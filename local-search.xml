<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>xv6-lab-lock</title>
    <link href="/2024/04/28/xv6-lab-lock/"/>
    <url>/2024/04/28/xv6-lab-lock/</url>
    
    <content type="html"><![CDATA[<h1 id="xv6-lab-lock-实验记录与分析"><a href="#xv6-lab-lock-实验记录与分析" class="headerlink" title="xv6-lab-lock 实验记录与分析"></a>xv6-lab-lock 实验记录与分析</h1><p><em><strong>写在前面</strong></em>: 这次关于使用lock的实验是关于多个进程之间通信的同步问题，在编写代码之前需要仔细地思考。特别是关于使用锁的顺序，中断是否开启之类的问题要格外注意。</p><hr><ul><li><a href="#kalloctest">kalloctest</a><ul><li><a href="#code">code</a></li></ul></li><li><a href="#buffer-cache">buffer-cache</a></li></ul><hr><h1 id="kalloctest"><a href="#kalloctest" class="headerlink" title="kalloctest"></a>kalloctest</h1><blockquote><p>在阅读这个实验的介绍时我感觉十分懵，原文说 **kalloctest prints (as “#fetch-and-add”) the number of loop iterations in acquire due to attempts to acquire a lock that another core already holds, for the kmem lock and a few other locks.**，我看了好久的这个实验介绍，同时也照着<code>kalloctest</code>的源码试着理解了这个测试的对象和测试原理。</p><p>在源码中我没有找到其中关于<code>fetch-and-add</code>部分的输出是哪来的，后来顺着执行步骤一步一步看，发现打印输出是一个<code>statistics()</code>函数来完成的，而这个函数本质上是读取一个名为<code>statistics</code>的文件，在xv6中使用ls命令后确实能找到这样的文件，但是它的文件类型为3,意思是<code>statistics</code>是一个设备文件，和<code>console</code>一样。经过一顿查找和跳转，终于是搞懂了这个信息是如何能打印出来的了：在xv6中将对所有文件的读取都用<code>read()</code>操作来实现，然后<code>read</code>再根据文件的不同类型来调用能具体实现的函数。在上述读取<code>statistics</code>设备的时候<code>read</code>被定向到了<code>statsread()</code>(stats.c) -&gt; <code>statslock()</code>(spinlock.c)。所以实际上也是通过将数据拷贝到用户进程的缓存区再通过<code>printf()</code>把数据通过串口打印出来。我也通过这个过程才初步理解了Unix中将一切视作文件的底层实现。</p><p>之前没有看见测试原理，对打印的一大堆东西都不太清楚，还是看见源码之后才能完全弄懂。本次lab测试的原理大概就是通过在<code>acquire()</code>函数获取锁的时候记录两个数据，首先是进入<code>acquire()</code>函数的次数，然后是在尝试获取锁, 但是锁实际上已经被拿走之后不断spin的次数。spin次数大致能反映了同一个锁被竞争的激烈程度，最后会统计竞争最激烈的Top5个锁。对于锁的分辨是通过在初始化的时候给<code>spinlock</code>的name字段赋值来的，所以要求中也强调在给每个锁定义名称的时候要以<code>kmem</code>开头。</p></blockquote><p>在解决了基本的读题障碍之后，就可以开始了。基本思路正如提升中所说，要给每一个CPU分配一个空闲内存的链表，这样每个CPU在进行内存动态分配的时候只使用自己的链表，会很大程度减少自旋锁之间的竞争问题。明显有一个需要解决的问题：当一个CPU已经没有空闲页面但是其他CPU还有的时候要从其他CPU<code>steal</code>部分空闲页面。</p><p>其实在做这个实验的时候我遇到两个最为主要的问题，一个就是如何从其他CPU<code>steal</code>内存。另一个是关于中断的开启与关闭问题。</p><ul><li>我关于<code>steal</code>部分的想法是，每次一个CPU没有内存的时候都会向还有空闲内存的CPU拿取一半的内存，每次都拿一半，这样我直观感受会比每次只拿一页稍微减少一点额外的<code>steal</code>开销，没有严格的数学计算，只是猜测。但是就是因为这个想法，让我调试了很久。因为在两个链表之间截取数据很容易出错，考虑用<code>r</code>还是<code>r-&gt;next</code>要十分仔细。空闲页面的奇偶性，应该拿取空闲链表的前半还是后半等等问题都让我考虑了很久。</li><li>在提示中有说到在调用<code>cpuid()</code>获取当前CPU号的时候要关闭中断，所以我之前简单地<code>push_off()-&gt;cpuid()-&gt;pop_off()</code>，实际上这样关闭中断是不够的。关闭中断主要是为了防止进程获取cpuid的后不被定时器中断而被调度到其他cpu上执行,否则就会产生CPU0对CPU1的链表进行操作的情况，这样显然是不对的。</li><li>最后曾经有一个比较疑惑的点：在直接启动xv6默认是用三个CPU核心，但是我们代码中的最大CPU数是8个。获取cpu号的方法是通过读取<code>tp</code>寄存器，没有机会在第4个寄存器上读取<code>tp</code>寄存器，所以虽然有8个<code>struct cpu</code>结构体但实际上却只用三个。</li></ul><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><p>为了能实现上述说的分配一半的页面，我在<code>kmem</code>结构体新增了一个字段用于记录剩余的空闲页面<code>freecount</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem</span>&#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>  <span class="hljs-type">int</span> freecount;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">freelist</span>;</span><br>&#125;;<br><br><span class="hljs-comment">// lock order: the least num hold lock first</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem</span> <span class="hljs-title">kmem</span>[<span class="hljs-title">NCPU</span>];</span><br></code></pre></td></tr></table></figure><p><code>kfree()</code>函数变化不大，主要是注意中断的关闭和对<code>freecount</code>更新。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">kfree</span><span class="hljs-params">(<span class="hljs-type">void</span> *pa)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span><br><br>  <span class="hljs-keyword">if</span>(((uint64)pa % PGSIZE) != <span class="hljs-number">0</span> || (<span class="hljs-type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)<br>    panic(<span class="hljs-string">&quot;kfree&quot;</span>);<br><br>  <span class="hljs-comment">// Fill with junk to catch dangling refs.</span><br>  <span class="hljs-built_in">memset</span>(pa, <span class="hljs-number">1</span>, PGSIZE);<br><br>  r = (<span class="hljs-keyword">struct</span> run*)pa;<br><br>  <span class="hljs-comment">// Safe for disable interupt</span><br>  push_off();<br>  <span class="hljs-type">int</span> id = cpuid();<br><br>  acquire(&amp;kmem[id].lock);<br>  r-&gt;next = kmem[id].freelist;<br>  kmem[id].freelist = r;<br>  kmem[id].freecount++;<br>  release(&amp;kmem[id].lock);<br><br>  pop_off();<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是关键的<code>kalloc()</code>，这个函数涉及到对页面的<code>steal</code>，所以我单独写了一个<code>steal()</code>函数用于被调用。关于在执行<code>steal()</code>函数期间会同时操作两个链表和<code>freecount</code>，所以毫无疑问是需要同时获取两把锁的，但是对于这 **两把锁的获取顺序是否有要求我还是保守地按照一定的顺序(cpu号小的先获取)**，尽可能避免<code>deadlock</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<br><span class="hljs-title function_">kalloc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span><br>  push_off();<br>  <span class="hljs-type">int</span> id = cpuid();<br><br>  acquire(&amp;kmem[id].lock);<br>  r = kmem[id].freelist;<br>  <span class="hljs-keyword">if</span>(r == <span class="hljs-number">0</span>)  <span class="hljs-comment">// empty for this freelist</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n = <span class="hljs-number">0</span>; n &lt; NCPU; n++)&#123;<br>      <span class="hljs-keyword">if</span>(n == id) <span class="hljs-keyword">continue</span>;<br>      <span class="hljs-keyword">if</span>(steal(id,n)==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// steal succeed</span><br>        r = kmem[id].freelist;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>  <br>  <span class="hljs-keyword">if</span>(r)&#123;<br>    kmem[id].freelist = r-&gt;next;<br>    kmem[id].freecount --;<br>  &#125;<br>  release(&amp;kmem[id].lock);<br><br>  pop_off();<br>  <span class="hljs-keyword">if</span>(r)<br>    <span class="hljs-built_in">memset</span>((<span class="hljs-type">char</span>*)r, <span class="hljs-number">5</span>, PGSIZE); <span class="hljs-comment">// fill with junk</span><br>  <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span>*)r;<br>&#125;<br><br><span class="hljs-comment">// return 0 when succeed, return -1 when the other CPU also empty.</span><br>uint64<br><span class="hljs-title function_">steal</span><span class="hljs-params">(<span class="hljs-type">int</span> takemem, <span class="hljs-type">int</span> givemem)</span><br>&#123;<br>  <span class="hljs-comment">// CPU which take mem must hold lock.</span><br>  <span class="hljs-comment">// and in this func must hold lock of CPU which give mem.</span><br>  <span class="hljs-comment">// consider locking order in case of deadlock.</span><br>  <br>  <span class="hljs-keyword">if</span>(!holding(&amp;kmem[takemem].lock))<br>    panic(<span class="hljs-string">&quot;steal lock&quot;</span>);<br><br>  <span class="hljs-keyword">if</span>(takemem &lt; givemem)<br>    acquire(&amp;kmem[givemem].lock);<br>  <span class="hljs-keyword">else</span>&#123;<br>    release(&amp;kmem[takemem].lock);<br>    acquire(&amp;kmem[givemem].lock);<br>    acquire(&amp;kmem[takemem].lock);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(kmem[takemem].freecount != <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;takemem:%d\n&quot;</span>,kmem[takemem].freecount);<br>    panic(<span class="hljs-string">&quot;steal:takemem&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span>(kmem[takemem].freelist != <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;takelist:%p\n&quot;</span>,kmem[takemem].freelist);<br>    panic(<span class="hljs-string">&quot;steal:takelist&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span>(kmem[givemem].freelist == <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">if</span>(takemem &lt; givemem)<br>      release(&amp;kmem[givemem].lock);<br>    <span class="hljs-keyword">else</span>&#123;<br>      release(&amp;kmem[takemem].lock);<br>      release(&amp;kmem[givemem].lock);<br>      acquire(&amp;kmem[takemem].lock);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-type">int</span> stl = (<span class="hljs-type">int</span>)((kmem[givemem].freecount+<span class="hljs-number">1</span>)/ <span class="hljs-number">2</span>);<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> * <span class="hljs-title">r</span> =</span> kmem[givemem].freelist;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c = <span class="hljs-number">0</span>; c &lt; stl<span class="hljs-number">-1</span>; c++)&#123;<br>    <span class="hljs-keyword">if</span>(r==<span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;round:%d,cpu:%d freecount:%d\n&quot;</span>,c, givemem,kmem[givemem].freecount);<br>      panic(<span class="hljs-string">&quot;steal r==0&quot;</span>);<br>    &#125;<br>    r = r-&gt;next;<br>  &#125;<br>  kmem[takemem].freelist = kmem[givemem].freelist;<br>  kmem[givemem].freelist = r-&gt;next;<br>  r-&gt;next = <span class="hljs-number">0</span> ;<br>  kmem[takemem].freecount += stl;<br>  kmem[givemem].freecount -= stl;<br><br>  <span class="hljs-keyword">if</span>(takemem &lt; givemem)<br>    release(&amp;kmem[givemem].lock);<br>  <span class="hljs-keyword">else</span>&#123;<br>    release(&amp;kmem[takemem].lock);<br>    release(&amp;kmem[givemem].lock);<br>    acquire(&amp;kmem[takemem].lock);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>xv6-Operating system</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unix/Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024第一次团建</title>
    <link href="/2024/04/28/2024%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%9B%A2%E5%BB%BA/"/>
    <url>/2024/04/28/2024%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%9B%A2%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="24年班级团建"><a href="#24年班级团建" class="headerlink" title="24年班级团建"></a>24年班级团建</h1><p>团建一定要轰轰烈烈吗？我看未必:</p><p>随便找一个操场，在班级群里通知一声，三五个同学结伴而来，围圈坐下就可以开始了。让同学们在繁重的学业中放松身心才是团建的目的。这样随意而轻松的模式才是我喜欢的方式。</p><p>回想起之前初进大学的时光，已经开始有些朦胧，时间就是这样，凡是使用过的日子，立即就会消失，抓不住，而且了无痕迹。也许正因为这样，人们才会热衷于创造让人深刻的回忆来留住些什么。我们在这个春天与夏天共存的下午，阳光也显得格外明媚，同学们纷纷来到约定的操场，想要留住现在的时光，创造属于我们的回忆。</p><p>我在文体委员借来的一个大音箱上首先点了一首欢快的《party!!》，音乐让我们愉悦，我们的身体随着欢快的鼓点微微律动，渐渐进入了开 <strong>party</strong> 的气氛。</p><p>首先开始的游戏是经典的”逢7过”，听名字可能会有些陌生，但是玩法却十分简单和有趣：大家按照大小顺序说一个数字，凡是数字里面有7或者被7整除的数字都需要跳过并拍手。如果没有按照要求来完成则会接受惩罚–“真心话和大冒险”。我影响比较深刻的是这个游戏有些地方比较容易上当，比如<code>91</code>,<code>84</code>这样不常用的7的整数倍的数字就很容易中招。还有当一个同学说完<code>69</code>时，由于从<code>70</code>开始的连续10个数都有7,所以好大一片连续的同学都要拍手，当时我还没有反应过来，现在回想才觉得<code>69</code>真是一个大坑。我运气比较好没有”中奖”，但是其他人就不一定了，还有同学连续”中奖”好几次，大家都很期待其他同学的搞笑瞬间。</p><p>后来玩的游戏也种类丰富：“逛三园”，“猪狗人”，“数字炸弹”等等。大家在接受”真心话大冒险”惩罚的时候也是多才多艺，有同学表演网络上段子的，把同学们都逗得哈哈大笑; 有同学唱歌的，吸引来一阵陶醉的目光; 有同学分享自己情感经历的，大家都为她们的甜蜜投去羡慕的眼神。</p><p>青岛校区靠海，虽然已经临近5月，阵阵海风还是带走了同学们身上的体温，但是却带不走我们心中的热情。为了暖暖身子，我提议我们来玩童年时期玩过的“丢手绢”。虽然规则已经记不太清，但是我却一直想玩这个游戏。</p><p>童年时期的音乐响起，丢手娟的同学正如歌词所说，将手娟轻轻地放在小朋友的后面。但是无奈还是被发现，转身拿起手娟就是追。可哪能让他轻易追到，一个逃一个追，可快乐了。这样几轮下来，同学们已经没有身体上的寒意，一直追不到的同学还有些热。轮到我的时候我可是追到了我们班的文体委员,他也借这个机会以一段表演结束了这次的团建。</p><p>记得有人曾说：“琉璃比玉贵重，玉里藏的是幻想，琉璃里装的是回忆”。生命中的碎玉琉璃无形的记载着我们每一天面临的，经历的，它使我们变得独特，变得深刻和不平庸。</p>]]></content>
    
    
    <categories>
      
      <category>diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>life_of_campus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xv6-lab-thread</title>
    <link href="/2024/04/23/xv6-lab-thread/"/>
    <url>/2024/04/23/xv6-lab-thread/</url>
    
    <content type="html"><![CDATA[<h1 id="xv6-lab-thread-实验记录与分析"><a href="#xv6-lab-thread-实验记录与分析" class="headerlink" title="xv6-lab-thread 实验记录与分析"></a>xv6-lab-thread 实验记录与分析</h1><p><em><strong>写在前面</strong></em>: 这次实验花费的时间远远高于我的预期以及官网上标注的难度(三个moderate).主要原因是在后面两个实验中查询的资料和最后一个<code>barrier</code>实验比较麻烦。由于数据结构的部分只是简单自学的，所以在做这个实验中还复习了散列表的一些知识, 也仔细阅读了”APUE”的关于本次实验关于线程的相关章节。</p><hr><ul><li><a href="#uthread">uthread</a></li><li><a href="#pthread">pthread-using</a><ul><li><a href="#hash-table">hash-table</a></li><li><a href="#multi-thread">multi-thread</a></li><li><a href="#code">code</a></li></ul></li><li><a href="#barrier">barrier</a><ul><li><a href="#condition-variable">condition-variables</a></li><li><a href="#code">code</a></li></ul></li></ul><hr><h1 id="uthread"><a href="#uthread" class="headerlink" title="uthread"></a>uthread</h1><p>在用户态进行线程切换和在内核中本质没有什么区别，都需要在切换上下文的时候对<code>callee register</code>进行保存,对于每一个线程都需要分配一个<code>struct thread</code>结构体用来保存。这个结构体是存放在进程的地址空间，在xv6中调度的最小单位是一个进程(包括这个进程的用户态线程和内核态线程)。所以在<code>uthread lab</code>中线程的切换是每个线程自己放弃CPU的，在目前的xv6中没有一种措施来强制让一个进程中的线程进行抢占式调度。所以在这个lab中只需要做好线程的创建和线程之间的上下文切换问题即可。</p><p>线程的创建主要是做好线程执行的入口地址以及线程运行的栈空间的配置。仿照<code>allocproc()</code>中配置如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <br><span class="hljs-title function_">thread_create</span><span class="hljs-params">(<span class="hljs-type">void</span> (*func)())</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread</span> *<span class="hljs-title">t</span>;</span><br><br>  <span class="hljs-keyword">for</span> (t = all_thread; t &lt; all_thread + MAX_THREAD; t++) &#123;<br>    <span class="hljs-keyword">if</span> (t-&gt;state == FREE) <span class="hljs-keyword">break</span>;<br>  &#125;<br>  t-&gt;state = RUNNABLE;<br>  <span class="hljs-comment">// YOUR CODE HERE</span><br>t-&gt;context.ra = (uint64)func;<br>t-&gt;context.sp = (uint64)t-&gt;<span class="hljs-built_in">stack</span> + STACK_SIZE;<br>&#125;<br></code></pre></td></tr></table></figure><p>上下文的切换仍然需要借助汇编来完成，首先需要在线程结构体中先定义一个字段来存放上下文<code>context</code>，内容和在内核中的一模一样，我直接复制的<code>struct context</code>定义。另外在<code>uthread_switch.S</code>中的内容和<code>swtch.S</code>也除了函数名一模一样，所以在做完上述的枯燥的复制工作之后就只剩下一行代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">  <span class="hljs-comment">/* YOUR CODE HERE</span><br><span class="hljs-comment">   * Invoke thread_switch to switch from t to next_thread:</span><br><span class="hljs-comment">   * thread_switch(??, ??);</span><br><span class="hljs-comment">   */</span><br>thread_switch((uint64)&amp;t-&gt;context,(uint64)&amp;next_thread-&gt;context);<br></code></pre></td></tr></table></figure><p>然后我刚想开始调试就发现已经做完了^_^.</p><h1 id="pthread"><a href="#pthread" class="headerlink" title="pthread"></a>pthread</h1><p>这个实验和后面的barrier实验都是在自己电脑的实际操作系统下进行的，使用的是真正的遵循 <strong>Single UNIX Specification</strong>的linux提供的函数接口，线程调度也由真正的linux内核来完成。想想还是有点激动的。</p><h2 id="hash-table"><a href="#hash-table" class="headerlink" title="hash-table"></a>hash-table</h2><p>虽然散列表在这个实验中只是形式上使用了一下，但是我也借助这个机会回去翻了翻我的那本黑皮书，复习了一些数据结构的知识。</p><p>散列表(又称哈希表)正如其名称所示，是将众多数据按照一定的规律分类排列的过程，可能这就是叫散列表的原因。这个分类的依据就是根据一个叫散列函数的标准，这个函数的选取十分关键，要尽可能使得大量的数据在每个分类中均匀，这样才能获得更好的性能。散列函数涉及到很多的数学知识,本例中就是根据数据除以一个素数的余数来分类，这是最简单的散列函数。</p><p>分类之后，需要找到一种方式将同一个种类的数据按照一定规律存放，这个存放方式粗略分为分离链接法和开放定址法。分离链接法本质就是一串串链表，由于比较简单，在本次实验中也是使用的这个方法。每一个分类都是一个单独的链表，可以选择是否加入表头(head)，由于加入表头会损失一定的空间和带来额外的插入开销。最突出的优势是当发生节点的删除的时候比较方便，所以当对节点的操作大多都是插入而没有删除的的情况下应该避免使用表头，本次实验的就不涉及节点的删除没有使用表头。</p><h2 id="multi-thread"><a href="#multi-thread" class="headerlink" title="multi-thread"></a>multi-thread</h2><p>多线程编程一个重要的问题就是如何对各个线程之间进行同步，要保证在多个线程共享一个相同的内存时，维持数据的一致性。当且仅当多个线程共享一个内存区域的时候至少一个线程对该内存区域修改才会产生上述的一致性问题，有时候称为竞争条件(race condition)。</p><p>为了解决这个同步的问题，有比较多种解决方法。使用互斥量(锁)就是其中一种，当然不一定是最好的，不过不叫主流和容易理解。下一个实验<code>barrier</code>使用的信号量和条件变量也是基于互斥量实现的。</p><p>在什么条件下使用锁？上述说到的情况是一定需要用的，如果需要更加严格的执行顺序，可以扩大锁的范围。值得注意的是：在上述存在竞争条件的情况下，即使是读取也要用锁来保护，因为普通的读取不是原子操作，很有可能在不加入锁的情况下在读到一半数据就被更改，造成明明是读取一个变量，得到的结果却和此刻该变量的值不一样。我忽略过这一点，造成了一些问题。</p><p>在使用锁的过程中，最容易发生也是最严重的问题就是发生<code>deadlock</code>死锁。用一把锁的时候死锁比较容易发现。但是如果使用多把锁，就变得难以发现和调试了。APUE中有着对使用多把锁的参考案例在图11-11，我对其进行了阅读和相应的理解，虽然本次实验不会用到多把锁。<br><img src="/2024/04/23/xv6-lab-thread/multi_lock1.png" alt="multi-lock"><br><img src="/2024/04/23/xv6-lab-thread/multi_lock2.png" alt="multi-lock"><br><img src="/2024/04/23/xv6-lab-thread/multi_lock3.png" alt="multi-lock"></p><p>有兴趣的同学可以自己阅读，我在这里只是想记录一下我觉得最为关键的部分：锁保护着不变量(invariant),在这里<code>hashlock</code>保护的是全局变量<code>fh</code>和散列链字段<code>f_next</code>, <code>fp-&gt;lock</code>保护的是一个结构体中其他字段(因为有可能多个线程同时需要访问某一个结构体)。<code>foo_rele()</code>函数主要是用来释放对数据对象的引用，这时候会出现两种情况</p><ul><li>一个线程当进入<code>foo_rele()</code>函数后发现除了自己还有其他线程在引用同一个数据对象即<code>f_count &gt; 1</code>。那么这个线程要做的事情只用对当前这个结构体的<code>f_count</code>进行写入操作, 由于不涉及对全局的散列表<code>fh</code>以及链表进行操作，所以很愉快的只申请了一个<code>fp-lock</code>然后改完<code>f_count</code>就将锁释放后返回。不用对<code>hashlock</code>做任何操作，因为这个过程不涉及它保护的invariant.</li><li>剩下的一种情况就比较复杂,当一个线程发现它是最后一个对数据进行引用的时候，就需要真正地做一系列<code>release</code>操作。这个回收空间的操作不可避免会用到全局散列表<code>fh</code>和链表,这意味着必须要先申请<code>hashlock</code>。而为了避免两个线程互相占有不同的锁带来的死锁，就需要按照先<code>fp-lock</code>再<code>hashlock</code>的顺序。这也是为什么要先释放，再重新获取的原因。此外，考虑到从<code>pthread_mutex_unlock(&amp;fp-&gt;lock);</code>到<code>pthread_mutex_lock(&amp;hashlock);</code>的这个空隙, invariant不受锁的保护，可能有其他的线程在这个期间更改一些参数，所以在代码中我们需要recheck。</li></ul><p><strong>lock protect invariant</strong>,在使用锁的过程中要搞清楚一把锁到底保护的什么不变量，不会违背不变量的时候可以不用锁，这样才能有效的使用锁这个工具。</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><p>在了解线程之间交互的基本逻辑的注意事项之后，再来完成本次实验就相对容易了。实验想要达成的目的是使用多个线程来完成对数据的存取，在避免<code>race condition</code>的同时也要兼顾程序运行的并行性。</p><p>单个线程的执行是没有问题的，本质上避免竞争条件的关键就是将可能发生竞争条件的代码部分给串行化，在尝试过将<code>put()</code>和<code>get()</code>无脑加上锁之后，我发现这样代码的执行效率不增反降，因为多了申请和释放锁的开销。所以需要进行优化，网络上的参考代码是降低了锁的粒度来获取较高的并行性，但是我觉得即使用一把锁也能够获得同样高的并行性。</p><p>首先，分析数据丢失的原因是多于一个线程对链表的头节点进行访问， <strong>并且至少有一个线程对其进行更改</strong>,那么，看实验的对散列桶的访问是将<code>put</code>和<code>get</code>分开的，所以当代码执行到<code>get()</code>部分的时候就不存在对全局变量进行写入的线程了，结论就是，在<code>get()</code>函数中不用加锁。</p><p>再来看<code>put()</code>函数部分，肯定是需要加入锁来避免竞争条件的，在原来的代码中是直接将<code>table[i]</code>和<code>&amp;table[i]</code>作为参数传递给<code>put()</code>。这样有一个弊端，用一把锁的话，想要加锁必须把<code>put()</code>整个给锁住。所以我更改了<code>put()</code>的函数参数,只用传递<code>key：value</code>，计算散列的部分给放在了<code>put()</code>里面进行。</p><p>经过测试，发现大部分的时间是在<code>for</code>循环中找到key值，这个过程也不会发生竞争条件，所以就将这部分给放在锁的外面并行执行。同时在<code>insert()</code>函数中也对全局变量进行了更改，所以应该对<code>insert()</code>处理，观察之后发现<code>insert()</code>都是一些常数时间的操作。唯一需要花费较多时间的就是<code>malloc()</code>了，会发生一些<code>system call</code>造成在用户态和内核态之间切换的开销。为了尽可能高效，我将<code>malloc()</code>放在了锁外并行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <br><span class="hljs-type">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span><br>&#123;<br>  <span class="hljs-type">int</span> i = key % NBUCKET;<br><br>  <span class="hljs-comment">// is the key already present?</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">entry</span> *<span class="hljs-title">e</span> =</span> <span class="hljs-number">0</span>;<br>pthread_mutex_lock(&amp;hashlock);<br>e = table[i];<br>pthread_mutex_unlock(&amp;hashlock);<br>  <span class="hljs-keyword">for</span> (; e != <span class="hljs-number">0</span>; e = e-&gt;next) &#123;<br>    <span class="hljs-keyword">if</span> (e-&gt;key == key)<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(e)&#123;<br>    <span class="hljs-comment">// update the existing key.</span><br>    e-&gt;value = value;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// the new is new.</span><br>    insert(key, value, i);<br>  &#125;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <br><span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value, <span class="hljs-type">int</span> i)</span> <br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">entry</span> *<span class="hljs-title">e</span> =</span> <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> entry));<br>  e-&gt;key = key;<br>  e-&gt;value = value;<br>pthread_mutex_lock(&amp;hashlock);<br>  e-&gt;next = table[i];<br>  table[i] = e;<br>pthread_mutex_unlock(&amp;hashlock);<br>&#125;<br></code></pre></td></tr></table></figure><p>测试可见，用一个锁也能得到近似两倍的执行效率。<br><img src="/2024/04/23/xv6-lab-thread/test_pthread.png" alt="test_pthread"></p><h1 id="barrier"><a href="#barrier" class="headerlink" title="barrier"></a>barrier</h1><p>本次实验的核心目的是设置一个屏障，让多个线程在运行的过程中保证只有当所有线程都到达设置好的屏障之后，这些线程才会进行下一步的执行，速度较快的线程会等待速度较慢的线程。</p><p>本次实验主要用到的函数是在POSIX规范中的<code>pthread_cond_wait()</code>和<code>pthread_cond_broadcast()</code>。关于这两个接口的性质我参考的APUE第11章条件变量部分。在开始写程序之前，首先要了解条件变量:</p><h2 id="condition-variable"><a href="#condition-variable" class="headerlink" title="condition-variable"></a>condition-variable</h2><p>条件变量的思想类似于<code>xv6</code>中的<code>sleep()</code>,<code>wakeup()</code>机制.关于这部分详细可以在教材chapter7的section5查看。这样的机制提供了一种 <strong>在等待一个条件满足的时候，不会阻塞</strong>，这区别于之前简单的<code>while</code>循环等待某个条件满足，让CPU在等待条件的时候将不满足条件的线程<code>sleep</code>，转而执行其他可以执行的线程。</p><p>由于简单的 <strong>条件判断到sleep之间不是原子性的</strong>,这就会导致出现经典的由于竞争条件导致的 <strong>lost wake-up problem</strong>，解决方法是加入锁来维护判断到sleep的原子性。由于基本上每个线程都会有锁来防止线程之间的<code>race condition</code>，将上述过程加入锁的范围之后，锁维护的<code>invariant</code>就随之增加了。</p><p>由于想要实现的目的是让一个线程sleep的时候其他线程可以执行，但是由于sleep之前获取了锁，如果不进行处理，其他线程想要获取相同的锁就会<code>deadlock</code>。所以在进入<code>pthread_cond_wait()</code>的同时将锁一并传入，在真正释放CPU控制权的时候先将之前获取的锁释放，这样其他线程在被调度之后就能够重新获取锁。一个休眠线程被<code>pthread_cond_broadcast()</code>唤醒后，会重新获取锁然后返回。所以一个休眠的过程会额外产生两次对锁的操作，并且这个过程对于用户线程是不可见的。</p><p>需要注意的是：在进入休眠到成功唤醒这个时间段其他线程是有机会对条件进行更改的,所以需要在线程被唤醒之后重新检查条件是否满足，APUE中也表达了同样的观点。<br><img src="/2024/04/23/xv6-lab-thread/cond_recheck.png" alt="cond_recheck"></p><h2 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h2><p>关于代码部分，我在网络上也看过其他人写的版本：<a href="https://xv6.dgs.zone/labs/answers/lab7.html">参考版本</a>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <br><span class="hljs-title function_">barrier</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-comment">// 申请持有锁</span><br>  pthread_mutex_lock(&amp;bstate.barrier_mutex);<br><br>  bstate.nthread++;<br>  <span class="hljs-keyword">if</span>(bstate.nthread == nthread) &#123;<br>    <span class="hljs-comment">// 所有线程已到达</span><br>    bstate.round++;<br>    bstate.nthread = <span class="hljs-number">0</span>;<br>    pthread_cond_broadcast(&amp;bstate.barrier_cond);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 等待其他线程</span><br>    <span class="hljs-comment">// 调用pthread_cond_wait时，mutex必须已经持有</span><br>    pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);<br>  &#125;<br>  <span class="hljs-comment">// 释放锁</span><br>  pthread_mutex_unlock(&amp;bstate.barrier_mutex);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个版本我复制过来之后尝试过，确实可以正常通过测试。但是注意到在上面的代码中当线程没有全部到达的时候，直接调用了<code>pthread_cond_wait()</code>一次，没有刚刚APUE中说到的在被唤醒之后重新检查条件是否满足。这样的情况下，就可以在最后一个线程到达之后，先将<code>nthread</code>置零然后才调用<code>pthread_cond_broadcast()</code>,由于在被休眠的线程中没有再进行<code>recheck</code>所以一定会继续向下执行。</p><p>现在来考虑一个线程唤醒之后执行<code>round + 1</code>，然而其他的线程还在<code>round</code>的情况：由于保证了每次最后一个线程到达之后都确保了将<code>bsate.nthread</code>置零，所以上述的情况在<code>bstate.nthread ++</code>的时候都是确保从0开始的，就避免了一系列的问题。</p><p>然而，我在开始写本次的程序的时候是按照APUE的方式对每一次唤醒都重新检查一次条件是否满足，所以导致了很多麻烦的情况。下面是我写的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <br><span class="hljs-title function_">barrier</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> wakeup = <span class="hljs-number">0</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">pthread_cond_t</span> fast_cond = PTHREAD_COND_INITIALIZER;<br>pthread_mutex_lock(&amp;bstate.barrier_mutex);<br><span class="hljs-keyword">if</span>(nthread == <span class="hljs-number">1</span>) bstate.round ++;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span>(bstate.nthread == nthread)&#123;<br>pthread_cond_wait(&amp;fast_cond,&amp;bstate.barrier_mutex);<br>&#125;<br>bstate.nthread ++;<br><span class="hljs-keyword">if</span>(bstate.nthread != nthread)&#123;<br><span class="hljs-keyword">while</span>(bstate.nthread != nthread)&#123;<br>pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);<br>&#125;<br>wakeup ++;<br><span class="hljs-keyword">if</span>(wakeup == nthread <span class="hljs-number">-1</span>)&#123;<br> bstate.nthread = <span class="hljs-number">0</span>;<br>pthread_cond_broadcast(&amp;fast_cond);<br>wakeup = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>bstate.round ++;<span class="hljs-comment">//only if all thread called barrier()</span><br><span class="hljs-keyword">if</span>(bstate.nthread == nthread)&#123;<br>pthread_cond_broadcast(&amp;bstate.barrier_cond);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error: nthread not equal\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br>&#125;<br>&#125;<br>  pthread_mutex_unlock(&amp;bstate.barrier_mutex);<br>&#125;<br></code></pre></td></tr></table></figure><p>很显然复杂了不少，我新增了两个变量来解决下列问题:</p><ul><li>首先，在需要进行条件recheck的情况下，是绝对不能在一个线程还在休眠的时候就对条件进行更改的。这样会使得被休眠的线程唤醒之后又发现条件不满足，然后重新进入休眠。</li><li>其次，需要仔细考虑上述的当一个线程被唤醒但是没有被调度器给予CPU来执行的时候，其他线程进入了下一个<code>round</code>。现在的情况下，<code>bstate.nthread ++</code>的时候不是确保从0开始的，所以会导致<code>bstate.nthread</code>的数值发生异常，本来应该是唤醒其他线程的最后一个线程进入的休眠，从而所有线程都在休眠。</li></ul><p>为了解决第一个问题，我尝试了不同的很多不同的方法，最后用一个<code>wakeup</code>变量解决了这个问题。<code>wakeup</code>变量记录了有多少线程因为满足条件从而离开休眠状态，因为最后一个线程不会进入等待休眠，所以正常的<code>wakeup</code>最大应该是<code>nthread-1</code>。仅当全部线程都被唤醒之后才改变条件，不会导致由于在有线程休眠的时候条件被改变然后进入无尽休眠。<br><img src="/2024/04/23/xv6-lab-thread/debug_source.png" alt="debug_source"></p><p>单独这样还不够，上述说的第二个问题，还没有得到解决。通过很多<code>printf()</code>输出状态信息如下，我以开启3个线程为例：<br><img src="/2024/04/23/xv6-lab-thread/debug_output.png" alt="debug_output"></p><p>观察上述图片中的wrong部分，有三个不同<code>threadid</code>的线程用ABC代替，首先AB线程进入休眠，C线程对AB线程进行唤醒。然后B线程醒来，由于是第一个线程，所以<code>bstate.nthread</code>不会置零，然后错误发生了 <strong>在本来应该是A线程醒来的时机，B线程没有失去对CPU的控制，转而进入了下一个循环</strong>,进入循环之后<code>bstate.nthread++</code>以 **<code>bstate.nthread == 4</code>**的状态进入了休眠。这下就乱套了，A线程在<code>bstate.nthread</code>为4的时候醒来，发现条件不满足又进入了休眠。更不用不说C线程将<code>bstate.nthread</code>增加到5再休眠了。</p><p>解决的方法是像上面的代码一样，新增一个信号量。但是我在实际写代码的时候即使发现了原因，还是没有很快地解决这个问题。因为判断什么时候一个线程是由于执行太快而进入<code>barrier()</code>是一个比较麻烦的问题。同样我尝试了很多种方式定义了一系列变量等等，但是两个线程上之间实际上对于新定义的变量又会产生竞争条件，所以我不想把问题进一步复杂化。最后仔细回顾了整个过程，发现当进入<code>barrier()</code>的时候可以根据<code>bstate.nthread != nthread</code>区分。</p><p>此外，在我调试的过程中还发现一个小细节的问题，<code>pthread_cond_broadcast(&amp;fast_cond);</code>这句代码应该放在最后一个线程确认唤醒之后再执行，否则如果每一个线程唤醒都执行一次的话，就有可能导致在所有线程都被唤醒之前提前使得进入下一个循环的速度较快的线程被唤醒，从而失去了我们想要达成的效果。<br><img src="/2024/04/23/xv6-lab-thread/debug_4thread.png" alt="debug_4thread"></p><blockquote><p><em>至于到底要不要吧<code>pthread_cond_wait()</code>放在循环里用来recheck条件,我咨询老师之后觉得是要根据实际情况来看的，当只需要起到一个同步所有线程的目的的时候比如上述的<code>barrier()</code>看起来就可以不用recheck。但是如果线程之后的操作需要用到那个条件就一定需要recheck</em></p></blockquote><hr><p>最后贴上成功通过测试的截图纪念。<br><img src="/2024/04/23/xv6-lab-thread/succeed.png" alt="succeed"></p><hr><p><em><strong>写在最后</strong></em>：感谢能读到这里，希望没有浪费您宝贵的时间，如果觉得还不错，不要吝啬手中的赞呦~。</p><blockquote><p>加以修改后的源代码放在了<a href="https://github.com/sycamoremoon/xv6-labs-2023">sycamoremoon’s github</a>,需要的同学可以自取。</p><p>之后还会有其他的内容上传，希望我的小小努力能够给大家带来帮助</p><p>这是<a href="sycamoremoon.online">我的网站</a>，内容会随着时间逐渐丰富的..</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>xv6-Operating system</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unix/Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xv6-lab-COW</title>
    <link href="/2024/04/18/xv6-lab-COW/"/>
    <url>/2024/04/18/xv6-lab-COW/</url>
    
    <content type="html"><![CDATA[<h1 id="xv6-lab-COW-实验记录与分析"><a href="#xv6-lab-COW-实验记录与分析" class="headerlink" title="xv6-lab-COW 实验记录与分析"></a>xv6-lab-COW 实验记录与分析</h1><p><em><strong>写在前面</strong></em>: 本次实验花费了超出我预期很多的时间来完成。分析原因是在测试的时候出现了大大小小很多问题，其中最关键的问题就是 <strong>Lost Pages</strong>, 刚开始我一直以为是我在哪里忘记<code>kfree()</code>回收了，但是后来看了对应的Lecture才发现是缺少自旋锁, 发生了 <strong>竞争条件(race condition)</strong> 。此外这次记录文字比较密集请见谅。</p><hr><ul><li><a href="#Copy-On-Write">Copy-On-Write</a></li><li><a href="#Lecture12">Lecture12</a></li><li><a href="#Race-Condition">Race-Condition</a></li><li><a href="#code">code</a></li></ul><hr><h1 id="Copy-On-Write"><a href="#Copy-On-Write" class="headerlink" title="Copy-On-Write"></a>Copy-On-Write</h1><p>当时一开始在做这个部分的时候还是比较清晰，因为COW的策略其实比较清晰，官网上也给出了比较详细的提示。所以把握好COW的核心思想就能正常完成绝大部分的内容。</p><p>COW的策略现在在我看来相对清晰了，主要就是为了减少由于<code>fork()</code>造成了页面复制开销，因为有一半以上的父进程在<code>fork</code>出子进程之后，子进程立即<code>exec()</code>. 所以在<code>fork()</code>期间复制的所以页面就会被无意义的丢弃掉。此外，对于某些只读的进程复制页面也属于一种时间和空间的浪费。COW策略是节省了类似上述两种情况的开销，加入子进程并没有<code>exec()</code>而是不断的读写<code>fork()</code>的页面，那么COW不仅没有节省开销反而在这个基础上增加了n次<code>trapin</code>和<code>trapout</code>的上下文切换带来的开销。</p><p>要想实现COW，有几个很关键的地方需要注意：</p><ol><li>为了不破坏父子进程之间的隔离性，任何对共享内存的更改都应该只对自身可见，所以利用页表机制的<code>store page fault</code>可以动态地更新映射关系，使原来指向的共享物理页面改为自己的私有物理页面。</li><li>对于每一个页表的每一个PTE都应该仔细考虑。在<code>fork()</code>过程中，应该清除<code>PTE_W</code>权限才能导致<code>page fault</code>的发生。而在处理<code>page fault</code>的程序中，应该将<code>PTE_W</code>添加上，同时 <strong>由于需要对一个新的物理页面进行映射，所以应该将原有PTE的权限位完全复制到新的PTE中</strong>。如果使用了PTE的保留位，也应该对该位进行配套的处理。</li><li>由于现在的COW机制允许将不同PTE映射至同一个物理页面，所以在进行<code>kfree()</code>的时候就应该对释放空间的机制进行调整。当且仅当最后一个PTE指向物理页面的时候才能真正地释放物理空间。我首先想到的是对于<code>kalloc()</code>和<code>kfree()</code>操作的每一个数据都包装成为一个结构体，里面包含了物理地址信息和引用次数，但是提示中说道可以用一个大数组来对应表示每一个物理页面的引用次数，觉得这样更直接，就用了提示中的方法，没有想到会真的存在 <strong>竞争条件</strong>的问题.</li><li>正如在<code>lazy allocation</code>实验中遇到的问题一样，应该处理当用户进程向内核传递一个使用COW策略的地址的情况，首先肯定不能直接写，这样就同时更改了所用使用这个物理页面的进程信息。其次在内核中的<code>copyout()</code>是用软件<code>walk</code>出物理地址的，所以没办法直接产生<code>page fault</code>。需要用软件判断一些标志来决定是直接写还是得重新分配页面之后再写。</li></ol><p>当实现上述说的特性之后，简单的COW就可以被实现了。只需要注意一些特殊情况的有效性，比如判断地址的有效范围，判断标志位等等。由于这个时候的代码太过于难看，我自己都讨厌，而且有下面说的问题没解决，所以就不贴了,要是想看看反面教材的话可以在github中的提交历史中找到。<a href="#code">重构后代码跳转</a></p><p>由于刚才使用全局变量数组来存放一个页面的引用次数，而且没有使用锁来处理 <strong>竞争条件</strong>, 所以会导致发生奇怪的问题。最直观的体现就是<code>Lost Page</code>.<br><img src="/2024/04/18/xv6-lab-COW/lost_page.png" alt="Lostpage"></p><blockquote><p><em>我能想到的一种最简单的可能性就是：两个进程同时<code>kfree()</code>,同时读取引用次数（假设2），然后都进入了不真正释放只减少引用的代码分支。然而已经没有其他进程引用这个物理页面了，仅有的两次<code>kfree()</code>机会都已经用完了。这个物理页面被丢失了, 无论那个物理页面的引用次数被减少了几次都无所谓了。</em></p></blockquote><h1 id="Lecture12"><a href="#Lecture12" class="headerlink" title="Lecture12"></a>Lecture12</h1><p>当时发现对于这次的COW实验还单独开设了一节答疑课还挺高兴的，听完教授做这次实验的全部过程，我不禁感叹: <strong>优雅，是在是太优雅了</strong>。</p><p>教授完全是和我们一样从0开始一步一步的开始整个实验，他所用的调试内核的策略是: <strong>take a baby step -&gt; get wrong -&gt; debugging and finding why -&gt; take another baby step</strong>。而我反思了一下我做实验的这个步骤: <strong>think a lot -&gt; try to do all i can do -&gt; get wrong -&gt; find something i was missing -&gt; stuck…</strong> 。当然我觉得想清楚再做肯定是没问题的，但是一步做的事情不要太多，否则出现问题的时候再回来找曾经疏漏的地方时就异常困难，甚至花费好几倍的时间。</p><p>我还注意到了一点我和教授的差距：每当教授想要写一个新函数或者实现一个新功能， <strong>首先他是在考虑有哪些非法情况我们需要排除，停下来好好想想之后再开始写主要功能。并且在很多不应该出现的情况后面加上<code>printf()</code>或者<code>panic()</code>输出错误信息。</strong> 而我却是一开始就写上了主要功能，有时候也懒得写调试语句，所以发生错误就得花费很久的时间去gdb一步一步调试。</p><p>发生错误或者<code>panic()</code>的时候，我本能地有些慌张，错误信息只是匆匆看一眼，对于调试这个不知道因为好几个蝴蝶效应才产生的错误有些恐惧。但是教授却显得很从容和兴奋，仔细观察错误信息然后推理和猜测，最终很快解决这个问题。</p><p>看了教授写的代码，我再来看我自己写的就惨不忍睹了，代码复用很少，也不利于调试和重构。于是我在我自己的思路上仿照教授的风格重新写了一份作为接下来的参考。</p><h1 id="Race-Condition"><a href="#Race-Condition" class="headerlink" title="Race-Condition"></a>Race-Condition</h1><p>在真正面临这个问题之前我是了解过一点 <strong>race condition</strong>的，只不过真正要解决的时候又有一点迷茫了。作为下一个实验的衔接，简单来说，当使用全局变量的时候就应该要考虑 <strong>race condition</strong>，这个条件可能根据实际情况稍微有所变化。</p><p>当时知道是由于没有加锁之后，我尝试在原来的代码上更改，但是原来的版本我并没有选择在<code>kfree()</code>中减少引用，而是直接在相应的<code>usertrap</code>和<code>copyout</code>函数中直接对那个全局数组进行操作，所以相应的就得在很多地方<code>acquire and release</code>.一不小心就<code>deadlock</code>。增加引用的操作也没有模块化，得一个一个<code>acquire and release</code>。现在回想真是一个糟糕的经历。</p><p>然后就是关于锁的选择，目前浅显的理解是锁是用来将原来并行的代码强制串行化的。在代码没有问题的基础上，串行执行是保证没有问题的，但是我们为了让执行速度更快，让好几个CPU同时执行不同的进程，这才导致了<code>race condition</code>。所以总结一下，既然串行执行没问题，那么极端一点，整个内核用一把锁也对执行的正确性没有问题。实际上有这么多的锁完全是为了提高代码的执行速度。在这个情况下，对于要不要初始化一把新的锁每个人都有自己的理解。</p><p>速度和简单总得选一个，由于我在这里对速度没有过多的要求，同时对锁的概念也不够了解，于是简单地将全局数组和<code>freelist</code>设置为共用一把锁，所以没有初始化一把新的锁。</p><p>下面是重构后的代码, 值得注意的是在代码中对一些异常的判断，这在调试中非常关键：</p><h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><p>首先需要在<code>uvmcopy()</code>中放弃整个页面的复制，从而只复制PTEs和清除<code>PTE_W</code>标志位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">uvmcopy</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> old, <span class="hljs-type">pagetable_t</span> new, uint64 sz)</span><br>&#123;<br>  <span class="hljs-type">pte_t</span> *oldpte, *newpte;<br>  uint64 pa, i;<br><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; sz; i += PGSIZE)&#123;<br>    <span class="hljs-keyword">if</span>((oldpte = walk(old, i, <span class="hljs-number">0</span>)) == <span class="hljs-number">0</span>)<br>      panic(<span class="hljs-string">&quot;uvmcopy: pte should exist&quot;</span>);<br>    <span class="hljs-keyword">if</span>((*oldpte &amp; PTE_V) == <span class="hljs-number">0</span>)<br>      panic(<span class="hljs-string">&quot;uvmcopy: page not present&quot;</span>);<br>pa = PTE2PA(*oldpte);<br>*oldpte &amp;= ~PTE_W;<br>*oldpte |= PTE_COW;<br>newpte = walk(new, i, <span class="hljs-number">1</span>);<br>*newpte = *oldpte;<br>pagerfcnt[(pa - FREESTART)/PGSIZE] += <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>维护一个存放引用次数的全局数组，同时对<code>kfree()</code>和<code>kalloc()</code>进行调整。全局数组的大小至少要对应所有的<code>freepage</code>，这个区间是<code>end</code>到<code>PHYSTOP</code>的页数，当然大一点也可以，教授就是申请了一些多余的空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// after print the address of end[]</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FREESTART PGROUNDUP(0x80046000L)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PA2REF(pa)  (pagerfcnt[(PGROUNDDOWN(pa) - FREESTART)/PGSIZE])</span><br><br><span class="hljs-type">int</span> pagerfcnt[(PHYSTOP-FREESTART)/PGSIZE] = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//reference count for each page.</span><br><br><span class="hljs-comment">// when allocate new page, set the reference to 1</span><br><span class="hljs-type">void</span> *<br><span class="hljs-title function_">kalloc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span><br><br>  acquire(&amp;kmem.lock);<br>  r = kmem.freelist;<br>  <span class="hljs-keyword">if</span>(r)&#123;<br>    kmem.freelist = r-&gt;next;<br><span class="hljs-keyword">if</span>(PA2REF((uint64)r) != <span class="hljs-number">0</span>) panic(<span class="hljs-string">&quot;kalloc ref\n&quot;</span>);<br>PA2REF((uint64)r) = <span class="hljs-number">1</span>;<br>&#125;<br>  release(&amp;kmem.lock);<br><br>  <span class="hljs-keyword">if</span>(r)<br>    <span class="hljs-built_in">memset</span>((<span class="hljs-type">char</span>*)r, <span class="hljs-number">5</span>, PGSIZE); <span class="hljs-comment">// fill with junk</span><br>  <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span>*)r;<br>&#125;<br><br><span class="hljs-comment">//when calling kfree two method to deal with it</span><br><span class="hljs-comment">//one is decrease reference and return</span><br><span class="hljs-comment">//one is decrease reference and really free</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">kfree</span><span class="hljs-params">(<span class="hljs-type">void</span> *pa)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span><br><br>  <span class="hljs-keyword">if</span>(((uint64)pa % PGSIZE) != <span class="hljs-number">0</span> || (<span class="hljs-type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)<br>    panic(<span class="hljs-string">&quot;kfree&quot;</span>);<br><br>acquire(&amp;kmem.lock);<span class="hljs-comment">//to avoid race condition, acquire the lock</span><br><span class="hljs-keyword">if</span>(PA2REF((uint64)pa) &lt; <span class="hljs-number">0</span>)<br>panic(<span class="hljs-string">&quot;kfree ref\n&quot;</span>);<br>PA2REF((uint64)pa) -= <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> tmp = PA2REF((uint64)pa);<br>release(&amp;kmem.lock);<br><br><span class="hljs-keyword">if</span>(tmp != <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span>;<br><br><span class="hljs-comment">// Fill with junk to catch dangling refs.</span><br><span class="hljs-built_in">memset</span>(pa, <span class="hljs-number">1</span>, PGSIZE);<br><br>r = (<span class="hljs-keyword">struct</span> run*)pa;<br><br>acquire(&amp;kmem.lock);<br>r-&gt;next = kmem.freelist;<br>kmem.freelist = r;<br>release(&amp;kmem.lock);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>为了避免<code>race condition</code>, 对于这种全局变量的读取和更改都需要先<code>acquire lock</code>，然后再释放。所以新增了两个这方面的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//increase the reference count to single page</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">incref</span><span class="hljs-params">(uint64 pa)</span><br>&#123;<br>acquire(&amp;kmem.lock);<br><span class="hljs-keyword">if</span>(PA2REF(pa) &lt;= <span class="hljs-number">0</span>)<br>panic(<span class="hljs-string">&quot;increase ref\n&quot;</span>);<br>PA2REF(pa) += <span class="hljs-number">1</span>;<br>release(&amp;kmem.lock);<br>&#125;<br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">getref</span><span class="hljs-params">(uint64 pa)</span><br>&#123;<br><span class="hljs-type">int</span> ref = <span class="hljs-number">0</span>;<br>acquire(&amp;kmem.lock);<br><span class="hljs-keyword">if</span>(PA2REF(pa) &lt;= <span class="hljs-number">0</span>)<br>panic(<span class="hljs-string">&quot;get reference \n&quot;</span>);<br>ref = PA2REF(pa);<br>release(&amp;kmem.lock);<br><span class="hljs-keyword">return</span> ref;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后处理如何应对一个<code>cow fault</code>，为了代码的复用率和模块化，我仿照教授的方式将这个措施写在了一个函数里面，和教授不同的是：我觉得当仅有一个进程引用一个物理页面的时候，可以直接将赋予写权限，就不需要再申请一次页面然后释放了，节省了一次复制的开销。这也是为什么我需要一个<code>getref()</code>函数来获取引用次数的原因。其次，我还在判断<code>page fault</code>是否是一个<code>COW fault</code>的时候用了一个PTE中的保留位，因为经过上次的<code>lazy lab</code>，我觉得<code>page fault</code>产生的实际上应该会有很多是由于类似COW之类的页表操作技巧，所以为了扩展性用一个位是值得的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_COW (1L &lt;&lt; 8)<span class="hljs-comment">// used for COW</span></span><br><br><span class="hljs-comment">//handle the case of Copy On Write fault.</span><br><span class="hljs-comment">//return -1 if error happened</span><br><span class="hljs-comment">//return 0 if going on right or nothing happened.</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">cowfault</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 va)</span><br>&#123;<br><span class="hljs-type">pte_t</span> * pte;<br><span class="hljs-keyword">if</span>(va &gt; MAXVA)<span class="hljs-comment">// avoid tricky virtual address.</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br><span class="hljs-keyword">if</span>((pte = walk(pagetable, va, <span class="hljs-number">0</span>)) == <span class="hljs-number">0</span>)<span class="hljs-comment">//avoid non-mapped va.</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br><span class="hljs-keyword">if</span>((*pte &amp; PTE_COW) == <span class="hljs-number">0</span>)<span class="hljs-comment">// not the COW case normal return </span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span>(((*pte) &amp; PTE_V || (*pte) &amp; PTE_U) == <span class="hljs-number">0</span>)<span class="hljs-comment">//avoid pages like guard page or trampoline or trapframe...</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>uint64 pa = PTE2PA(*pte);<br><span class="hljs-keyword">if</span>(getref(pa) == <span class="hljs-number">1</span>)&#123;<br>*pte |= PTE_W;<br>*pte &amp;= ~PTE_COW;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-type">int</span> flag = PTE_FLAGS(*pte);<br><span class="hljs-type">void</span> *mem = kalloc();<br><span class="hljs-keyword">if</span>(mem == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>memmove(mem, (<span class="hljs-type">void</span>*)pa, PGSIZE);<br>*pte = PA2PTE((uint64)mem) | flag | PTE_W;<br>*pte &amp;= ~PTE_COW;<br>kfree((<span class="hljs-type">void</span>*)pa);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>前面说到，关于<code>cow page fault</code>的处理有两处，一处是<code>usertrap</code>，用户直接写入共享地址;第二处是<code>copyout</code>，用户先将地址传递给内核，由内核执行写入，由于这个时候不能产生<code>store page fault</code>，需要软件判断。为了可扩展性，这两处都预留了做其他事情的空间，因为当<code>cowfault</code>返回0的时候相当于什么也不做。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">usertrap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">// .........................................</span><br><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((which_dev = devintr()) != <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// ok</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(r_scause() == <span class="hljs-number">15</span>)&#123;<br><span class="hljs-keyword">if</span>(cowfault(p-&gt;pagetable, r_stval()) &lt; <span class="hljs-number">0</span>)<br>p-&gt;killed = <span class="hljs-number">1</span>;<br><span class="hljs-comment">//do other situation here.</span><br> &#125;<span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;process : %s\n&quot;</span>,p-&gt;name);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());<br><span class="hljs-comment">// ..........................................</span><br>&#125;<br><br><span class="hljs-comment">// 由于copyout的cowfault部分可能不会执行，所以应该在前面再判断一次数据的有效性。</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">copyout</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 dstva, <span class="hljs-type">char</span> *src, uint64 len)</span><br>&#123;<br>  uint64 n, va0, pa0;<br><span class="hljs-type">pte_t</span> *pte;<br><br>  <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">0</span>)&#123;<br>    va0 = PGROUNDDOWN(dstva);<br><span class="hljs-keyword">if</span>(va0 &gt; MAXVA)<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>pte = walk(pagetable, va0, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span>(pte == <span class="hljs-number">0</span>) <br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br><span class="hljs-keyword">if</span>(((*pte) &amp; PTE_V || (*pte) &amp; PTE_U) == <span class="hljs-number">0</span>)<span class="hljs-comment">// check for validation</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br><span class="hljs-keyword">if</span>((*pte &amp; PTE_W) == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">if</span>(cowfault(pagetable, va0) &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// do other situation here.</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">// .........................................</span><br>&#125;<br></code></pre></td></tr></table></figure><p>最后贴上成功通过测试的截图纪念，这次实验确实比想象中的要复杂，也收获了很多。<br><img src="/2024/04/18/xv6-lab-COW/succeed.png" alt="succeed"></p><hr><p><em><strong>写在最后</strong></em>：感谢能读到这里，希望没有浪费您宝贵的时间，如果觉得还不错，不要吝啬手中的赞呦~。</p><blockquote><p>加以修改后的源代码放在了<a href="https://github.com/sycamoremoon/xv6-labs-2023">sycamoremoon’s github</a>,需要的同学可以自取。</p><p>之后还会有其他的内容上传，希望我的小小努力能够给大家带来帮助</p><p>这是<a href="sycamoremoon.online">我的网站</a>，内容会随着时间逐渐丰富的..</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>xv6-Operating system</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unix/Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xv6-lab-lazy</title>
    <link href="/2024/04/15/xv6-lab-lazy/"/>
    <url>/2024/04/15/xv6-lab-lazy/</url>
    
    <content type="html"><![CDATA[<h1 id="xv6-labs-lazy实验记录与分析"><a href="#xv6-labs-lazy实验记录与分析" class="headerlink" title="xv6-labs-lazy实验记录与分析"></a>xv6-labs-lazy实验记录与分析</h1><p><em><strong>写在前面</strong></em>: 前面在虚拟地址和页表部分花了不少时间去理解，现在终于可以真正的使用这一项强大的机制来实现很多内核中有用的技巧了。这次实验虽然是分成三个部分但是实际上就是围绕一个问题展开，那就是对用户进程申请的内存空间进行 <strong>lazy allocation</strong>。本来以为不会很复杂，但是还是花了不少时间来通过测试，因为需要注意很多细节的地方，否则就会出各种问题。</p><hr><ul><li><a href="#Modify-sbrk">Modify sbrk()</a></li><li><a href="#Lazy-allocation">Lazy allocation</a></li><li><a href="#Lazytests-Usertests">Lazytests Usertests</a></li></ul><hr><h1 id="Modify-sbrk"><a href="#Modify-sbrk" class="headerlink" title="Modify-sbrk"></a>Modify-sbrk</h1><p>这个部分十分简单，只需要更改<code>sys_sbrk()</code>函数让它不要进行内存的分配转而只将<code>p-&gt;sz</code>增加部分数值即可。但是为了了解为什么会产生<code>pagefault</code>，我仍然花了一点时间在GDB上。</p><p>当直接执行<code>echo hi</code>的时候，由于在sbrk中什么都没干，很显然会造成trap，那么到底是执行了什么造成的<code>usertrap</code>呢？如下图可见，设置断点在<code>stval</code>指向的虚拟地址，然后在GDB中<code>backtrace</code>可以看出造成<code>usertrap</code>的原因。<br><img src="/2024/04/15/xv6-lab-lazy/usertrap.png" alt="usertrap"></p><p>可以看出，这个异常的trap发生在shell进程中，此时还没有切换到<code>echo</code>进程，只是在<code>exec</code>调用之前发生了一些异常读取内存的trap。具体来说就是在<code>malloc()</code>函数中调用了<code>sbrk()</code>申请内存空间。站在用户程序的角度就可以认为调用<code>sbrk()</code>之后就可以实际使用申请好的内存了。这时候由于是<code>lazy allocation</code> 实际上并没有对应的实际内存，用户页表中也没有对应的映射，此时执行<code>sd/ld</code>等指令就会产生异常<code>usertrap</code>进入内核。</p><h1 id="Lazy-allocation"><a href="#Lazy-allocation" class="headerlink" title="Lazy-allocation"></a>Lazy-allocation</h1><p>还是跟着实验内容的脚步，在这个部分我们只需要上内核的<code>usertrap</code>正确应对<code>page fault</code>的<code>Store page fault</code>即可。针对这个任务首先需要在<code>usertrap</code>加入针对这种特殊情况的代码。</p><p>对于所有类型的<code>page fault</code>都必须经过一个先申请内存然后映射到发生错误的虚拟地址的过程。execute等其他类型的可能还额外要对申请页面进行数据的复制之类的操作。所以在这一部分的代码也比较简单</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">usertrap</span><span class="hljs-params">()</span>&#123;<br><br><span class="hljs-comment">//.....................................</span><br><br>   <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((which_dev = devintr()) != <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// ok</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(r_scause() == <span class="hljs-number">15</span> || r_scause() == <span class="hljs-number">13</span>)&#123;<br><span class="hljs-type">int</span> flag = r_scause() == <span class="hljs-number">15</span> ? PTE_W|PTE_R|PTE_U : PTE_R|PTE_U;<br><span class="hljs-type">void</span>* mem = kalloc();<br><span class="hljs-built_in">memset</span>(mem, <span class="hljs-number">0</span>, PGSIZE);<br><span class="hljs-keyword">if</span>(mappages(p-&gt;pagetable, PGROUNDDOWN(r_stval()), PGSIZE, (uint64)mem, flag) != <span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mapping failed.\n&quot;</span>);<br>kfree(mem);<br>&#125;<br>&#125; <br><span class="hljs-comment">// unhandled trap type</span><br><span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());<br>    p-&gt;killed = <span class="hljs-number">1</span>;<br>  &#125;<br><br><span class="hljs-comment">// ...........................................</span><br>&#125;<br></code></pre></td></tr></table></figure><p>只修改这一部分还不够，因为引入<code>lazy allocation</code>本质上更改了整个xv6操作系统基础管理内存方式的机制。之前的xv6默认是认为每一个申请的内存都映射于用户的页表或者内核页表的,并且对于每一个需要用到的PTE都是valid的。现在引入<code>lazy</code>后，这一默认的条件不再是永远成立的了，完全有可能用户需要的虚拟地址上没有映射相应的物理页面，甚至连存放PTE的页表都没有分配！</p><p>这样的情况在之前无疑是内核代码出现了问题，发现后立即<code>panic()</code>比较有利于调试内核。现在引入机制后，这样的情况是完全可能的，内核发现后也不需要有过激的反映。所以还需要对<code>uvmunmap()</code>修改如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">uvmunmap</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 va, uint64 npages, <span class="hljs-type">int</span> do_free)</span><br>&#123;<br>  uint64 a;<br>  <span class="hljs-type">pte_t</span> *pte;<br><br>  <span class="hljs-keyword">if</span>((va % PGSIZE) != <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;uvmunmap: not aligned&quot;</span>);<br>  <span class="hljs-keyword">for</span>(a = va; a &lt; va + npages*PGSIZE; a += PGSIZE)&#123;<br>    <span class="hljs-keyword">if</span>((pte = walk(pagetable, a, <span class="hljs-number">0</span>)) == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>    <span class="hljs-keyword">if</span>((*pte &amp; PTE_V) == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">if</span>(PTE_FLAGS(*pte) == PTE_V)<br>      panic(<span class="hljs-string">&quot;uvmunmap: not a leaf&quot;</span>);<br>    <span class="hljs-keyword">if</span>(do_free)&#123;<br>      uint64 pa = PTE2PA(*pte);<br>      kfree((<span class="hljs-type">void</span>*)pa);<br>    &#125;<br>    *pte = <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过这样修改后，应该是能够成功从sh进程fork出子进程执行<code>echo</code>进程了。为了更加直观的感受到<code>lazy</code>机制，下面我用GDB加上QEMU的后台查看功能调出了用户进程的页表分配。<br><img src="/2024/04/15/xv6-lab-lazy/vary_pagetable.png" alt="vary_pagetable"></p><p>图中第一次打印的页表是执行完<code>sbrk()</code>系统调用但是还没有实际使用的sh进程页表分布。第二次打印的是实际对分配的页面使用时候的页表分布，可见其中多了两项，这两项恰好对应的就是对应打印的发生<code>page fault</code>的地址所在的页表。</p><h1 id="Lazytests-Usertests"><a href="#Lazytests-Usertests" class="headerlink" title="Lazytests-Usertests"></a>Lazytests-Usertests</h1><p>在<code>Lazytests</code>中的内容其实相对比较少，按照提示来完成即可。但是令人比较头疼的是要通过<code>Usertests</code>这个测试比较完整的测试了内核的完好性，保证在加入<code>lazy</code>机制之后不会破坏原有的内核结构。同样代码量也不多，但是调试也不太容易。</p><p>首先要解决的是空间的释放，这样才能实现对空间的重复利用。在原来的xv6中用户释放内存空间的方式实际上还是通过系统调用sbrk()来进行。所以在新的<code>sbrk()</code>中也要提供相应的实现。</p><p>当参数为正数的时候，可以近似无限制的扩张sz，因为如果超过了物理界限内核会给出相应的处理。但是如果参数为负数，这时候就需要考虑更多的东西：缩减后的sz不能低于stack的虚拟地址，否则会覆盖用户栈空间的数据，然后要对中间差值的这个空间进行解除映射和释放空间，最后才调整sz。具体代码如下，要特别注意其中是<code>&gt;</code>还是<code>&gt;=</code>，否则会直接忽略掉对一整页的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64<br><span class="hljs-title function_">sys_sbrk</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  <span class="hljs-type">int</span> addr;<br>  <span class="hljs-type">int</span> n;<br><br>  <span class="hljs-keyword">if</span>(argint(<span class="hljs-number">0</span>, &amp;n) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  addr = p-&gt;sz;<br><span class="hljs-keyword">if</span>(n &gt;= <span class="hljs-number">0</span>) <br>p-&gt;sz = p-&gt;sz+n;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p-&gt;sz+n &gt;= PGROUNDUP(p-&gt;trapframe-&gt;sp))&#123;<br>uvmunmap(p-&gt;pagetable, PGROUNDUP(p-&gt;sz+n), (PGROUNDUP(p-&gt;sz)-PGROUNDUP(p-&gt;sz+n))/PGSIZE, <span class="hljs-number">1</span>);<br>p-&gt;sz = p-&gt;sz+n;<br>&#125; <span class="hljs-keyword">else</span><span class="hljs-comment">//shrink into stack page</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">return</span> addr;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来的部分是<code>page fault</code>在<code>usertrap</code>中的一些限制。当用户访问超出sz界限的虚拟地址时，当<code>page fault</code>是因为stack的守护页时，或者当用户程序消耗完所用的内存之后要进行一些相应的处理，在这次实验中就是简单的<code>kill</code>。接下来的<code>usertrap</code>版本是考虑各种异常的版本。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">usertrap</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-comment">// .....................................</span><br><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((which_dev = devintr()) != <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// ok</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(r_scause() == <span class="hljs-number">15</span> || r_scause() == <span class="hljs-number">13</span>)&#123;<br><span class="hljs-type">int</span> flag = r_scause() == <span class="hljs-number">15</span> ? PTE_W|PTE_R|PTE_U : PTE_R|PTE_U;<br><span class="hljs-comment">//printf(&quot;store page fault: %p\n&quot;, r_stval());</span><br><span class="hljs-keyword">if</span>(r_stval() &lt; p-&gt;sz &amp;&amp; r_stval() &gt;= PGROUNDUP(p-&gt;trapframe-&gt;sp))&#123;<br><span class="hljs-type">void</span>* mem = kalloc();<br><span class="hljs-keyword">if</span>(mem == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-comment">//printf(&quot;From usertrap:out of memory\n&quot;);</span><br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br><span class="hljs-built_in">memset</span>(mem, <span class="hljs-number">0</span>, PGSIZE);<br><span class="hljs-keyword">if</span>(mappages(p-&gt;pagetable, PGROUNDDOWN(r_stval()), PGSIZE, (uint64)mem, flag) != <span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mapping failed.\n&quot;</span>);<br>kfree(mem);<br>&#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">//printf(&quot;reference page out of user address space:\n&quot;);</span><br><span class="hljs-comment">//printf(&quot;  pid=%d epc=%p stval=%p\n&quot;, p-&gt;pid, r_sepc(), r_stval());</span><br>p-&gt;killed = <span class="hljs-number">1</span>;<br>&#125;<br>&#125; <br><span class="hljs-comment">// unhandled trap type</span><br><span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());<br>    p-&gt;killed = <span class="hljs-number">1</span>;<br>  &#125;<br><br><span class="hljs-comment">// ............................................</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>关于提示里面的 **Handle the case in which a process passes a valid address from sbrk() to a system call such as read or write, but the memory for that address has not yet been allocated.**我实际上是十分在意这个的，因为有些系统调用是需要读取用户空间的地址作为参数，比如说<code>write()</code>系统调用。这样就会发生一个问题：本来是应该在内核空间分配物理地址的虚拟地址却在没有分配物理空间前就已经进入了内核空间。</p><p>我首先出现的想法是利用内核空间的<code>trap</code>进入<code>machine-mode</code>。所以我在<code>kerneltrap</code>函数中写了一段十分类似<code>usertrap</code>的对内存分配的代码。然后在我测试的时候竟然很多测试都表现良好，仅仅除了一个<code>sbrkarg()</code>测试函数。我找了很多这个的原因，后来发现在内核处理上述的情况的时候根本不会进一步陷入<code>machine-mode</code>。</p><p>思考之后我发现确实不会进入<code>trap</code>是理所应当的事情，因为首先想要发生<code>page fault</code>是由于用硬件访问一个不没有映射的虚拟地址造成的。更细节一点说是在执行<code>store/load</code>指令的时候MMU无法找到合适的物理地址才会发生的事情。但是在内核空间我们并不会直接去访问用户地址，而且在目前的情况下我们的<code>kernel pagetable</code>中也根本有没有映射用户进程的虚拟地址映射关系，所有获取数据的方式都是用<code>walk</code>函数直接找到物理页面获取的。所以在内核态也就不会产生<code>trap</code>了。</p><p>想要应对这种情况，我们必须在用软件模拟获取数据的过程中来处理这种异常情况。xv6的软件模拟MMU交换数据的函数是<code>copyin(),copyout()</code>.所以应该在这里面进行更改。<code>copyin()</code>代码如下，主要还是更改了对于<code>pa== 0</code>的情况，同样需要考虑<code>usertrap</code>中对内存范围的限制。<code>copyout</code>同理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">copyin</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, <span class="hljs-type">char</span> *dst, uint64 srcva, uint64 len)</span><br>&#123;<br>  uint64 n, va0, pa0;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> * <span class="hljs-title">p</span> =</span> myproc();<br>  <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">0</span>)&#123;<br>    va0 = PGROUNDDOWN(srcva);<br>    pa0 = walkaddr(pagetable, va0);<br>    <span class="hljs-keyword">if</span>(pa0 == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">if</span>(srcva &lt; p-&gt;sz &amp;&amp; srcva &gt;= PGROUNDUP(p-&gt;trapframe-&gt;sp))&#123;<br><span class="hljs-type">void</span>* mem = kalloc();<br><span class="hljs-keyword">if</span>(mem != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">memset</span>(mem, <span class="hljs-number">0</span>, PGSIZE);<br><span class="hljs-keyword">if</span>(mappages(pagetable, va0, PGSIZE, (uint64)mem, PTE_W|PTE_R|PTE_U) != <span class="hljs-number">0</span>)<br>kfree(mem);<br>pa0 = walkaddr(pagetable, va0);<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;copyin: out of memory\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br>&#125;<span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br>    n = PGSIZE - (srcva - va0);<br>    <span class="hljs-keyword">if</span>(n &gt; len)<br>      n = len;<br>    memmove(dst, (<span class="hljs-type">void</span> *)(pa0 + (srcva - va0)), n);<br><br>    len -= n;<br>    dst += n;<br>    srcva = va0 + PGSIZE;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>再进一步想</strong>:要是使用在 <strong>pgtbl2020</strong> 中实现的为每一个用户进程分配一个内核页表，而且这个内核页表中也包含用户地址空间的信息，那么<code>copyin()</code>是不需要walk函数直接访问的，这样是否就可以在内核空间<code>trap</code>而进入<code>kerneltrap</code>进行处理了。理论上是可行的，等成功之后再回来更新。</p><p>最后，类似于<code>uvmunmap()</code>中的对无效页表项的处理，在<code>fork()</code>中也要处理这样的情况，因为原来的xv6是直接全部将父进程的信息复制到子进程新的地址空间，毫无疑问现在会遇到有些PTE无效这样的特殊情况。前面说到过，现在修改后的xv6内核已经容忍这种情况出现了，所以只需要跳过即可,其中需要更改的核心部分如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">uvmcopy</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> old, <span class="hljs-type">pagetable_t</span> new, uint64 sz)</span><br>&#123;<br><br><span class="hljs-comment">// ..........................</span><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; sz; i += PGSIZE)&#123;<br>    <span class="hljs-keyword">if</span>((pte = walk(old, i, <span class="hljs-number">0</span>)) == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">if</span>((*pte &amp; PTE_V) == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>    pa = PTE2PA(*pte);<br><br><span class="hljs-comment">// .........................</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>按照上述操作更改完，应该就能通过所有测试了，贴一个图记录一下：<br><img src="/2024/04/15/xv6-lab-lazy/succeed.png" alt="succeed"></p><hr><p><em><strong>写在最后</strong></em>：感谢能读到这里，希望没有浪费您宝贵的时间，如果觉得还不错，不要吝啬手中的赞呦~。</p><blockquote><p>加以修改后的源代码放在了<a href="https://github.com/sycamoremoon/xv6-labs-2023">sycamoremoon’s github</a>,需要的同学可以自取。</p><p>之后还会有其他的内容上传，希望我的小小努力能够给大家带来帮助</p><p>这是<a href="sycamoremoon.online">我的网站</a>，内容会随着时间逐渐丰富的..</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>xv6-Operating system</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unix/Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xv6-lab-trap</title>
    <link href="/2024/04/10/xv6-lab-trap/"/>
    <url>/2024/04/10/xv6-lab-trap/</url>
    
    <content type="html"><![CDATA[<h1 id="xv6-labs-trap实验记录与分析"><a href="#xv6-labs-trap实验记录与分析" class="headerlink" title="xv6-labs-trap实验记录与分析"></a>xv6-labs-trap实验记录与分析</h1><p><em><strong>写在前面</strong></em>: 本次实验是关于从用户态陷入内核态的，关于这个部分呢不可避免需要汇编语言的知识。关于RISC-V汇编语言可以参考<a href="https://riscv.org/technical/specifications/">spec</a>.正如提示中所说，本次实验的代码较少，但是需要思考的东西比较多，写出正确的代码也要非常仔细地考虑。</p><hr><ul><li><a href="#RISCV-assembly">RISCV-assembly</a></li><li><a href="#backtrace">backtrace</a></li><li><a href="#Alarm">Alarm</a></li></ul><hr><h2 id="RISCV-assembly"><a href="#RISCV-assembly" class="headerlink" title="RISCV-assembly"></a>RISCV-assembly</h2><p>关于calling-convention官方给出的参考文献是<a href="https://pdos.csail.mit.edu/6.828/2020/readings/riscv-calling.pdf">Call convertion</a>它描述了在进行C语言函数调用的时候各个参数之间是如何进行传递的，摘自上述的Specification。之后我又找到一个参考文献个人感觉比Spec更加通俗易懂，出自berkeley大学<a href="https://inst.eecs.berkeley.edu/~cs61c/resources/RISCV_Calling_Convention.pdf">Understanding RISC-V Calling Convention</a>.</p><p>其中关于s和t寄存器分别是被调用者保存(callee save)和调用者保存(caller save)。他们的区别大致是: callee save 在子程序调用完成返回时要保证该寄存器中存储的数据不会改变。caller save 是要在调用子程序之前将寄存器中的值提前存放好，子程序返回再恢复，因为子程序对该寄存器中的值没有任何保护的措施。关于为什么要区别这个，我问一位这方面专业的老师得到的答案是 <strong>硬件方面暂时没有区分这两类寄存器的区别,仅为了能让编译器能够编译出高效的代码</strong>。至于混用可能也不会暂时不会导致马上出错，但是为了规范还是要避免这种情况发生。<br><img src="/2024/04/10/xv6-lab-trap/violating_conv.png" alt="violating_convention"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asm">;一个简单的c语言程序调用。<br>int g(int x) &#123;<br>   0:1141                addisp,sp,-16<br>   2:e422                sds0,8(sp)<br>   4:0800                addis0,sp,16<br>  return x+3;<br>&#125;<br>   6:250d                addiwa0,a0,3<br>   8:6422                lds0,8(sp)<br>   a:0141                addisp,sp,16<br>   c:8082                ret<br></code></pre></td></tr></table></figure><p>这个简单的c语言程序较为完整的反映了calling convertion的过程。前两条指令是prologue,保存callee save寄存器。第5,6条指令是epilogue,恢复之前保存的寄存器。然后ret返回。但是有一个特别之处是这个程序没有调用其他的子程序，属于leaf,所以不需要保存ra寄存器.正常来说假如一个程序还调用了其他的子程序，则会在栈的最顶端保存ra，接下来一个位置保存s0(frame pointer)。现在这个情况属于是在栈的顶端保存的s0，ra不用保存，应该也是RISC-V的规范要求。</p><p>第一条指令将sp减去16,是为了给接下来的程序腾出一段栈空间。因为栈的生长方向向下。所以在原来的sp至sp-16这段内存空间是给接下来的程序使用的。至于为什么只保存了一个寄存器还需要将sp移动16个字节，是因为RISC-V需要进行内存对齐，对齐的最小宽度就是16字节。</p><p>一个更完整的有代表性的例子如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs asm">void<br>fprintf(int fd, const char *fmt, ...)<br>&#123;<br> 64a:715d                addisp,sp,-80<br> 64c:ec06                sdra,24(sp)<br> 64e:e822                sds0,16(sp)<br> 650:1000                addis0,sp,32<br> 652:e010                sda2,0(s0)<br> 654:e414                sda3,8(s0)<br> 656:e818                sda4,16(s0)<br> 658:ec1c                sda5,24(s0)<br> 65a:03043023          sda6,32(s0)<br> 65e:03143423          sda7,40(s0)<br>  va_list ap;<br><br>  va_start(ap, fmt);<br> 662:fe843423          sds0,-24(s0)<br>  vprintf(fd, fmt, ap);<br> 666:8622                mva2,s0<br> 668:00000097          auipcra,0x0<br> 66c:e16080e7          jalr-490(ra) # 47e &lt;vprintf&gt;<br>&#125;<br> 670:60e2                ldra,24(sp)<br> 672:6442                lds0,16(sp)<br> 674:6161                addisp,sp,80<br> 676:8082                ret<br></code></pre></td></tr></table></figure><p>接下来我觉得比较重要的一个点是关于<code>little-endian</code>和<code>big-endian</code>的区别。给定下面的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0x00646c72</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;H%x Wo%s&quot;</span>, <span class="hljs-number">57616</span>, &amp;i);<br></code></pre></td></tr></table></figure><p>由于计算机的最小存储单元是一个字节，所以当数据只占用一个字节宽度的时候这两种格式没有什么区别。但是当数据宽度大于一个字节，每个字节存放的顺序就有所区别了。注意到对于这个<code>unsigned int</code>格式的i变量，在printf的时候用打印字符串的格式打印，这个时候就体现了<code>little</code>和<code>big</code>的区别。RISC-V所用的<code>little-endian</code>是把最低位放在这一块数据的最前面，所以从i的地址开始首先看见的应该是<code>0x72</code>这个数据,最后才是<code>0x00</code>.如果是<code>big-endian</code>首先看见的就是<code>0x00</code>,最后才是<code>0x72</code>。</p><h2 id="backtrace"><a href="#backtrace" class="headerlink" title="backtrace"></a>backtrace</h2><p>这个实验要求比较清晰，就是完成一个<code>backtrace()</code>函数，然后<code>sys_sleep()</code>对其进行调用即可。我在完成的时候遇到了几个问题. 当时以为挺容易的，后来还真的仔细思索才完成。</p><ol><li>首先需要明确的是，pc寄存器的内容虽然都是虚拟地址。但是内核存放程序的地方虚拟地址映射关系是直接映射，所以直接打印pc即可。</li><li>为了回溯函数调用的情况，我们需要查询栈中的数据。而栈中的数据却是虚拟地址，陷入内核后每个进程都有一个内核栈被映射到一个高的虚拟地址。 <strong>所以fp是虚拟地址，它指向的下一级fp也是虚拟地址</strong>,我们在<code>backtrace()</code>中的操作完全是在一页大小的内核栈中进行的。完全不需要进行<code>walk()</code>这类的操作。</li><li>在一个函数里面进行回溯的过程中, 从s0寄存器获得的frame pointer是指向caller 函数。其中含有的信息不包括当前正在执行的函数。</li></ol><p>由于在<code>backtrace()</code>之前的所有函数都必然不是一个leaf函数。所以栈的存储情况必然如下图所示。可以由此看出如果需要访问pc或者fp则需要进行适当的偏移。<br><img src="/2024/04/10/xv6-lab-trap/stack.png" alt="stack"><br>最后附上代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//backtrace for debugging</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">backtrace</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">// notice that r_fp() returns the value of the virtual address of sp</span><br><span class="hljs-comment">// in order to get stored pc and fp which needs to shift 8/16 bit.</span><br>uint64 cur_fp = r_fp();<br>uint64 pre_fp = *(uint64 *)(cur_fp - <span class="hljs-number">16</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;backtrace:\n&quot;</span>);<br><span class="hljs-keyword">while</span>(pre_fp &lt;= PGROUNDUP(cur_fp) &amp;&amp; pre_fp &gt;= PGROUNDDOWN(cur_fp))<br>&#123;<br><span class="hljs-comment">// print current stored pc</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>,*(uint64 *)(cur_fp - <span class="hljs-number">8</span>));<br>cur_fp = pre_fp;<br>pre_fp = *(uint64 *)(cur_fp - <span class="hljs-number">16</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h2><p>这个实验的要求很细致，相当于一篇英文文章了。简单来说就是设置一个定时器中断函数，在每次定时器中断的时候就执行一次处于用户空间的函数。</p><p>首先需要进行一些简单的配置,比如添加编译项，添加系统调用，修改头文件之类的事情等等。然后就是在系统调用<code>sys_sigalarm</code>中进行一些添加性的工作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Per-process state</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> &#123;</span><br><span class="hljs-comment">// ............................</span><br><span class="hljs-type">void</span> (*handler)();           <span class="hljs-comment">// Alarm handler </span><br><span class="hljs-type">int</span> ticks;                   <span class="hljs-comment">// The Totall Ticks period of call</span><br><span class="hljs-type">int</span> left_ticks;              <span class="hljs-comment">// When it count down to 0,call fn</span><br><span class="hljs-type">int</span> blocked;                 <span class="hljs-comment">// Blocked the device interupt</span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64<br><span class="hljs-title function_">sys_sigalarm</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> * <span class="hljs-title">p</span> =</span> myproc();<br><span class="hljs-type">int</span> ticks = <span class="hljs-number">0</span>;<br>uint64 handler = <span class="hljs-number">0</span>;<br>argint(<span class="hljs-number">0</span>, &amp;ticks);<br>argaddr(<span class="hljs-number">1</span>, &amp;handler);<br><br>p-&gt;ticks = ticks;<br>p-&gt;left_ticks = ticks;<br>p-&gt;handler = (<span class="hljs-type">void</span>(*)())handler;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="test0"><a href="#test0" class="headerlink" title="test0"></a>test0</h3><p>实验指导很贴心的将这个任务分成了两部分来完成。test0就是进入定时器中断函数的时候能执行设置好的函数句柄. 想要完成这个任务会遇到的困难是用户代码使用的是用户页表，而中断函数处于一个使用内核页表的状态，肯定是不能直接执行。</p><ul><li>为了解决这个问题，我首先想到的就是在执行句柄函数之前切换一下页表，改成用户页表。但是毫无疑问是一个糟糕的方法，因为自从<code>satp</code>寄存器改变的那一瞬间开始，地址的映射关系就完全变化了。pc指向的地址映射关系已经变化了，那里已经不是原来的程序指令了，或者切换页表后pc指向的位置根本没有映射到物理页面。所以切换<code>satp</code>的时候要格外小心，<code>trampoline</code>就是为了解决这个问题，所以在每个页表中都映射到了一个相同的物理页面，所以这样即使切换页表，指令也可以继续执行。</li><li>后来我又尝试在调用句柄函数之前将用户页表的PTEs给复制到内核页表中,然后等待执行完毕后再把用户页表的PTE从内核页表中擦除。这种方法确实可以在调用句柄函数的时候正常跳转。但是这相当与在内核执行用户的程序，对隔离性和安全性有着很大的威胁，还有一个问题很是致命：现在执行用户程序的时候是处于内核态，同时用户程序会不断地发出<code>system call</code>请求，这个时候<code>ecall</code>指令就不是跳转到<code>uservec</code>而是<code>kernelvec</code>了，会导致程序发生混乱。</li><li>尝试这么久无果，我后来又仔细整理了一下整个usertrap的过程。发现要是想要让句柄函数能够成功在用户态执行，最好的方式就是直接更改<code>epc</code>寄存器，然后在执行<code>sret</code>的时候自动将<code>epc</code>复制到<code>pc</code>中。页表的切换也在<code>trampoline page</code>的<code>userret</code>函数中. 所以实际上只需要一行代码就可以搞定。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">p-&gt;trapframe-&gt;epc = (uint64)p-&gt;handler;<br></code></pre></td></tr></table></figure></li></ul><p>最后解决了才发现这个答案原来如此straightforward.^_^</p><h3 id="test1-2-3"><a href="#test1-2-3" class="headerlink" title="test1,2,3"></a>test1,2,3</h3><p>这三个test分别测试是否能够会恢复到被定时器中断的位置，是否能保证在执行句柄函数的时候不会被重入(re-entrant)，是否能在执行一个假<code>sigalarm()</code>之后仍然能够正确执行之后的程序。</p><p>关于这个流程简易的trap流程如下图所示：<br><img src="/2024/04/10/xv6-lab-trap/timer_trap.jpg" alt="timer_trap"></p><ol><li><p>想要恢复到被定时器中断的部分，就需要对之前的寄存器进行保存，通过<code>uservec</code>保存在<code>trapframe</code>的部分会随着定时器中断返回而对此没有任何保证。句柄函数可能会改变使用的寄存器，然后通过系统调用陷入内核从而刷新进程的<code>trapframe</code>。所以 <strong>必然需要另外一个存储空间来单独保存因为定时器中断时的进程状态信息</strong>。关于这个位置可以重新分配一个物理页面，但是我并不太想修改<code>allocproc()</code>函数，同时注意到原来的<code>trapframe</code>页面有很大一部分空间没有被利用。所以我选择直接存储在<code>trapframe</code>对应的物理页面上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//store 1 / load 0 trapframe</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">timer_changestate</span><span class="hljs-params">(<span class="hljs-type">int</span> flag)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> * <span class="hljs-title">timer_trapframe</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> * <span class="hljs-title">p</span> =</span> myproc();<br>timer_trapframe = p-&gt;trapframe + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(flag == <span class="hljs-number">1</span>)<span class="hljs-comment">//store trapframe into timer_trapframe</span><br>memmove((<span class="hljs-type">void</span>*)timer_trapframe,(<span class="hljs-type">void</span>*)p-&gt;trapframe,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> trapframe));<br><span class="hljs-keyword">else</span><span class="hljs-comment">//load timer_trapframe into trapframe </span><br>memmove((<span class="hljs-type">void</span>*)p-&gt;trapframe,(<span class="hljs-type">void</span>*)timer_trapframe,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> trapframe));<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>关于如何防止句柄函数被重入也需要仔细考虑。首先中断标志位(SIE)的关闭是在用户陷入内核后硬件自动处理的，我们只需要考虑如何打开即可。中断标志位控制的是处理器对硬件中断信号是否能够陷入内核，对于<code>ecall</code>和<code>exception</code>没有影响。在未更改之前 <strong>每次从内核执行<code>usertrapret</code>都必然置位中断标志位</strong>, 查看<code>syscall</code>流程可以得知关于系统调用的整个流程涉及了两次中断的开启。<code>devintr</code>整个流程只涉及了一次中断的开启,只是中断返回导致。明白这一点后，就针对这个来选择性地置位中断标志位, 判断的标志就是进程结构体中新增的字段<code>blocked</code>(全局变量被初始化为0).</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">usertrap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">// .................................</span><br><br>    <span class="hljs-comment">// an interrupt will change sepc, scause, and sstatus,</span><br>    <span class="hljs-comment">// so enable only now that we&#x27;re done with those registers.</span><br><span class="hljs-comment">// since we stored status , we enable interupt.</span><br>    <span class="hljs-keyword">if</span>(p-&gt;blocked == <span class="hljs-number">0</span>)intr_on();<br><br>    syscall();<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((which_dev = devintr()) != <span class="hljs-number">0</span>)&#123;<br><span class="hljs-comment">// Device Interupt handled here.</span><br><span class="hljs-comment">// which_dev = 2 means timer interuprt</span><br><span class="hljs-keyword">if</span> (which_dev == <span class="hljs-number">2</span>)&#123;<br><span class="hljs-comment">// do timer handling here.</span><br><span class="hljs-keyword">if</span> (p-&gt;handler != <span class="hljs-number">0</span> || p-&gt;ticks != <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">if</span>(p-&gt;left_ticks-- == <span class="hljs-number">0</span>)&#123;<br>timer_changestate(<span class="hljs-number">1</span>);<span class="hljs-comment">// store trapframe.</span><br>p-&gt;trapframe-&gt;epc = (uint64)p-&gt;handler;<br>p-&gt;left_ticks = p-&gt;ticks;<br>p-&gt;blocked = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());<br>    setkilled(p);<br>  &#125;<br><br><span class="hljs-comment">// ....................................</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// return to user space</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">usertrapret</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">// ...................................</span><br><br>  <span class="hljs-comment">// set up the registers that trampoline.S&#x27;s sret will use</span><br>  <span class="hljs-comment">// to get to user space.</span><br>  <br>  <span class="hljs-comment">// set S Previous Privilege mode to User.</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x = r_sstatus();<br>  x &amp;= ~SSTATUS_SPP; <span class="hljs-comment">// clear SPP to 0 for user mode</span><br><span class="hljs-keyword">if</span>(p-&gt;blocked) x &amp;= ~SSTATUS_SPIE; <span class="hljs-comment">// disable interrupts in user mode. Preventint re-entrant into alarm func</span><br><span class="hljs-keyword">else</span> x |= SSTATUS_SPIE; <span class="hljs-comment">// enable interrupts in user mode</span><br>  w_sstatus(x);<br><br><span class="hljs-comment">// ...................................</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>最后注意避免dummy函数句柄，要将对进程结构体的一切操作(恢复trapframe，释放blocked)建立在这个函数句柄有效的基础上，体现在先判断再处理。否则会导致test3 fail</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64<br><span class="hljs-title function_">sys_sigreturn</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> * <span class="hljs-title">p</span> =</span> myproc();<br><span class="hljs-keyword">if</span> (p-&gt;handler != <span class="hljs-number">0</span> || p-&gt;ticks != <span class="hljs-number">0</span>)&#123;<br>timer_changestate(<span class="hljs-number">0</span>);<span class="hljs-comment">//load trapframe before excuting alarm function.</span><br>p-&gt;blocked = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>到此为止这次实验的内容就完成了，还是贴一张图片纪念一下。<br><img src="/2024/04/10/xv6-lab-trap/succeed.png" alt="succeed"></p><hr><p><em><strong>写在最后</strong></em>：感谢能读到这里，希望没有浪费您宝贵的时间，如果觉得还不错，不要吝啬手中的赞呦~。</p><blockquote><p>加以修改后的源代码放在了<a href="https://github.com/sycamoremoon/xv6-labs-2023">sycamoremoon’s github</a>,需要的同学可以自取。</p><p>之后还会有其他的内容上传，希望我的小小努力能够给大家带来帮助</p><p>这是<a href="sycamoremoon.online">我的网站</a>，内容会随着时间逐渐丰富的..</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>xv6-Operating system</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unix/Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xv6-lab-pgtb-part2</title>
    <link href="/2024/04/08/xv6-lab-pgtb-part2/"/>
    <url>/2024/04/08/xv6-lab-pgtb-part2/</url>
    
    <content type="html"><![CDATA[<h1 id="xv6-labs-pgtbl-2020-version"><a href="#xv6-labs-pgtbl-2020-version" class="headerlink" title="xv6-labs-pgtbl(2020-version)"></a>xv6-labs-pgtbl(2020-version)</h1><p><em><strong>前言</strong></em>: 之前已经写过一篇关于pagetable的实验记录，那次是使用的2023年的课程实验。2023年的实验和2020年的实验还是有一些区别的，简而言之就是2023年的相对简单，内容较少。抱着尽可能多的学习的心态，我在做完2023版本后又把2020年版本的做了一遍。温故而知新，感觉良好，过程也顺利不少。</p><hr><ul><li><a href="#User-Kernel_PageTable">User-Kernel-PageTable</a></li><li><a href="#Simplied-Copyin">Simplied-CopyinNCopyinstr</a></li><li><a href="#%E4%B8%80%E7%82%B9%E6%84%9F%E6%85%A8">一点感慨</a></li></ul><hr><h2 id="User-Kernel-PageTable"><a href="#User-Kernel-PageTable" class="headerlink" title="User-Kernel_PageTable"></a>User-Kernel_PageTable</h2><p>这个实验可以有两种方式可以完成，区别在如何对user Kernel_pagetable进行初始化。一种是复制原有的Kernel Pagetable，一种是和原有的Kernelpagetable共享不需要改变的部分。</p><p>我是使用的直接复制的方式，这种方式比较容易想到，网上的教程也大部分是这种方式。 由于网上的教程也比较丰富，我就只记录一下我觉得比较重要的部分。</p><p>首先就是初始化一个新的Kernel_pagetable,方式和<code>kvminit()</code> 几乎一模一样。由于是复制的，所以会一个不落的重新走一遍分配页表，添加映射等等流程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Init for each user process&#x27; Kernel pagetable</span><br><span class="hljs-type">pagetable_t</span><br><span class="hljs-title function_">ukvminit</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">pagetable_t</span> kernel_pagetable = uvmcreate();<br>  <span class="hljs-comment">// uart registers</span><br>  uvmmap(kernel_pagetable, UART0, UART0, PGSIZE, PTE_R | PTE_W);<br>  <span class="hljs-comment">// virtio mmio disk interface</span><br>  uvmmap(kernel_pagetable, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);<br>  <span class="hljs-comment">// CLINT</span><br>  uvmmap(kernel_pagetable, CLINT, CLINT, <span class="hljs-number">0x10000</span>, PTE_R | PTE_W);<br>  <span class="hljs-comment">// PLIC</span><br>  uvmmap(kernel_pagetable, PLIC, PLIC, <span class="hljs-number">0x400000</span>, PTE_R | PTE_W);<br>  <span class="hljs-comment">// map kernel text executable and read-only.</span><br>  uvmmap(kernel_pagetable, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);<br>  <span class="hljs-comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span><br>  uvmmap(kernel_pagetable, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);<br>  <span class="hljs-comment">// map the trampoline for trap entry/exit to</span><br>  <span class="hljs-comment">// the highest virtual address in the kernel.</span><br>  uvmmap(kernel_pagetable, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);<br>  <span class="hljs-keyword">return</span> kernel_pagetable;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数<code>uvmmap()</code>也很简单就完全是把<code>mappages()</code>这个基本函数封装了一下，和原来的<code>kvmmap()</code>对应起来。</p><p>没一个新的进程的创建都需要调用 <code>allocproc()</code>函数，无一例外。调用的途径只有最开始的<code>initcode</code>进程和由最开始的进程<code>fork()</code>出来的进程。所以这种配置页表的工作最合适的地方就是在<code>allocproc()</code>函数里面。</p><p>提示中说道，<code>procinit()</code>函数可以部分或者全部移植到<code>allocproc()</code>函数中，查看后发现确实之前对所有的用户进程都分配一个内核栈确实有些浪费了，因为绝大多数时候进程都不是满载。所以在创建一个新用户进程的时候才分配对应的内核栈，在进程结束的时候释放感觉才是一个高效率的方案。</p><p>我在其中添加了下面的代码使其成功配置用户进程的内核页表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> proc*<br><span class="hljs-title function_">allocproc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-comment">// ..............</span><br><br>  <span class="hljs-comment">// An user Process&#x27; kernel pagetable</span><br>  p-&gt;kernel_pagetable = ukvminit();<br>  <span class="hljs-keyword">if</span>(p-&gt;kernel_pagetable == <span class="hljs-number">0</span>)&#123;<br>    freeproc(p);<br>    release(&amp;p-&gt;lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-comment">// Allocate a page for the process&#x27;s kernel stack.</span><br>  <span class="hljs-comment">// Map it high in memory, followed by an invalid</span><br>  <span class="hljs-comment">// guard page.</span><br>  <span class="hljs-type">char</span> *pa = kalloc();<br>  <span class="hljs-keyword">if</span>(pa == <span class="hljs-number">0</span>)<br>panic(<span class="hljs-string">&quot;kalloc&quot;</span>);<br>  uint64 va = KSTACK((<span class="hljs-type">int</span>) (p - proc));<br>  uvmmap(p-&gt;kernel_pagetable,va, (uint64)pa, PGSIZE, PTE_R | PTE_W);<br>  p-&gt;kstack = va;<br><br>  <span class="hljs-comment">// ...............</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>剩下的比较重要的部分是在进程生命周期结束的时候需要释放进程占有的内存空间。进程私有的部分可以放心释放，但是我们肯定不希望将唯一的存放内核数据的页给释放掉，这样必然导致内核崩溃。释放页表的操作可以从<code>freewalk()</code>中模仿。同时注意释放掉之前分配的内核栈的空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Free a process&#x27;s page table, and free the</span><br><span class="hljs-comment">// physical memory it refers to.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">proc_freekernelpgtb</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable)</span><br>&#123;<br>  <span class="hljs-comment">// there are 2^9 = 512 PTEs in a page table.</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">512</span>; i++)&#123;<br>    <span class="hljs-type">pte_t</span> pte = pagetable[i];<br>    <span class="hljs-keyword">if</span>((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-comment">// this PTE points to a lower-level page table.</span><br>      uint64 child = PTE2PA(pte);<br>      proc_freekernelpgtb((<span class="hljs-type">pagetable_t</span>)child);<br>      pagetable[i] = <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-keyword">else</span>&#123; <br><span class="hljs-comment">// do nothing</span><br>    &#125;<br>  &#125;<br>  kfree((<span class="hljs-type">void</span>*)pagetable);<br>&#125;<br></code></pre></td></tr></table></figure><p>将释放内核页表的部分放入<code>freeproc()</code>,同时释放内核栈。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">freeproc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> proc *p)</span><br>&#123;<br>  <span class="hljs-keyword">if</span>(p-&gt;trapframe)<br>    kfree((<span class="hljs-type">void</span>*)p-&gt;trapframe);<br>  p-&gt;trapframe = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span>(p-&gt;pagetable)<br>    proc_freepagetable(p-&gt;pagetable, p-&gt;sz);<br>  p-&gt;pagetable = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span>(p-&gt;kernel_pagetable)&#123;<br>uvmunmap(p-&gt;kernel_pagetable,p-&gt;kstack,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<span class="hljs-comment">//unmap while freeing</span><br>    proc_freekernelpgtb(p-&gt;kernel_pagetable);<br>  &#125;<br>  <span class="hljs-comment">// ..............</span><br>&#125;<br></code></pre></td></tr></table></figure><p>剩下比较关键的部分是在<code>scheduler()</code>函数中切换<code>satp</code>。在讲座中说到一个比较重要的并且之前没有想到的部分是，在没有进程正在执行的时候需要切换成原来的内核页表。原来以为没有什么重要的理由，实际上是为了防止在进程生命周期结束(用户内核页表已经被释放)，内核仍然在使用被释放的页表。这样就能在任意时刻完全保证当前所使用的页表是有效的。</p><hr><p>相比之下使用共享内核表就显得要高效得多，在2020版讲座里面教授使用的方法就是使用共享内核页表。</p><p>观察内核页表的分布可以知道，在整个内核页表的上半部分的映射关系是固定的。具体一点就是PLIC以上是固定的分布，PLIC以下是我们可以自己映射的空间。相比之下可以映射的虚拟内存空间就显得很少，只存在于根页表的0号页表项覆盖的1GB空间。所以从1号页表项到511项可以直接复制到user Kernel_pagetable, 这样就不需要重新为1～511项重新申请物理页来存放页表了。详细代码可以看<a href="https://www.bilibili.com/video/BV19k4y1C7kA/?p=6&spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=afefae5b8dc3c6db1130aadd8eaadc5f">Lecture7</a></p><h2 id="Simplied-Copyin"><a href="#Simplied-Copyin" class="headerlink" title="Simplied-Copyin"></a>Simplied-Copyin</h2><p>这个实验目的是为了让用户进程陷入内核的时候, 能够直接解引用用户进程的地址空间。这就需要在用户进程的Kernel_pagetable中映射用户的地址空间。这个能够实现的前提是在用户的内核页表的低地址中原来没有映射,并且用户进程需要的地址大小要完全处于没有映射的部分(PLIC:0x0c000000以下)</p><p>核心思想就是将用户页表中存储用户进程数据的部分给映射至用户的内核页表中,正如提示所说这个任务需要在所有更改过用户页表的地方都更新映射一次，这些地方包括<code>exec(),fork(),growup()</code>。</p><p>在之前我以为只需要将用户栈空间给映射过去就行，后来考虑到有些是地址传递需要解引用指针，所以需要把整个用户进程的页表给传递过去。刚开始我是打算就用已经有的<code>uvmcopy()</code>函数，但是这个函数的特点是对于给定的一个页表和这个页表的存储空间，完全重新分配物理内存来存放底层页表和原来的数据。显然不需要这么强的隔离性在用户空间和内核空间，不仅会产生不必要的复制开销，还需要对一些在内核更改的数据同步到用户空间。这样来看，共享一个物理地址就是一个不错的选择。为此需要编写一个函数来完成这个更新用户内核页表的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Update old pagetable to new pagetable </span><br><span class="hljs-comment">// Which share one physical page.</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">uvmupdate</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> old, <span class="hljs-type">pagetable_t</span> new, uint64 oldsz, uint64 newsz)</span><br>&#123;<br>  <span class="hljs-type">pte_t</span> *pte, *new_pte;<br>  uint64 pa, new_pa, i;<br>  uint flags;<br>  <span class="hljs-keyword">if</span> (newsz &gt; oldsz)<br>  &#123;<br>    oldsz = PGROUNDUP(oldsz);<br><span class="hljs-keyword">for</span>(i = oldsz; i &lt; newsz; i += PGSIZE)&#123;<br>  new_pte = walk(new, i, <span class="hljs-number">1</span>);<span class="hljs-comment">//find or alloc a pte</span><br>  new_pa = PTE2PA(*new_pte);<br>  <span class="hljs-keyword">if</span>((pte = walk(old, i, <span class="hljs-number">0</span>)) == <span class="hljs-number">0</span>)<br>panic(<span class="hljs-string">&quot;uvmupdate: pte should exist&quot;</span>);<br>  <span class="hljs-keyword">if</span>((*pte &amp; PTE_V) == <span class="hljs-number">0</span>)<br>panic(<span class="hljs-string">&quot;uvmupdate: page not present&quot;</span>);<br>  pa = PTE2PA(*pte);<br>  <span class="hljs-keyword">if</span>(new_pa == pa) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//this page has already been mapped.</span><br>  flags = PTE_FLAGS(*pte) &amp; ~PTE_U;<span class="hljs-comment">//kernel pagetable need no PTE_U permission.</span><br>  *new_pte = PA2PTE(pa) | flags;<br>&#125;<br>  &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(newsz &lt; oldsz)&#123;<br>  newsz = PGROUNDUP(newsz);<br>  <span class="hljs-keyword">for</span>(i = newsz; i &lt; oldsz; i+=PGSIZE)&#123;<br>  new_pte = walk(new, i, <span class="hljs-number">0</span>);<span class="hljs-comment">//find a pte now not using</span><br>  *new_pte = <span class="hljs-number">0</span>;<br>  &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数做的事就是单纯将进程的用户页表项复制到对应的内核页表项中，同时注意权限位<code>PTE_U</code>的清除。根据RISC-V的特权指令Specification中所说，当<code>sstatus</code>寄存器中的<code>SUM</code>位为0时，内核态中的进程不能访问PTE_U置位后的页表项对应的物理地址。同时，当新的空间需要缩减的时候，将不需要的页表项给清0。</p><p>接下来就是在上述说到的位置调用函数更新一下进程的内核页表。由于<code>fork(),exec()</code>更新了整个的用户页表，所以在进程的内核页表中也要全部更新。<code>growrpoc()</code>函数是在用户需要申请内存时通过系统调用<code>sbrk()</code>运行的，所以不需要整个更新，只需要关注增长或者减少了多少即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">exec</span><span class="hljs-params">(<span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>  <span class="hljs-comment">//.........................</span><br><br>  <span class="hljs-comment">// Commit to the user image.</span><br>  oldpagetable = p-&gt;pagetable;<br>  p-&gt;pagetable = pagetable;<br>  p-&gt;sz = sz;<br>  p-&gt;trapframe-&gt;epc = elf.entry;  <span class="hljs-comment">// initial program counter = main</span><br>  p-&gt;trapframe-&gt;sp = sp; <span class="hljs-comment">// initial stack pointer</span><br>  <span class="hljs-comment">// Map user process to kernel pagetable. </span><br>  <span class="hljs-comment">// Since in exec the kernelpagetable is initally blank.   </span><br>  uvmupdate(p-&gt;pagetable, p-&gt;kernel_pagetable, <span class="hljs-number">0</span>, p-&gt;sz);<br>  proc_freepagetable(oldpagetable, oldsz);<br><br>  <span class="hljs-keyword">if</span>(p-&gt;pid == <span class="hljs-number">1</span>) vmprint(p-&gt;pagetable);<br>  <span class="hljs-keyword">return</span> argc; <span class="hljs-comment">// this ends up in a0, the first argument to main(argc, argv)</span><br><br>  <span class="hljs-comment">//.........................</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-comment">//.....................................</span><br><br>  <span class="hljs-comment">// Copy user memory from parent to child.</span><br>  <span class="hljs-keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="hljs-number">0</span>)&#123;<br>    freeproc(np);<br>    release(&amp;np-&gt;lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <br>  <span class="hljs-comment">// Copy user memory from userspace to kernelspace.</span><br>  <span class="hljs-comment">// Every user process has a unique pagetable and kernelpagetable</span><br>  uvmupdate(np-&gt;pagetable, np-&gt;kernel_pagetable, <span class="hljs-number">0</span>, p-&gt;sz);<br><br>  <span class="hljs-comment">//.....................................</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">growproc</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br>  uint sz;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  sz = p-&gt;sz;<br><br>  <span class="hljs-comment">//test if user virtual memory is lower than PLIC Limit</span><br>  <span class="hljs-keyword">if</span>(sz + n &gt; PLIC)<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">if</span>(n &gt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">if</span>((sz = uvmalloc(p-&gt;pagetable, sz, sz + n)) == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>uvmupdate(p-&gt;pagetable,p-&gt;kernel_pagetable,p-&gt;sz,sz);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">0</span>)&#123;<br>    sz = uvmdealloc(p-&gt;pagetable, sz, sz + n);<span class="hljs-comment">// clear pte at uvmunmap.</span><br>uvmupdate(p-&gt;pagetable,p-&gt;kernel_pagetable,p-&gt;sz,sz);<br>  &#125;<br>  p-&gt;sz = sz;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="一点感慨"><a href="#一点感慨" class="headerlink" title="一点感慨"></a>一点感慨</h2><p>在上一次完成实验的时候就花了很多时间在这个上面，其中有一部原因是我似乎被题目下面的解析给误导了(想多了). <strong>The goal of this section and the next is to allow the kernel to directly dereference user pointers.</strong> 这句话在一开始我理解的时候就把它看成应该在这一次实验中完成能够对user space的地址解引用的操作了。然后我又没有看后面的Copyin实验，所以一直在思索如何能够在这一个实验同时完成两个实验的内容，最后知道了很是无语。</p><p>由于之前使用的是2023版本的，没有在用户进程添加页表项的实验。所以我又添加了一个2020版本的远程仓库在我的工作目录下。到此为止没有任何问题，但是我当时想着这两个版本更改也不算很多，就想着把我之前已经做完的2023pgtbl实验合并到2020pgtbl中。我合并了，也花了一点精力解决冲突，但是后来我发现我想要的那个2020版本特有的部分在合并中丢失了，Git也没有任何冲突提示。很是疑惑，找了一些资料推测可能是Git的合并机制的原因，因为这两个分支也没有共同的祖先节点，所以具体的合并机制暂时不是很清楚。想在以后找个时间好好研究研究。目前就直接用2020版本直接提交到远程仓库算了吧。</p><p>最后贴一个成功通过测试的图纪念一下：<br><img src="/2024/04/08/xv6-lab-pgtb-part2/pgtbsucceed_part2.png" alt="successfully_passed"></p><hr><p><em><strong>写在最后</strong></em>：感谢能读到这里，希望没有浪费您宝贵的时间，如果觉得还不错，不要吝啬手中的赞呦~。</p><blockquote><p>加以修改后的源代码放在了<a href="https://github.com/sycamoremoon/xv6-labs-2023">sycamoremoon’s github</a>,需要的同学可以自取。</p><p>之后还会有其他的内容上传，希望我的小小努力能够给大家带来帮助</p><p>这是<a href="sycamoremoon.online">我的网站</a>，内容会随着时间逐渐丰富的..</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>xv6-Operating system</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unix/Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xv6-lab-pgtbl</title>
    <link href="/2024/04/02/xv6-lab-pgtbl/"/>
    <url>/2024/04/02/xv6-lab-pgtbl/</url>
    
    <content type="html"><![CDATA[<h1 id="xv6-labs-pgtbl实验记录与分析"><a href="#xv6-labs-pgtbl实验记录与分析" class="headerlink" title="xv6-labs-pgtbl实验记录与分析"></a>xv6-labs-pgtbl实验记录与分析</h1><p><em><strong>写在前面</strong></em>: 这次实验花了我不少时间和精力，一方面是因为操作系统的页表机制有一定的难度，还有一方面就是自己犯傻.本次实验是独立完成，只通过官方的资料和源码获取相关的知识来修改内核。</p><p><em>题外话：我登录的课程网站是2020年的版本，但是做的实验版本是2023年的，虽然那课程内容都差不多但是实验内容却有很大的区别，所以我在开始一直很懵但是有没有看相关的解析，所以导致一直没有通过测试。后来发现测试的内容在实验内容中根本没有，这才意识到版本不对。</em></p><hr><ul><li><a href="#Pagetable">Pagetable概述</a></li><li><a href="#Core-Func">Core-Func</a></li><li><a href="#Speed-Up-System-Call">Speed-Up-System-Call</a></li><li><a href="#Print-A-Page-Table">Print-A-Page-Table</a></li><li><a href="#Page-Access">Page-Access</a></li></ul><hr><h2 id="Pagetable"><a href="#Pagetable" class="headerlink" title="Pagetable"></a>Pagetable</h2><p>在学习这次课程的时候我已经不是第一次听说过页表了，页表本身的原理十分简单，无非就是一个虚拟地址到物理地址的映射，而这样的映射关系则由页表来提供。就像课程里面老师说的一样，页表是一个小而美的东西，逻辑并不复杂但是却能提供很强大的功能，比如提供各个进程之间的隔离机制，内核态与用户态之间的权限切换等.</p><p>简单的虚拟地址只有一级页表，这一级页表中包括了所有能访问到的物理地址页。但是由于这样的结构太直接，导致了这唯一的一级页表显得十分庞大，如果给一个普通的进程分配这么大的页表会导致有些根本用不上的PTE(Page Table Entry)会浪费掉。如下图所示：如果用一个简单的一级页表在RISC-V的SV39结构下会导致每个进程都会分配到2^27 bytes的存储空间来存放这样一个大的页表，尽管绝大多部分都没有用上。</p><p><img src="/2024/04/02/xv6-lab-pgtbl/single-levelpgtb.png" alt="single-levelpgtb"></p><p>于是为了能够节省空间，必然会牺牲一定的时间作为代价。多级页表就产生了，个人的观点下多级页表就是为了解决单级页表的空间分配太大所产生的。在页表查询过程中每一个中间级别的页表的PTE都包含了下一个级别的页表的物理地址信息。从而能够一级一级的索引到最末端的leafPTE,有点类似于链表的数据结构。使用页表的还有一点好处就是页表把一些离散的内存空间通过这样的映射关系映射成了一段逻辑上连续的内存空间。对于单个的进程来说，只要正确地设置好页表，用户进程根本不知道自己使用的内存空间是连续的还是离散的，甚至都不知道到底被放在了哪个位置。每个进程只能访问自己页表中有效部分的内容(也就是拥有自己独立的地址空间)，对于不属于自己页表的内容根本没有这样的映射关系，也就不可能会导致内存的非法访问。而内核也只是完成对页表自己空间分配和添加映射的工作，正常情况也没有办法能够访问用户进程的地址空间。所以用户进程和用户进程，用户进程和内核进程之间的隔离性就很好的由 <strong>以页表机制为基础的虚拟地址</strong>实现了。多级页表在SV39中的结构可由下图得知。</p><p><img src="/2024/04/02/xv6-lab-pgtbl/multi-levelpgtb.png" alt="multi-levelpgtb"></p><p>值得注意的是：图中的satp是RISC-V中的一个专有的指向第一级页表的寄存器，当satp中不为0时，将由微处理器中的MMU(memory manage unit)自动进行对虚拟地址的转化。转化的依据就是satp所指向的第一级页表的首地址。整个流程就是上面的图所示。</p><p>至于剩下的具体页表的映射关系，可以看<a href="https://pdos.csail.mit.edu/6.1810/2023/xv6/book-riscv-rev3.pdf">xv6-book</a>的chapter3中的3.2和3.6。书中说得非常清晰，我觉得最为重要的一点就是注意kernel的页表绝大多部分都是直接映射(direct mapping),除了trampoline和为每个进程分配的内核栈(kstacks),trampoline很特殊， <strong>它对应的物理页面是由所有的进程共同享有的，所有进程的页表中的TRAMPOLINE都映射到同一个物理页面，用来处理由用户态引发的Trap</strong>。Kstack则是用户进程陷入内核之后用于运行内核代码的栈，每个用户进程都有属于自己的内核栈，这样才能彼此互不干扰。用户进程的TRAPFRAME的映射关系也比较特殊，这个TRAPFRAME在用户进程页表的位置是固定好的，但是它所指向的物理页面却每个进程都不同。这样是为了方便在trap过程中将进程的重要状态信息保存在每个进程自己的trapframe中。 <strong>在保存的过程satp还是指向用户进程的页表，所以会将TRAMPFRAME映射到进程专属的trapframe。</strong></p><h2 id="Core-Func"><a href="#Core-Func" class="headerlink" title="Core-Func"></a>Core-Func</h2><ol><li>walk函数是我认为在页表中最为重要的函数之一，同时walk函数也写得十分精美。代码不长但是每一句代码都很关键，缺一不可。我将来仔细分析本人对这个函数的理解，阅读源码时同时在后面加入了自己写的注释供参考<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Return the address of the PTE in page table pagetable</span><br><span class="hljs-comment">// that corresponds to virtual address va.  If alloc!=0,</span><br><span class="hljs-comment">// create any required page-table pages.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The risc-v Sv39 scheme has three levels of page-table</span><br><span class="hljs-comment">// pages. A page-table page contains 512 64-bit PTEs.</span><br><span class="hljs-comment">// every page-table size is a pageof allocate</span><br><span class="hljs-comment">// A 64-bit virtual address is split into five fields:</span><br><span class="hljs-comment">//   39..63 -- must be zero.</span><br><span class="hljs-comment">//   30..38 -- 9 bits of level-2 index.</span><br><span class="hljs-comment">//   21..29 -- 9 bits of level-1 index.</span><br><span class="hljs-comment">//   12..20 -- 9 bits of level-0 index.</span><br><span class="hljs-comment">//    0..11 -- 12 bits of byte offset within the page.</span><br><span class="hljs-type">pte_t</span> *<br><span class="hljs-title function_">walk</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 va, <span class="hljs-type">int</span> alloc)</span><span class="hljs-comment">//walk can be used to find or allocate</span><br>&#123;<br>  <span class="hljs-keyword">if</span>(va &gt;= MAXVA)<br>    panic(<span class="hljs-string">&quot;walk&quot;</span>);<br><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> level = <span class="hljs-number">2</span>; level &gt; <span class="hljs-number">0</span>; level--) &#123;<br>    <span class="hljs-type">pte_t</span> *pte = &amp;pagetable[PX(level, va)];<span class="hljs-comment">// find the exact page table entry,return address</span><br>    <span class="hljs-keyword">if</span>(*pte &amp; PTE_V) &#123;<span class="hljs-comment">//if one PTE valid prove that the pagetable is allocated</span><br>      pagetable = (<span class="hljs-type">pagetable_t</span>)PTE2PA(*pte);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//walk function also can be a allocater of pagetable </span><br>      <span class="hljs-keyword">if</span>(!alloc || (pagetable = (<span class="hljs-type">pde_t</span>*)kalloc()) == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">// whether allocate new page depend on the similarity of each layer </span><br>      <span class="hljs-built_in">memset</span>(pagetable, <span class="hljs-number">0</span>, PGSIZE);<br>      *pte = PA2PTE(pagetable) | PTE_V;<span class="hljs-comment">//pte in last level layer. set permission of last layer to next layer. </span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> &amp;pagetable[PX(<span class="hljs-number">0</span>, va)];<span class="hljs-comment">// at this time the address of pagetable has been tracked to lowest layer of tree.</span><br>&#125;<br></code></pre></td></tr></table></figure>首先这个walk函数的目的是将虚拟地址通过页表一一映射到相应的物理地址上去。这会出现两种情况，一种是原来的映射关系已经存在，需要walk像走路一项走过去到达目的地。还有一种就是原来的映射关系并不存在，需要新建立一个映射关系。新的映射关系建立无疑需要动态内存分配，所以总而言之，walk函数既可以用来查找映射关系，也可以用来分配内存建立映射关系，无论哪种情况都可以获得一个最终地址。</li></ol><p>现在来分析一下代码的逻辑：RISC-V进行虚拟内存映射是通过三层页表来确定的，每层页表逐层嵌套，最终在最低层找到想要的地址。所以walk函数也是一个逐层查找的过程，由于层数已知用一个循环就能搞定。在循环开始的时候对root层pagetable进行索引(PX宏将对应层的偏移量给提取出来，作为当前层偏移量的索引)。不管是哪一层的pagetable都会有512个64bit空间，这刚好对应着最小空间分配中的一页4096字节。在使用偏移量索引的时候可以不用担心内存访问空间的问题，因为虽然pagetable是一个指针，但是它总是指向一页已经alloc好的空间。</p><ol><li>假设映射关系已经存在，即上一层的页表项对应的valid标志位(PTE_V)已经置位，则会把上一层的地址作为下一层pagetable的首地址并以相同的方式查找下一个。整个循环持续两次，最高层的root地址是已经由参数给出的，需要用root查询出中间层的地址，再用中间层查询出最低层的pagetable首地址。到此为止，整个循环已经结束，最终地址根据首地址加偏移量索引到相应的页表项获得。注意，最后一次的索引只是单纯的数组偏移获得，其中保存的具体值是不清楚的。</li><li>当映射关系不存在的时候，代码进入<code>else</code>分支。当alloc标志位置位的时候允许动态内存分配新页表。这里用了一个c语言的<code>||</code>技巧提高了代码执行的效率：就是当标志位为0时直接不会看后面的部分。如果分配成功就将新的pagetable首地址设置成新分配页的首地址，注意此时的pagetable已经对应了下一级的首地址。紧接着用<code>memset</code>函数将新分配的一页空间全部清零，然后<code>*pte = PA2PTE(pagetable) | PTE_V;</code> 非常值得注意，这里的pte指的是上一层的pagetable entry的地址，将下一层的pagetable首地址和相应标志位赋值给pte取地址后的那个存信息的页表项。 <strong>不管是赋值还是设置标志位都是针对上一层的pagetable</strong>,和下一层没有任何关系。 <strong>所以最后的return并不对最低层的页表项的内容负责，里面无论是何内容walk函数都无从得知</strong>。</li></ol><p>理解这个walk查找映射和分配映射的逻辑关系后，很容易发现：是否要申请新页表建立映射关系完全取决于虚拟地址的分布。最理想的情况就是整个虚拟地址到物理地址的映射只需要三个pagetable。什么时候需要多于三个的pagetable呢？ <strong>需要的页表多于512个时肯定是要增加页表的，同时虚拟地址不连续也会导致页表的增加，根据walk函数可以看出当最高层不一致的时候就需要额外分配两个页表，当最高层一致中间层不一致的时候需要额外分配一个页表，只有最底层不一致的时候就不需要额外分配页表了。</strong></p><ol start="2"><li>看懂了walk函数再来看<code>mappages()</code>函数就很清楚了：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">mappages</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa, <span class="hljs-type">int</span> perm)</span><br>&#123;<br>  uint64 a, last;<br>  <span class="hljs-type">pte_t</span> *pte;<br><br>  <span class="hljs-keyword">if</span>((va % PGSIZE) != <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;mappages: va not aligned&quot;</span>);<br><br>  <span class="hljs-keyword">if</span>((size % PGSIZE) != <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;mappages: size not aligned&quot;</span>);<br><br>  <span class="hljs-keyword">if</span>(size == <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;mappages: size not valid&quot;</span>);<br>  <br>  a = va;<br>  last = va + size - PGSIZE; <span class="hljs-comment">// last page head-address </span><br>  <span class="hljs-keyword">for</span>(;;)&#123;<br>    <span class="hljs-keyword">if</span>((pte = walk(pagetable, a, <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>) <span class="hljs-comment">// walk return a physical address to store every PTES</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span>(*pte &amp; PTE_V)<span class="hljs-comment">//only when the pte valid flag is not set (not mapped)</span><br>      panic(<span class="hljs-string">&quot;mappages: remap&quot;</span>);<br>    *pte = PA2PTE(pa) | perm | PTE_V;<br>    <span class="hljs-keyword">if</span>(a == last)<br>      <span class="hljs-keyword">break</span>;<br>    a += PGSIZE;<br>    pa += PGSIZE;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>除去前面的对参数的有效性判断核心代码就是这个循环，a代表第一个页表的首地址，last代表最后一个页表的 <strong>首地址</strong>。在调用walk函数获得一个虚拟地址对应的页表项之后，首先判断这个页表项的有效性(之前说到walk函数并不保证返回的页表项的有效性),检查无误后 <strong>将这个虚拟地址对应的物理地址按照合法格式放在这个虚拟地址对应的页表项中</strong>。之后RISC-V的MMU(memory management unit)将会根据这个映射关系自动处理虚拟地址。对于接下来的几页也按相同的方式进行处理，直到break发生。</li></ol><p>以上就是我觉得实现也表机制的两个最为关键的两个函数，特别是walk函数，它模拟了MMU对虚拟地址的处理，让我们能够在配置页表的时候能够建立或者查询到这样的映射关系。余下的配置函数就是结合以上两个关键函数和kalloc.c中对内存动态管理的函数构造的，比较简单，但是需要注意页表之间的配置顺序，不要重复映射一个页表，也不要重复释放一个页表。</p><hr><p> 在开始分析后面的实验之前我想简单说说我做的2020版本的实验，我只做到第一个就发现了问题，所以目前只做了第一个，也没有测试程序来测试是否正确。但是2020版本的那个“让用户进程陷入内核之后能够直接对传入的地址能够解引用” 确实花了我不少精力。我的思路就是将建立一个用户的内核页表专属于一个进程，在用户进程陷入内核后使用用户进程自己的内核页表来处理。同时建立一个映射关系在用户内核页表和用户进程在用户态使用的栈之间，这样就可以直接访问用户态的栈。同时由于这个用户进程的内核页表只属于一个专属的进程，所以只需要将那个对应的kstack添加到用户内核页表中就可以了。</p><p>完成这个工作需要考虑的东西比较多，发生了许许多多的问题。稍微一不注意就会导致系统<code>panic</code>或者进入<code>kernelvec</code>无限循环。所以我不得已会使用到GDB进行调试，参考了这个写得很好的<a href="https://beej.us/guide/bggdb/">Quick GDB</a>。后来发现这个对于GDB的使用是在syscall实验部分就要求掌握的，也算是殊途同归了。</p><p>由于我感觉这个实验想要完成需要的知识肯定不止于对Pagetable的掌握，所以我还继续学习了关于上下文切换，由内核和用户态引起的Trap，还有一些汇编过程的知识。这才让我对系统的启动和工作有了初步的认识，才有信心继续完成实验。当然最后发现这个其实不需要做，实际上要做的比较简单我在之前学习的基础上只花了2～3个小时就完成了本次的3个实验。</p><h2 id="Speed-Up-System-Call"><a href="#Speed-Up-System-Call" class="headerlink" title="Speed-Up-System-Call"></a>Speed-Up-System-Call</h2><p>这个练习的在理解页表结构和题意之后就是十分简单. 题目的意识就是实现一个快捷的系统调用，不需要陷入内核，上下文切换造成的额外开销。简单的一个函数调用就完成了以前的系统调用的功能。于是就需要一个存放信息的页面，这个页面在用户进程页表中叫USYSCALL，处于紧挨着TRAPFRAME的下面。快捷的系统调用就直接访问这个用户进程私有的物理页面获取数据。</p><ol><li>首先需要在进程结构体中添加一个指向这个USYSCALL的指针</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Per-process state</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> &#123;</span><br>  <span class="hljs-comment">//........</span><br>  <span class="hljs-comment">// these are private to the process, so p-&gt;lock need not be held.</span><br>  uint64 kstack;               <span class="hljs-comment">// Virtual address of kernel stack</span><br>  uint64 sz;                   <span class="hljs-comment">// Size of process memory (bytes)</span><br>  <span class="hljs-type">pagetable_t</span> pagetable;       <span class="hljs-comment">// User page table</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">trapframe</span>;</span> <span class="hljs-comment">// data page for trampoline.S</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usyscall</span> * <span class="hljs-title">usyscall</span>;</span>  <span class="hljs-comment">// data page for simple syscall from userspace.   </span><br>  <span class="hljs-comment">//........</span><br>&#125;;<br></code></pre></td></tr></table></figure><ol start="2"><li>接下来的操作就是在用户进程页表中将usyscall映射到USYSCALL，这样在访问USYSCALL的时候就相当与访问了用户进程结构体的usyscall成员. <strong>整个配置用户进程页表的过程中都是在内核态进行</strong>,所以整个proc结构体的地址信息都是处于内核页表的映射下的，而 <strong>内核页表的这部分是直接映射，所以相当于物理地址了</strong>。仿照trapframe在<code>proc_pagetable()</code>中添加映射,这时候页面的权限需要PTE_R和PTE_U。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Create a user page table for a given process, with no user memory,</span><br><span class="hljs-comment">// but with trampoline and trapframe pages.</span><br><span class="hljs-type">pagetable_t</span><br><span class="hljs-title function_">proc_pagetable</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> proc *p)</span><br>&#123;<br>  <span class="hljs-type">pagetable_t</span> pagetable;<br><br>  <span class="hljs-comment">// An empty page table.</span><br>  pagetable = uvmcreate();<br>  <span class="hljs-keyword">if</span>(pagetable == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">//.........................</span><br><br>  <span class="hljs-comment">//map the USYSCALL page just below the trapframe.</span><br>  <span class="hljs-comment">//the Permisson bit is RU users space can get access to it.</span><br>  <span class="hljs-keyword">if</span>(mappages(pagetable, USYSCALL,PGSIZE,<br>  (uint64)p-&gt;usyscall, PTE_R | PTE_U) &lt; <span class="hljs-number">0</span>)&#123;<br>  uvmunmap(pagetable, TRAMPOLINE, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  uvmfree(pagetable,<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> pagetable;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>映射关系有了，但是还没有为USYSCALL分配实际的物理空间，接下来就是分配空间并且在这个空间里面填充需要快速直接给用户进程的信息。每个进程的创建都需要执行<code>allocproc()</code>函数，这也是最好的位置进行以上的工作。注: <strong><code>kalloc()</code>函数分配空间是以一页4KB为单位的，页表映射也是以页为单位的，可以变化的是我们对这一个指向一页空间的地址的解读,这里通过很多casting转化了指针类型，也就是只使用了这一页的一部分空间。</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> proc*<br><span class="hljs-title function_">allocproc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span><br><br>  <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;<br>    acquire(&amp;p-&gt;lock);<br>    <span class="hljs-keyword">if</span>(p-&gt;state == UNUSED) &#123;<br>      <span class="hljs-keyword">goto</span> found;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      release(&amp;p-&gt;lock);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>found:<br>  p-&gt;pid = allocpid();<br>  p-&gt;state = USED;<br><br>  <span class="hljs-comment">//....................</span><br><br>  <span class="hljs-comment">//Allocate a usyscall page </span><br>  <span class="hljs-keyword">if</span>((p-&gt;usyscall = (<span class="hljs-keyword">struct</span> usyscall *)kalloc()) == <span class="hljs-number">0</span> )&#123;<br>  freeproc(p);<br>  release(&amp;p-&gt;lock);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  p-&gt;usyscall-&gt;pid = p-&gt;pid;<span class="hljs-comment">//init the usyscall data here </span><br><br>  <span class="hljs-comment">//.................</span><br><br>  <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="Print-A-Page-Table"><a href="#Print-A-Page-Table" class="headerlink" title="Print-A-Page-Table"></a>Print-A-Page-Table</h2><p>关于这个部分其实没什么好说的，就是写一个函数而已。提示说参考<code>freewalk()</code>函数，函数很短是用递归完成的，但是我对递归不太熟练，由于环境原因根本没怎么写过递归。想到这又不是算法课要考虑时间复杂度，所以直接用循环简单粗暴完成了，还方便调试,就是不太美观。看看就好，网上有很多用递归实现的可以学习。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//used for print pagetable mapping and physical adddress.</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vmprint</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable)</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;page table %p\n&quot;</span>,pagetable);<br><span class="hljs-type">pte_t</span> pte_top, pte_mid, pte_low;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">512</span>; i++)<br>&#123;<br>pte_top = pagetable[i];<br><span class="hljs-keyword">if</span>(pte_top &amp; PTE_V)<br>&#123; <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;..%d: pte %p pa %p\n&quot;</span>,i, pte_top, PTE2PA(pte_top));<br><span class="hljs-type">pagetable_t</span> mid_pagetable = (<span class="hljs-type">pagetable_t</span>)PTE2PA(pte_top);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">512</span>; j++)<br>&#123;<br>pte_mid = mid_pagetable[j];<br><span class="hljs-keyword">if</span>(pte_mid &amp; PTE_V)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;.. .. %d: pte %p pa %p\n&quot;</span>,j ,pte_mid, PTE2PA(pte_mid));<br><span class="hljs-type">pagetable_t</span> low_pagetable = (<span class="hljs-type">pagetable_t</span>)PTE2PA(pte_mid);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">512</span>; k++)<br>&#123;<br>pte_low = low_pagetable[k];<br><span class="hljs-keyword">if</span>(pte_low &amp; PTE_V) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;.. .. ..%d: pte %p pa %p\n&quot;</span>,k ,pte_low, PTE2PA(pte_low));<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Page-Access"><a href="#Page-Access" class="headerlink" title="Page-Access"></a>Page-Access</h2><p>这个练习虽然标的是hard，但是我并不觉得有什么难度。可能是已经一定程度理解了页表的机制。练习很贴心地把这个<code>pgaccess()</code>的配置工作给完成了。只需要写好系统调用<code>sys_pgaccess()</code>就可以了。先看代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//system call pgaccess.</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pgaccess</span><span class="hljs-params">(<span class="hljs-type">void</span> *base, <span class="hljs-type">int</span> len, <span class="hljs-type">void</span> *mask)</span>;<br><br><span class="hljs-comment">//Function body</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">sys_pgaccess</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-comment">// lab pgtbl: your code here.</span><br>  uint64 vmstart;<br>  <span class="hljs-type">int</span> numofpg;<br>  uint64 vmmask;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> * <span class="hljs-title">p</span> =</span>myproc();<br>  argaddr(<span class="hljs-number">0</span>, &amp;vmstart);<span class="hljs-comment">//get page&#x27;s vitual memory start</span><br>  argint(<span class="hljs-number">1</span>, &amp;numofpg);<span class="hljs-comment">//get num of pages need to look up</span><br>  argaddr(<span class="hljs-number">2</span>, &amp;vmmask);<span class="hljs-comment">//get the address for store the result</span><br>  uint32 mask =<span class="hljs-number">0</span>;<br>  numofpg = (numofpg &gt; <span class="hljs-number">32</span> ? <span class="hljs-number">32</span> : numofpg);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numofpg; i++)<br>  &#123;<br>  <span class="hljs-type">pte_t</span> * pte = walk(p-&gt;pagetable,vmstart+PGSIZE*i,<span class="hljs-number">0</span>);<span class="hljs-comment">//walk along with process&#x27;s pagetable,do not allocate new pagetable.</span><br>  <span class="hljs-keyword">if</span>(*pte &amp; PTE_A)<span class="hljs-comment">//Acess permission</span><br>  &#123;<br>  mask = mask | (<span class="hljs-number">1</span> &lt;&lt; i);<br>  *pte = *pte &amp; ~PTE_A;<br>  &#125;<br>  &#125;<br>  copyout(p-&gt;pagetable, vmmask, (<span class="hljs-type">char</span> *)&amp;mask, <span class="hljs-keyword">sizeof</span>(mask));<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>相信看见代码就很清楚了，不过还是大致讲解一下。<br>有一个我仔细考虑的地方是：<code>pgaccess()</code>的第三个参数的作用是传递一个数的地址，在处理完后将页表的状态信息存在相应的位上，如果第i页被Access就将数的第i位置为1。所以对于这个参数应该是用一个int接收还是一个指针接收不太确定。在RISC-V中的指针是一个64位的数据，所以应该用一个64位宽度的数据来存储它，确定了应该用<code>argaddr()</code> 而不是<code>argint()</code>，所以上面的<code>vmmask</code>实际上存放的是一个地址。</p><p>然后for循环就是对所有的页表进行遍历，查询PTE_A位有没有被置1,如果有就将临时变量掩码<code>mask</code>的相应位置1并且重置PTE_A位。最后，就像提示中说的用<code>copyout()</code>函数将内核空间的mask变量复制到用户空间的<code>vmmask</code>指向的位置。至于PTE_A的定义是需要看RISC-V的Spec来确定的。<br><img src="/2024/04/02/xv6-lab-pgtbl/pte.png" alt="pte_permission"></p><hr><p>至此pgtbl实验就完成了，最后不由得感叹人类的智慧如此伟大，在一个说白了就是一个存储器上经过逻辑抽象加上物理实现，完成了这么多样化而且十分丰富的数据结构，真正的不断逼近这块简单的DRAM的存储器的极限。这样的方法无疑是让人激动的，回想起自己学习开发整个页表的过程就发自内心的感到不可思议。这次实验确实花了很多时间精力，但是无疑是值得的。</p><p>贴一个成功通过测试的图片纪念一下。<br><img src="/2024/04/02/xv6-lab-pgtbl/succeed.png" alt="successfully_passed"></p><hr><p><em><strong>写在最后</strong></em>：感谢能读到这里，希望没有浪费您宝贵的时间，如果觉得还不错，不要吝啬手中的赞呦~。</p><blockquote><p>加以修改后的源代码放在了<a href="https://github.com/sycamoremoon/xv6-labs-2023">sycamoremoon’s github</a>,需要的同学可以自取。</p><p>之后还会有其他的内容上传，希望我的小小努力能够给大家带来帮助</p><p>这是<a href="sycamoremoon.online">我的网站</a>，内容会随着时间逐渐丰富的..</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>xv6-Operating system</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unix/Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xv6-lab-syscall</title>
    <link href="/2024/03/17/xv6-lab-syscall/"/>
    <url>/2024/03/17/xv6-lab-syscall/</url>
    
    <content type="html"><![CDATA[<h1 id="xv6-labs-syscall实验记录与分析"><a href="#xv6-labs-syscall实验记录与分析" class="headerlink" title="xv6-labs-syscall实验记录与分析"></a>xv6-labs-syscall实验记录与分析</h1><p><em><strong>写在前面</strong></em>:这次实验的前一个任务在完成的时候参考了网络上的资料，因为之前都是写的一个程序，这次需要自己配置内核添加系统调用。完成第一个实验的时候有点懵，后面的一个是独立完成的。</p><hr><ul><li><a href="#OS_%E7%BB%84%E7%BB%87%E5%BD%A2%E5%BC%8F">操作系统的基本组织形式</a></li><li><a href="#syscall%E6%B5%81%E7%A8%8B">系统调用的流程整理</a></li><li><a href="#trace">trace_syscall</a></li><li><a href="#sysinfo">sysinfo</a></li></ul><hr><p>在开始完成实验之前，需要阅读教材的chapter 2 和chapter 4 的有关内容，因为本次实验没有课程讲解，所以阅读教材是必须的。除了教材之外，阅读xv6的内核源码也是不可缺少的一部分，因为有些系统调用的实现不看源码是不能理解的。所以我花了不少时间在这上面。</p><h2 id="OS-组织形式"><a href="#OS-组织形式" class="headerlink" title="OS_组织形式"></a>OS_组织形式</h2><p>这部分的内容主要在chapter 2 中描述，简要讲解了xv6的目的以及组织方式。在此仅记录本人的理解，获得准确的描述<a href="https://pdos.csail.mit.edu/6.828/2020/xv6/book-riscv-rev1.pdf">请阅读原文</a>.</p><p>关于操作系统的作用，我目前浅显的认识是为了把硬件资源如CPU，存储器，一些外设等硬件与用户的软件隔离开，这样的话能够更有效的管理的分配硬件资源。有了操作系统作为背后的调控者，许多软件就能处于一个并行执行的状态，CPU密集型的程序占用更多的CPU资源，IO密集型程序占用更多的IO资源。这样使得硬件资源不会过多处于一个空转的浪费情况。</p><p>由于目前的微处理器已经普遍支持不同软件执行模式的切换，比如RISC-V就有着用户模式，管理员模式，以及机器模式(user mode, supervisor mode, machine mode).一般来说重要的内核程序是运行在管理员模式下的，这样内核程序就有着基本所有的对硬件资源的访问权限，能够直接对硬件进行操作。而用户程序只运行在用户模式，没有对硬件的直接控制权，每次需要访问硬件资源（比如读取存储器的信息）都需要通过运行在管理员模式的内核程序来代替执行，这个过程叫做 **陷入内核(trap)**。当然这也是一个重要的原因来保证当用户程序出错的时候不会影响到其他用户程序。</p><p>此外，也有例外情况。以上说到的整个内核都在管理员模式下有着高级权限的方式叫做 <strong>monolithic kernel</strong>,这样的内核工作方式理论上是没有任何问题的，但是这样的内核提供了很多系统调用的接口，十分复杂难以管理，并且要在编写内核程序的时候保证内核程序本身没有任何BUG，不然就会导致错误在supervisor mode下发生，这样的错误无疑是致命的。所以就有了相对而言更轻量级别的内核： <strong>mircokernel</strong>。这样的方式是仅仅将一些最为重要的系统调用给放在supervisor mode ，比如最最基本的文件read和write等，剩下的一部分服务放在用户空间处于user mode 模式下，当需要这样的服务的时候再经内核之手再被调用(即使处于user mode 用户程序也不能直接调用的).</p><p>xv6的内核组织形式是说到的monolithic kernel, 这也是当前各大主流通用操作系统如Linux，FreeBSD等的组织形式。mircokernel一般用于一些嵌入式操作系统中。</p><h2 id="syscall流程"><a href="#syscall流程" class="headerlink" title="syscall流程"></a>syscall流程</h2><p>对于xv6系统的启动流程，此处就不再赘述，目前理解不够深入担心会误导大家。总之对于这种底层的配置是离不开汇编的，可以自己阅读chapter 2.6<a href="https://pdos.csail.mit.edu/6.828/2020/xv6/book-riscv-rev1.pdf">原文</a>. 对于系统调用的流程，经过我的思考与实践总结出流程如下：</p><p>凡是一个系统调用，它本身就和一个普通的函数有着本质的区别。用read函数举例的话，每当在程序用遇到read这样形似函数的系统调用的时候，就会 **陷入内核(这是系统调用和普通函数最主要的区别)**。对于一个系统调用read,当执行到它的时候并不会跳转到一个名为read的函数体中去，而是会跳转到一段汇编程序，这段汇编程序的生成在usys.pl中按照规范配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm">.global read<br>trace:<br> li a7, SYS_read<br> ecall<br> ret<br></code></pre></td></tr></table></figure><p> ecall指令使其陷入内核,其中包括了一些状态信息的保存(trapframe)和进入内核执行syscall函数，syscall函数应该就是处于一个supervisor mode下运行的函数。注意是所有的系统调用都会跳转到这里，那么如何区分具体是要执行哪个系统调用呢？是根据保存在a7寄存器中的系统调用号来进行判断是要具体执行哪个。如下所示：这个SYS_read是一个索引，一个整数而已，索引到了一个名为sys_read的实际函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-title function_">uint64</span> <span class="hljs-params">(*syscalls[])</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> = &#123;<br>[SYS_fork]    sys_fork,<br>[SYS_exit]    sys_exit,<br>[SYS_wait]    sys_wait,<br>[SYS_pipe]    sys_pipe,<br>[SYS_read]    sys_read,<span class="hljs-comment">// 只截取了部分</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，syscalls是一个 <strong>函数指针数组</strong>(没错疯狂套娃),没一个成员都是一个函数指针参数为void，返回值为uint64。还有一点需要注意是在定义数组的时候用中括号指定编号是C语言的一种冷门语法。这样对应的成员就可以任意排序。</p><p>当然，sys_read这类的函数才是真正要被执行的，需要开发人员自行编写。可以定义在别处，但是要在syscall中声明。然后有一点在刚开始非常不解的就是有些系统调用比如fork，在它的sys_fork函数体中就是只单纯调用了一下fork这个函数。这样也说明了系统调用和函数的区别，同样是名为fork，fork函数就是直接被调用，fork系统调用就需要陷入内核再执行sys_fork。</p><p>所以想要添加一个系统调用至少需要一下几个步骤:</p><ol><li>在user.h中添加系统调用接口</li><li>修改系统调用入口配置usys.pl, 生成一个汇编文件指示系统调用时跳转的实际入口。</li><li>在syscall.h中添加系统调用号</li><li>在syscall.c中添加系统调用函数入口，声明实际系统调用函数入口，添加新增的trace系统调用需要的名称</li><li>在相应的源文件中定义实际被调用的系统调用函数</li></ol><h2 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h2><p>这个任务本身是不难的，但是由于刚开始没有弄懂题目描述的含义。所以寻求了一下网友的帮助。</p><p>要达成题目的要求在指定的系统调用每发生一次的时候都要打印相关的信息，所以这个打印的步骤肯定不能在sys_trace中完成，因为这样的话最多只能被执行一次。之前说道所有的系统调用都会跳转到syscall这个函数，然后根据寄存器的索引值来确定某个特定的系统调用，所以答案已经很显然了，就是将printf放在syscall函数中。然后根据相应的索引值建立一个表来展示相应的系统调用的名称。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">char</span> * syscall_name[] = &#123;<br>[SYS_fork]    <span class="hljs-string">&quot;fork&quot;</span>,<br>[SYS_exit]    <span class="hljs-string">&quot;exit&quot;</span>,<br>[SYS_wait]    <span class="hljs-string">&quot;wait&quot;</span>,<br>[SYS_pipe]    <span class="hljs-string">&quot;pipe&quot;</span>,<br>[SYS_read]    <span class="hljs-string">&quot;read&quot;</span>,<span class="hljs-comment">//仅展示部分</span><br>&#125;<br></code></pre></td></tr></table></figure><p>还剩一些细节的处理，比如修改fork函数，在struct proc中添加成员等操作等等，在想好思路之后都是很自然的事情。这里附上一篇博客写得很详细，在此就不赘述。<a href="https://blog.miigon.net/posts/s081-lab2-system-calls/">trace博客</a></p><h2 id="sysinfo"><a href="#sysinfo" class="headerlink" title="sysinfo"></a>sysinfo</h2><p>在有了前一次的经验之后，再来完成这道题就显得简单了。题目的要求是在调用这个sysinfo系统调用之后能后获取到当前系统的两个状态信息。一个是还剩余多少可用的空间，还有一个是当前标记为 <strong>UNUSED</strong>状态的进程数目。这两个状态信息通过一个定义好的结构体传输。</p><p>关于如何从内核向用户空间传递信息的方法，有提示中告诉我们可以参考<code>sys_fstat()</code>和<code>filestat()</code>的实现方法。在老老实实看完内核中提供的示范之后，就对这个方法感到十分清晰了。示范代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64<br><span class="hljs-title function_">sys_fstat</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span>;</span><br>  uint64 st; <span class="hljs-comment">// user pointer to struct stat</span><br>  <span class="hljs-comment">//get the struct stat address from register 1</span><br>  argaddr(<span class="hljs-number">1</span>, &amp;st);<br>  <span class="hljs-keyword">if</span>(argfd(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, &amp;f) &lt; <span class="hljs-number">0</span>)<span class="hljs-comment">//change where the f point to what fd refers from register 0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">return</span> filestat(f, st);<span class="hljs-comment">//copy struct stat to a certain address (st) from a struct file </span><br>&#125;<br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">filestat</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *f, uint64 addr)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br>  <br>  <span class="hljs-keyword">if</span>(f-&gt;type == FD_INODE || f-&gt;type == FD_DEVICE)&#123;<br>    ilock(f-&gt;ip);<br>    stati(f-&gt;ip, &amp;st);<br>    iunlock(f-&gt;ip);<br>    <span class="hljs-keyword">if</span>(copyout(p-&gt;pagetable, addr, (<span class="hljs-type">char</span> *)&amp;st, <span class="hljs-keyword">sizeof</span>(st)) &lt; <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过阅读上述代码，我们可以得知在系统调用<code>sys_fstat()</code>中首先从寄存器0和1获取了参数保存在临时变量中，特别要注意，这里保存地址的方式不是用的指针，而是把地址直接存放在了一个64位的整形变量st中。之后argfd的作用就是把struct file 类型的指针指向特定文件描述符确定的一个struct file。后面的filestat函数就相当于是一个复制的工作，用<code>copyout()</code>来完成. </p><p>sys_sysinfo()代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64<br><span class="hljs-title function_">sys_sysinfo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysinfo</span> <span class="hljs-title">ifo</span>;</span><br>uint64 si;<br><br>argaddr(<span class="hljs-number">0</span>,&amp;si);<br>ifo.freemem = kgetrest();<br>ifo.nproc = procget();<br><span class="hljs-keyword">if</span>(copyout(p-&gt;pagetable,si,(<span class="hljs-type">char</span> *)&amp;ifo,<span class="hljs-keyword">sizeof</span>(ifo))&lt;<span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>知道了如何把数据从内核复制到用户空间，现在就来看看是如何获取数据的吧。</p><ul><li><p>关于内存分配的函数都放在了<code>kernel/kalloc.c</code>文件中，要获取剩余空间就要考虑整个空间分配是如何运作的。阅读源码之后了解到，整个存储空间的分配是基于一个单向链表的数据结构。每一页的字节数用宏定义确定，空间分配和释放的最小单位也是页。所以只需要知道一共还剩多少页空间没有利用就能知道还剩多少字节数了。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">next</span>;</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">freelist</span>;</span><br>&#125; kmem;<br><br><span class="hljs-comment">// Free the page of physical memory pointed at by pa,</span><br><span class="hljs-comment">// which normally should have been returned by a</span><br><span class="hljs-comment">// call to kalloc().  (The exception is when</span><br><span class="hljs-comment">// initializing the allocator; see kinit above.)</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">kfree</span><span class="hljs-params">(<span class="hljs-type">void</span> *pa)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span><br><br>  <span class="hljs-keyword">if</span>(((uint64)pa % PGSIZE) != <span class="hljs-number">0</span> || (<span class="hljs-type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)<br>panic(<span class="hljs-string">&quot;kfree&quot;</span>);<br><br>  <span class="hljs-comment">// Fill with junk to catch dangling refs.</span><br>  <span class="hljs-built_in">memset</span>(pa, <span class="hljs-number">1</span>, PGSIZE);<br><br>  r = (<span class="hljs-keyword">struct</span> run*)pa;<br><br>  acquire(&amp;kmem.lock);<br>  r-&gt;next = kmem.freelist;<span class="hljs-comment">//consider that the memory location is not continue</span><br><span class="hljs-comment">//make a one direction list listing all free memory</span><br>  kmem.freelist = r;<br>  release(&amp;kmem.lock);<br>&#125;<br></code></pre></td></tr></table></figure><p>  由于动态内存分配的原因，长时间系统分配内存释放内存之后会导致内存空间处于一个不连续的分布。所以释放也是基于链表的不连续释放。比如有一页不会需要了，kfree先将这一页的链表尾端指向之前的链表头部，然后将新的链表头部设置为这一页的开始。也就是所谓的 <strong>链表头插数据</strong>。考虑到全局变量会被默认赋值为0。所以可以确定链表的尾端就是0。</p><p>  查询剩余空间的函数如下所示：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//Get infomation of the rest free memory(bytes)</span><br>uint64<br><span class="hljs-title function_">getrest</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">int</span> block;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> * <span class="hljs-title">r</span> =</span> kmem.freelist;<br><span class="hljs-keyword">for</span>(block = <span class="hljs-number">0</span>; r != <span class="hljs-number">0</span> ;block++)<br>r = r-&gt;next;<br><span class="hljs-keyword">return</span> (block*PGSIZE);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>同样的形式，我们再来定义一个函数用来获取我们需要的进程数。<br>  进程相关的函数在<code>kernel/proc.c</code>中定义，这个任务其实非常简单，只要明白一个结构体的成员就可以。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">procstate</span> &#123;</span> UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE &#125;;<br><br><span class="hljs-comment">// Per-process state</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br><br>  <span class="hljs-comment">// p-&gt;lock must be held when using these:</span><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">procstate</span> <span class="hljs-title">state</span>;</span>        <span class="hljs-comment">// Process state</span><br>  <span class="hljs-type">void</span> *chan;                  <span class="hljs-comment">// If non-zero, sleeping on chan</span><br>  <span class="hljs-type">int</span> killed;                  <span class="hljs-comment">// If non-zero, have been killed</span><br>  <span class="hljs-type">int</span> xstate;                  <span class="hljs-comment">// Exit status to be returned to parent&#x27;s wait</span><br>  <span class="hljs-type">int</span> pid;                     <span class="hljs-comment">// Process ID</span><br>  &#125;<span class="hljs-comment">//省略部分成员</span><br></code></pre></td></tr></table></figure><p>  这个结构体的成员有一个state枚举类型就标识着这个进程的状态。一个循环就搞定，没有什么可以说的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Get the processes which state is not UNUSED</span><br>uint8<br><span class="hljs-title function_">procget</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>uint8 i = <span class="hljs-number">0</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> * <span class="hljs-title">process</span>;</span><br><span class="hljs-keyword">for</span>(process=proc;process &lt; &amp;proc[NPROC];process++)<br>&#123;<br><span class="hljs-keyword">if</span>(process-&gt;state != UNUSED)<br>i++;<br>&#125;<br><span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><p>这样本次实验就算成功完成了，留下一个成功通过测试的标志纪念一下。<br><img src="/2024/03/17/xv6-lab-syscall/syscall.png" alt="syscall_grade"></p><hr><p><em><strong>写在最后</strong></em>：感谢能读到这里，希望没有浪费您宝贵的时间，如果觉得还不错，不要吝啬手中的赞呦~。</p><blockquote><p>加以修改后的源代码放在了<a href="https://github.com/sycamoremoon/xv6-labs-2023">sycamoremoon’s github</a>,需要的同学可以自取。</p><p>之后还会有其他的内容上传，希望我的小小努力能够给大家带来帮助</p><p>这是<a href="sycamoremoon.online">我的网站</a>，内容会随着时间逐渐丰富的..</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>xv6-Operating system</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unix/Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>remap caps to esc/ctrl</title>
    <link href="/2024/03/14/esc-ctrl/"/>
    <url>/2024/03/14/esc-ctrl/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux下将Caps重映射为Esc和Ctrl的一种简便方法"><a href="#Linux下将Caps重映射为Esc和Ctrl的一种简便方法" class="headerlink" title="Linux下将Caps重映射为Esc和Ctrl的一种简便方法"></a>Linux下将Caps重映射为Esc和Ctrl的一种简便方法</h1><p><em><strong>写在前面</strong></em>: 本文是对于Linux操作系统下，对于标准键盘的键盘重映射的记录，同时能够给想对键盘重映射的同学提供一个参考。</p><hr><ul><li><a href="#%E9%97%AE%E9%A2%98%E5%BC%95%E5%85%A5">问题引入</a></li><li><a href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95">常见的解决方法</a></li><li><a href="#%E5%8E%9F%E5%88%9B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95">原创解决方法</a></li></ul><hr><h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><blockquote><p>由于本文更多是为了记录的目的，如果不想听个人的罗嗦，可以直接跳转到<a href="#%E9%85%8D%E7%BD%AExmodmap">快速解决</a>。</p></blockquote><p>在使用Vim的过程中，经常会使用到Esc键来进行Normal模式和Insert模式的切换。但是由于Esc键位距离主键盘的位置太远，所以需要自己进行设置。方式也有很多：有使用快捷键进行代替的，也有用Ctrl+]代替的。但是本人不喜欢这样优柔寡断的解决方案。希望能够在不仅仅使用Vim时做到esc键位的方便，在其他软件的使用中也能做到同样的效果。</p><p>所以，在网络上搜索之后发现了对键盘键位进行重映射的方法。于是才有了这篇文章。</p><h2 id="常见的解决方案"><a href="#常见的解决方案" class="headerlink" title="常见的解决方案"></a>常见的解决方案</h2><p>一开始我在网络上找到了很多种键位重映射的方案</p><ol><li>使用xmodmap，<a href="https://www.cnblogs.com/uestcliming666/p/13196572.html">参考教程网站</a></li><li>使用XCaps软件辅助，<a href="https://www.jianshu.com/p/6fdc0e0fb266">参考教程网站</a></li><li>使用caps2esc软件达到重映射的效果，<a href="https://orxing.top/post/d3c3145e.html#%E5%85%B6%E4%BB%96">参考网站教程</a></li></ol><h3 id="xcaps"><a href="#xcaps" class="headerlink" title="xcaps"></a>xcaps</h3><p>一开始我是使用的第二种方案，对于新手来说比较友好，也不需要配置复杂的环境。按照教程操作之后确实可以达到我想要的效果：Caps短按是Esc，按组合键是Ctrl。但是原来的Ctrl键变成了CapsLosck键，这一时间有些不习惯，会导致经常性按错。但是这不是主要原因我放弃了它，转而寻找一种新的方法。真正的不可接受的是，在我的电脑环境下(Ubuntu 22.04LTS), <strong>经常性的失灵</strong>,这使得我在某个时间正愉快地编辑的时候，突然发现键位变了。想要恢复还得重启电脑(可能有简单的方法我没有找到).</p><h3 id="caps2esc"><a href="#caps2esc" class="headerlink" title="caps2esc"></a>caps2esc</h3><p>在这个时间段里面，我同时也在尝试给我的Windows系统也修改一下键位的映射。不然在系统切换的时候得用两套不同的键盘很难受。于是我在网络上找到了，caps2esc这个软件。也就是上面提到的第三种方案。按照里面的教程我很快就在WIndows中配置好了。而且在Windows中的这个软件稳定性很高，并且能够保留原来的Ctrl功能，把CapsLock键位给映射到原来的Esc键上面去。很舒服。这样就不用担心会误触了，而且兼容之前的使用习惯。</p><p>查看caps2esc的<a href="https://gitlab.com/interception/linux/plugins/caps2esc">gitlab</a>官网的时候，我发现这个caps2esc还支持在linux系统下的使用，这让我很是激动。于是打算按照他的这个教程来配置一下我的Linux环境</p><blockquote><p>我主要参考的是gitlab上的教程和上面提到的第三个教程，但是比较懵，现在看来教程的主要目的就是将一个系统服务添加到系统自启动项目中去。所以在教程中会叫你创建一个名为<code>udenmon.yaml</code>的文件和<code>udevmon.service</code>的文件。<code>.yaml</code>是一种脚本语言。<code>.service</code>是一项系统任务。关于** systemctl命令的相关介绍** 可以看这篇关于<a href="https://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html">systemctld的博客</a>.</p><p>后面的本地服务配置比较容易完成, 但是前面部分的程序环境搭建就没那么顺利了。要执行下面三个命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo add-apt-repository ppa:deafmute/interception<br>sudo apt install interception-tools<br>sudo apt install interception-caps2es<br></code></pre></td></tr></table></figure><p>由于caps2esc是依赖于interception的，需要先创建相关的环境，所以在执行第二条命令的时候就出了问题。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Depends</span>: libyaml-cpp0.<span class="hljs-number">6</span> (&gt;= <span class="hljs-number">0</span>.<span class="hljs-number">6</span>.<span class="hljs-number">2</span>) but it is not installable<br></code></pre></td></tr></table></figure><p>这一看就是相关的依赖又没有添加，所以正当我打算添加libyaml-cpp0.6时，发现直接用Ubuntu自带的apt-get安装只能安装0.7的版本，这就十分尴尬了。当然我尝试过能不能用0.7兼容0.6,显然是不能的，这东西它只认0.6的版本。我还得自己去找这个版本的<code>.deb</code>包。<br>前面说过，本文主要用来记录。所以给出<a href="https://pkgs.org/">下载网站</a>.然后执行dpkg命令，后面跟上需要安装的<code>.deb</code>包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo dpkg -i *******.deb <br></code></pre></td></tr></table></figure><p>之后重新执行以上三条命令就能成功安装了。</p></blockquote><p>为什么我觉得恶心心呢，因为在我的环境下(有可能是软件的BUG也有可能是我本身环境的配置问题)，不知道为什么,当我按下Ctrl与其他按键的组合键的时候，会自动执行原来CapsLock本身的功能，并且会输出一个大写的A之类的字符。</p><p>在我尝试排除过很多可能的问题之后，包括重装，重启，甚至直接从源码编译。我放弃了…..</p><h3 id="xmodmap"><a href="#xmodmap" class="headerlink" title="xmodmap"></a>xmodmap</h3><p>这个方法本身是最简单的，它只用到了xmodmap软件，在很多X11基础的图形化界面中甚至这个软件是自带的。如果没有就下载一个，自行搜索下载方法. 那为什么一开始不用这个方法呢，因为我看网上的教程中说这个方法只能把两个按键交换位置，并不能实现CapsLock在短按和长按分别为不同功能的作用。</p><p>但是经过我在无奈之下的研究，了解xmodmap重映射的原理之后，我发现只用xmodmap也能把CapsLock映射到两个按键的功能，具体实现看下一节的介绍。</p><h2 id="原创解决方案"><a href="#原创解决方案" class="headerlink" title="原创解决方案"></a>原创解决方案</h2><p>首先需要理解键盘的工作原理，这一部分网上有很多博客都在介绍，这里推荐这个<a href="https://www.cnblogs.com/yinheyi/p/10146900.html">博客</a>.</p><p>简单理解就是：键盘上每一个按键按下只是给操作系统发送了一个信号(中断)。比如按下’a’,只是给操作系统发送了一个“38号按键”已经按下的信息，具体对此应该做怎样的处理则交给操作系统来处理。在这个情况下，按下“38号按键”对应的是’a’的编码。</p><ul><li>每一个按键的物理序号和位置都是固定的。(‘a’的位置对应38号按键)</li><li>同时每一个想要真实表达的信息编码也是确定的(如’a’就只能对应0x62,’b’就只能对应0x63).</li></ul><p>所以，能够改变的只是上面两者的对应关系。明白这一点后，再来看看组合键是如何实现的。</p><p><img src="/2024/03/14/esc-ctrl/key_map.png" alt="key_map"></p><p>图中显示的shift,control,lock等是按键按下的功能，举个例子：假如说我按下了左边Shift_L对应位置的按键，正常来说是对应一个“使用者想按下shift而不是a”的信号，所以这时候对应的编码是0x32。</p><p>但是，按下Shift_L之后又有什么用呢？注意到一点，我们单独按Shift是没有任何反应的，说明shift功能本身对应的编码0x32就不会产生任何反应。我们都知道shift组合键的一个最简单的功能就是将其他按键对应的其他字符显示出来，或者切换大小写。</p><p>关键来了,<strong>Shift编号0x32本身是不会产生任何效果的，与0x62编号产生一个a不同。但是我们在这个基础上赋予了0x32按键按下不放开的状态一个新的含义</strong>.由于这个含义是后来赋予的，和键盘硬件以及对应的编码都没有关系。所以其实我们也是可以把这个含义赋予到其他按键编码上面。那为什么不这样做呢？原因就是其他案件都有自己本身产生的效果或者反映，而Shift(0x32)等等这一类的按键编码则没有任何自身的反应,这岂不是绝配?!</p><p>明白了这个shift组合键的原理，再来看conttrol和lock键也就自然能明白了。我在理解这一点之后做的事情很简单，首先将键盘上的Esc与CapsLock键对应的键码交换，所以Esc实现的是转换大小写的功能，CapsLock实现的是退出的功能。然后再将control键的这个状态赋予了Esc的键码(0x42).</p><p>前面说道，shift，control这个状态切换的能力是我们使用者有能力赋予给对应的键码的。所以这里赋予给ESC(0x42)也是没有任何问题的。然后就是考虑功能会不会重叠的问题，实际测试过：按下配置好的CapsLock后会首先给出一个Esc功能的键码给操作系统，再切换状态。</p><blockquote><p>在日常使用中，如果想要按下Esc是只需要按一次的。反正我是没见过有哪种情况需要同时按下Esc和其他的按键。然后进入Control状态再退出，control模式只要你不同时按其他的键相当与没按，啥也不做，所以这个情况是没有任何影响的。</p><p>如果只想要按下Ctrl键，那么意味着自动先输入了一个Escape。这个虽然理论上是会有影响，但是在日常使用中可谓是微乎其微。除非你在看视频的全屏状态下想按下Ctrl组合键，这样会使得你退出全屏。还一点就是，对于使用Vim的人来说，这还是一件好事，因为大多数Ctrl的组合键都是在Normal模式下进行的。这相当于可以直接在Insert模式直接按下Ctrl组合键，然后直接跳转到Normal模式执行想要的命令。</p></blockquote><p>总之这样改完是稍微有一点影响的，不过影响微乎其微。用过才知道真的好用。况且，要是真的有那种需要不先按下Esc直接按Ctrl组合键的需求，原来的左右两个Ctrl这不也没动它吗。</p><h3 id="配置xmodmap"><a href="#配置xmodmap" class="headerlink" title="配置xmodmap"></a>配置xmodmap</h3><p>在家目录下创建一个<code>.xmodmap</code>的配置文件。这里附上我的配置供参考</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs abnf">clear lock<br>clear control <br>add Control <span class="hljs-operator">=</span> Control_L<br>add Control <span class="hljs-operator">=</span> Control_R<br>add Control <span class="hljs-operator">=</span> Escape<br>keycode <span class="hljs-number">9</span> <span class="hljs-operator">=</span> Caps_Lock<br>keycode <span class="hljs-number">66</span> <span class="hljs-operator">=</span> Escape<br>keycode <span class="hljs-number">37</span> <span class="hljs-operator">=</span> Control_L<br></code></pre></td></tr></table></figure><p>这是我的配置供大家参考，由于我之前的配置有些混乱所以我直接把lock和contrl全部解除映射之后再重新映射。 <strong>关键是<code>add control</code> 这条命令，它对Control的解读是解读成正常情况下的对应的物理键码编号</strong>,比如control_L对应就是37。关于这个顺序，最好还是把添加control映射的<code>add</code>放在<code>keycode</code>前面，实测这样稳定性高，不然有几率会配置失误。</p><p>可能有同学会在网上看见这样的配置：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">clear <span class="hljs-keyword">Lock</span><br>keysym Caps_Lock = <span class="hljs-keyword">Escape</span><br>keysym <span class="hljs-keyword">Escape</span> = Caps_Lock<br><span class="hljs-keyword">add</span> <span class="hljs-keyword">Lock</span> = Caps_Lock<br></code></pre></td></tr></table></figure><p>一个主要的区别是，被修改的实际键盘上的编号表示方式的不同<code>keycode</code>是用一个不会变的物理编号来表示。<code>keysym</code>是用一个变量来表示,这个等号左边变量名又恰好和等号右边的实际功能名一样。就特别容易混淆，这里推荐还是用<code>keycode</code>表示，清晰又直观。</p><p>配置完成之后就只需要更新配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">xmodmap ~/.xmodmap<br></code></pre></td></tr></table></figure><p>当然一个很自然的想法就是希望能在开机时候自己启动，这样就可以毫无察觉地更改键位了，但是我按照网上的教程尝试过很多方法，包括但不限于:修改.bashrc_profile, 修改.profile,修改crontab周期执行程序,添加脚本到&#x2F;etc&#x2F;init.d&#x2F;,添加system系统服务程序,添加autostart等等。后面三种是我在那照猫画虎，但是前面几种方法我是真没搞懂是哪出的问题。登录后再<code>source ～/.profile</code>都没有问题。我只能是理解成登录后又重新恢复了一下默认配置了。有知道原因的同学麻烦指导指导。</p><p>所以我只能用手动的方式来进行了：创建一个包含开机需要运行一次的脚本<code>start.sh</code>.然后在<code>/usr/local/bin</code>中创建一个软链接<code>startup</code>指向这个脚本。开机后手动执行一次<code>startup</code>，这也是一个暂时的方式了</p><hr><p><em><strong>写在最后</strong></em>：感谢能读到这里，希望没有浪费您宝贵的时间，如果觉得还不错，不要吝啬手中的赞呦~。</p><blockquote><p>其他有关的资料代码放在了<a href="https://github.com/sycamoremoon">sycamoremoon’s github</a>,需要的同学可以自取。</p><p>之后还会有其他的内容上传，希望我的小小努力能够给大家带来帮助</p><p> 这是<a href="sycamoremoon.online">我的网站</a>，内容会随着时间逐渐丰富的..</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>question_records</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unix/Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xv6-lab-Util</title>
    <link href="/2024/03/06/xv6-lab-Util/"/>
    <url>/2024/03/06/xv6-lab-Util/</url>
    
    <content type="html"><![CDATA[<h1 id="xv6-labs-Util-实验记录分析"><a href="#xv6-labs-Util-实验记录分析" class="headerlink" title="xv6-labs-Util 实验记录分析"></a>xv6-labs-Util 实验记录分析</h1><p><em><strong>写在前面</strong></em>:在使用类Unix操作系统中，我对这类操作系统的原理产生了比较浓厚的兴趣，同时这类Unix操作系统也是嵌入式实时操作系统的基础，所以选择跟着<a href="https://pdos.csail.mit.edu/6.828/2020/schedule.html">MIT6.S081</a>这门课程开始学习。<br>    这个类别的文章是我独立通过思考完成labs的记录，便于个人日后复盘以及其他同学参考</p><hr><ul><li><a href="#%E5%90%AF%E5%8A%A8xv6">启动xv6</a></li><li><a href="#sleep">sleep</a></li><li><a href="#ping-pong">ping-pong</a></li><li><a href="#primes">primes</a></li><li><a href="#find">find</a></li><li><a href="#xargs">xargs</a></li></ul><hr><p>相信能够选择学习这门课程的同学应该都对unix环境配置有着一定掌握，根据网络上的教程应该可以配置出这个运行在RISC-V架构下的xv6操作系统,此处附上一篇<a href="https://zhangjk98.xyz/archives/page/5/">博客</a>，能够作为不错的参考。</p><h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p>第一个程序比较简单，直接看代码就可以理解，注意在读取命令行参数时是一个字符串，需要用atoi()库函数转化成整数传递给sleep()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">int</span> <br><span class="hljs-title function_">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> * argv[])</span><br>&#123;<br><span class="hljs-keyword">if</span>(argc &gt; <span class="hljs-number">2</span>)<br>&#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;error of using sleep function&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(argc == <span class="hljs-number">2</span>)<br>&#123;<br>sleep(atoi(argv[<span class="hljs-number">1</span>]));<br>&#125;<br><span class="hljs-keyword">else</span><br>sleep(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ping-pong"><a href="#ping-pong" class="headerlink" title="ping-pong"></a>ping-pong</h2><p>ping-pong这个函数也相对简单，是对进程之间用管道通行的简单实验，涉及到通信的顺序问题，了解wait(),read()的阻塞机制就可以正常完成。源码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc , <span class="hljs-type">const</span> <span class="hljs-type">char</span> * argv[])</span><br>&#123;<br><span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<br><span class="hljs-type">char</span> buf[<span class="hljs-number">1</span>];<br><span class="hljs-type">int</span> pid;<br>pipe(p);<br><span class="hljs-keyword">if</span>((pid = fork())&gt;<span class="hljs-number">0</span>)<br>&#123;<br>wait(<span class="hljs-number">0</span>);<br>read(p[<span class="hljs-number">0</span>],buf,<span class="hljs-keyword">sizeof</span>(buf));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received pong\n&quot;</span>,getpid());<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid ==<span class="hljs-number">0</span>)<br>&#123;<br>write(p[<span class="hljs-number">1</span>],buf,<span class="hljs-keyword">sizeof</span>(buf));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received ping\n&quot;</span>,getpid());<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;fork failed&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h2><p>关于这个实验，我花了不少功夫，一方面是对管道通信的不熟悉，一方面是本身自己的逻辑也不够完善。对得起<strong>hard</strong>这个难度称号了。<br><a href="https://pdos.csail.mit.edu/6.828/2020/labs/util.html">官方给出的提示</a>翻译成<a href="https://xv6.dgs.zone/labs/requirements/lab1.html">中文</a><br>首先给出代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc , <span class="hljs-type">const</span> <span class="hljs-type">char</span> * argv[])</span><br>&#123;<br><span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<br><span class="hljs-type">char</span> buf[<span class="hljs-number">1</span>];<br><span class="hljs-type">int</span> pid;<br>pipe(p);<br><span class="hljs-keyword">if</span>((pid = fork())&gt;<span class="hljs-number">0</span>)<br>&#123;<br>wait(<span class="hljs-number">0</span>);<br>read(p[<span class="hljs-number">0</span>],buf,<span class="hljs-keyword">sizeof</span>(buf));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received pong\n&quot;</span>,getpid());<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid ==<span class="hljs-number">0</span>)<br>&#123;<br>write(p[<span class="hljs-number">1</span>],buf,<span class="hljs-keyword">sizeof</span>(buf));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received ping\n&quot;</span>,getpid());<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;fork failed&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>对于提示中的<strong>For each prime number, you will arrange to create one process that reads from its left neighbor over a pipe and writes to its right neighbor over another pipe</strong> 这句话也没有很明确表示每个prime的process应该是由谁来创建，所以在思考应该如何实现的时候就有了两种方案：</p><ol><li>由子进程来创建新的子进程，最开始的父进程只创建一个进程，后面的执行就交给子进程不断递归实现。所以父进程需要等待所有的子子孙孙进程终止，同时每个子进程也要等待自己创建的子子孙孙进程终止。</li><li>还有一种方案就是将数据的传递交给最后开始的父进程，子进程只负责数据的筛选和打印，完成任务之后就立即终止。这样不断循环直到发生一个终止条件，这样子进程不需要等待任何条件来退出了。</li></ol><p>很显然这两个方案的区别也是经典的递归算法和循环算法的区别，由于我在嵌入式开发这样的环境中基本不使用递归算法，就没有用递归的习惯(其实也不会了..),所以上面的程序用的就是循环来实现的，比较繁琐，远没有递归优美. 同时也出了很多问题，在网上找到的参考全部都是递归实现的，但是秉着递归能实现那么循环也能实现的心态, 一点一点查手册找问题最终真的实现了</p><p>一点小感慨，罗嗦这么久，现在来分析一下这个循环的实现和注意的要点：</p><blockquote><p>在代码的开始给数组初始化赋值就不用多说了，我觉得这个实验最需要注意的点之一就是read()和write()系统调用在管道通信中的使用:</p><ol><li>read()在一般的环境下读取管道都是阻塞的，也就是当有任意的进程打开write文件描述符,并且这个文件描述符和read指向同一个管道。此时read就有可能发生阻塞，一般发生在管道里面没有文件，read在读同时write也没有在往里面写数据的时候。</li><li>read()也有一个最大能读取的字节长度作为参数，不管有没有write文件描述符指向管道，只要管道里面有数据read就能够成功读取，读取的长度小于等于最大字节长度，并返回实际读取到的字节数。但是相反的，要是管道里没有数据，read就不能正常读取，要么阻塞(上文提到),要么发生错误(当没有任何write文件指向管道的时候)，返回-1。</li></ol><p>还有一个要特别注意的点就是关闭不需要用到的文件描述符，在官方指导中是这样说的：<strong>Be careful to close file descriptors that a process doesn’t need, because otherwise your program will run xv6 out of resources before the first process reaches 35</strong>,至于原因是关于文件描述符有一个最大值的limit，不能超过这个limit。</p></blockquote><p>注意到我的代码实现数据传递是用了两个管道来进行数据传递，因为父进程和子进程需要进行双向的通信。虽然管道是可以进行双向通信的，但是为了标识数据的末尾，在一方发送完数据之后就必须关闭管道。这就需要用两个管道分别进行数据从父到子和从子到父的传输。并且如果对一个管道是读操那么作必须关闭对管道write的文件描述符，否则就会导致自己阻塞自己情况。同理，如果对一个管道进行写操作意味着就不能对这个管道read了，需要关闭read文件描述符，目的是为了节省资源也防止阻塞。这一点体现在代码的22,23行和36,37行。</p><p>此外，即使对一个管道只进行的写操作，比如父进程写管道1向子进程通信，在父进程写完之后也要关闭对管道1的write文件描述符，因为此时这个描述符已经属于一个不需要的文件描述符(file descriptor that a process doesn’t need)。同理，对其他不需要的文件描述符也应该关闭。这体现在代码的27,32行和53,58行。之前调试的时候忘记关闭，就导致了一个情况：当数字数目比较小的时候能正常运行，数目变多就发生了各种各样的问题…</p><p>父程序的28行wait()系统调用不是必须的，父进程在从子进程读取的过程会阻塞父进程，一直到58行子进程关闭文件描述符。</p><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>find程序主要参考了xv6系统自己写的ls命令代码，可谓是短小精悍。不多说了，直接上源码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/fs.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/fcntl.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * filename, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * path)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span><br><span class="hljs-type">int</span> fd;<br><span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>] = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//why if I dont initalize this buf, it will go wrong</span><br>   <span class="hljs-type">char</span> * p;<br><br><span class="hljs-comment">//printf(&quot;for the begin the path is %s\nthe buf is %s\n&quot;,path,buf);</span><br><span class="hljs-keyword">if</span> ((fd = open(path,O_RDONLY)) &lt; <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: cannot open current path\n&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>memmove(buf,path,<span class="hljs-built_in">strlen</span>(path));<br>p = buf + <span class="hljs-built_in">strlen</span>(buf);<br><span class="hljs-comment">//printf(&quot;before loop the buf is %s\n&quot;,buf);</span><br><span class="hljs-keyword">while</span>(read(fd,&amp;de,<span class="hljs-keyword">sizeof</span>(de)) == <span class="hljs-keyword">sizeof</span>(de))<br>&#123;<br><span class="hljs-keyword">if</span>(de.inum == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">continue</span>;<br>*p = <span class="hljs-string">&#x27;/&#x27;</span>;<span class="hljs-comment">// p point to where the &#x27;/&#x27; is</span><br>memmove(p+<span class="hljs-number">1</span>,de.name,DIRSIZ);<span class="hljs-comment">//when it copys, the position where p point to is not change</span><br>p[DIRSIZ] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (stat(buf,&amp;st) &lt; <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;find: cannot stat %s \n&quot;</span>,buf);<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">switch</span> (st.type)&#123;<br><span class="hljs-keyword">case</span> T_DEVICE:<br><span class="hljs-keyword">case</span> T_FILE:<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(de.name,filename) == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-type">char</span> ret= <span class="hljs-string">&#x27;\n&#x27;</span>;<br>write(<span class="hljs-number">1</span>,buf,<span class="hljs-built_in">strlen</span>(buf));<br>write(<span class="hljs-number">1</span>,&amp;ret,<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> T_DIR:<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(de.name,<span class="hljs-string">&quot;.&quot;</span>) == <span class="hljs-number">0</span> || <span class="hljs-built_in">strcmp</span>(de.name,<span class="hljs-string">&quot;..&quot;</span>) == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br><span class="hljs-comment">//printf(&quot;before recsive the buf is %s ,filename is %s\n&quot;,buf ,filename);</span><br>find(filename,buf);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">break</span>;<br><br>&#125;<br>&#125;<br>close(fd);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc , <span class="hljs-type">const</span> <span class="hljs-type">char</span> * argv[])</span><br>&#123;<br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span> )<br>&#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;Please input at least one target\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">2</span>;i &lt; argc; i++)<br>&#123;<br>find(argv[i],argv[<span class="hljs-number">1</span>]);<br>&#125;<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>main函数就不多说了，就是一个参数的读取和对find函数的调用。关键是find函数，这其中还包含了不少坑。</p><p>确定基本的思路就是对命令行的参数循环读取，对于每个被查找的文件对象都执行一次find函数。然后find函数再从当前的目录开始对每个目录里面的文件都递归执行相同的步骤。总结就是: <strong>循环对当前目录下的文件遍历，如果发现是普通文件就执行比较文件名的操作;如果是目录文件就再次调用自身</strong>。可以对照ls.c文件查看更容易理解。</p><p>但是其中有这两个细节:</p><ol><li>如果文件名匹配，就需要输出这个文件的完整路径名。一开始我用的是printf标准输出函数，带输出缓冲.C标准规定，对于标准输出函数的缓冲如果是终端等设备，那么默认是 <strong>行缓冲，也就是一行结束冲洗一次缓冲区</strong> ，结束标志也就是我们熟悉的’\n’.直接使用没有任何问题，也能过后面的检测。但是如果将find命令重定向之后再输出，这个时候缓冲策略就变成了 <strong>全缓冲，即要么缓冲区满，要么这个程序执行完毕exit之后才会冲洗缓冲区</strong> 。这也是我在完成后面的xargs命令时发现的一个问题。我找了找这个user&#x2F;user.h文件夹中没有相关的flush函数和改变缓冲策略的函数。所以只能使用不带缓冲的 <strong>系统调用write</strong>了。</li><li>经过实验验证，在递归调用find函数自身的时候，发起调用的函数中的临时变量中的内容会原封不动的复制到被调函数中去。代码的12行定义了一个临时数组，一开始没有进行初始化，导致之前发起调用的函数往buf中填充的数据也给了被调函数。一开始不清楚，后面疯狂插入了好多printf查看变量状态。发现了这个问题<br><img src="/2024/03/06/xv6-lab-Util/find_buf_issue.png" alt="find_buf_issue"><br>别问为什么不用GDB调试，问就是环境没配好，出一些奇怪的BUG。</li></ol><h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><p>开始看见这个xargs的时候非常疑惑，因为我从来没有使用过这个这么强有力的工具，然后又去网上找了xargs的介绍才继续做的。<br>先贴源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/param.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXCMD 9</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXNUM 8</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">xargs</span><span class="hljs-params">( <span class="hljs-type">char</span> * cmd , <span class="hljs-type">char</span> * args)</span><br>&#123;<br><span class="hljs-type">char</span> * vargs[MAXNUM] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">char</span> private_buf[MAXARG] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">char</span> * pchar;<br><span class="hljs-comment">//printf(&quot;before child the args is %s\n&quot;,args);</span><br><span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span> )<span class="hljs-comment">//child process</span><br>&#123;<br><span class="hljs-type">int</span> v = <span class="hljs-number">2</span>;<br>memmove(private_buf,args,MAXARG);<br>vargs[<span class="hljs-number">0</span>] = cmd;<br>vargs[<span class="hljs-number">1</span>] = pchar= private_buf;<br><span class="hljs-keyword">while</span>((pchar = <span class="hljs-built_in">strchr</span>(pchar,<span class="hljs-string">&#x27; &#x27;</span>))!= <span class="hljs-number">0</span> )<br>&#123;<br>*pchar = <span class="hljs-number">0</span>;<br>vargs[v++] = ++pchar;<br>&#125;<br>vargs[v] = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//for(int i=0; i&lt;=v;i++)</span><br><span class="hljs-comment">//printf(&quot;VEC&#x27;s num is %d\nthe vec[%d] is %s\n&quot;,v,i,vargs[i]);</span><br><span class="hljs-comment">//printf(&quot;the cmd is %s\n&quot;,cmd);</span><br>exec(cmd,vargs);<br>&#125;<br><br>wait(<span class="hljs-number">0</span>);<br><br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc , <span class="hljs-type">const</span> <span class="hljs-type">char</span> * argv[])</span><br>&#123;<br><span class="hljs-type">int</span> i;<br><span class="hljs-type">char</span> cmd[MAXCMD] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">char</span> * begin;<br><span class="hljs-type">char</span> argsbuf[MAXARG] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">char</span> streambuf[MAXARG] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">char</span> * p_argv , *p_stream;<br><br><span class="hljs-comment">//printf(&quot;argc is %d\n&quot;,argc);</span><br><span class="hljs-keyword">for</span>(i =<span class="hljs-number">0</span> ;i&lt;argc ;i++)<br>&#123;<br><span class="hljs-comment">//printf(&quot;argv[%d] is %s\n&quot;,i,argv[i]);</span><br>&#125;<br><span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>)<br>&#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;xargs: missing argument\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-built_in">strcpy</span>(cmd,argv[<span class="hljs-number">1</span>]);<br>p_stream = streambuf;<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">2</span>;i&lt;argc;i++)<br>&#123;<br><span class="hljs-built_in">strcpy</span>(p_stream,argv[i]);<br>p_stream = p_stream + <span class="hljs-built_in">strlen</span>(argv[i]);<br>*(p_stream++)= <span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br><br>p_argv = argsbuf;<br><span class="hljs-type">int</span> fnum;<br><span class="hljs-keyword">while</span> ((fnum = read(<span class="hljs-number">0</span>,p_argv,MAXARG)) &gt; <span class="hljs-number">0</span>)<span class="hljs-comment">// read the data from standard input </span><br>&#123;<br>p_argv = p_argv+fnum;<br>&#125;<br><span class="hljs-comment">//printf(&quot;read from pipe is %sthe argsbuf is %s&quot;,p_argv,argsbuf);</span><br>begin = argsbuf;<br><span class="hljs-keyword">do</span>&#123;<br>p_argv = <span class="hljs-built_in">strchr</span>(begin,<span class="hljs-string">&#x27;\n&#x27;</span>);<br><span class="hljs-keyword">if</span>(p_argv != <span class="hljs-number">0</span>)*p_argv = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">strcpy</span>(p_stream,begin);<br>xargs(cmd,streambuf);<br>begin = p_argv+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">while</span>((p_argv = <span class="hljs-built_in">strchr</span>(begin,<span class="hljs-string">&#x27;\n&#x27;</span>)) != <span class="hljs-number">0</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我觉得写这个命令的难点主要在于</p><ol><li><p>对命令行输入和管道数据的读取</p><blockquote><p>数据的读取是在main函数里面完成的,命令行参数读取就不用多说了，一个循环搞定。对管道数据的获取是有一个小坑的,64行的读取文件描述0的内容就是标准输入，但是已经被重定向到之前的一个函数的输出了。不过对于函数xargs自身来说对是否被重定向是一概不知的。所以它 <strong>仍然用处理终端输入的策略来进行数据读取</strong>(行缓冲一次读取一行)，遇到换行符停止，并把换行符留在缓冲区中。所以这里需要循环读取直到读取到EOF。之前只读取一次就出现了漏掉参数的情况。(突然想到大一学c语言的时候，每次scanf之后都需要一个getchar来吃掉最后的换行符，应该是一个道理)</p></blockquote></li><li><p>对获取到的数据进行分隔和组合</p></li></ol><blockquote><p>对数据处理在main和xargs函数中都有了，main中主要负责把整个的数据分成命令字符串、需要传递多次的字符串和只需要传递一次的字符串。传递一次的字符串用’\n’分割，代码的69至77就是处理这个事情，方法显得繁琐，主要是之前没有注意到gets这个库函数。将只传递一次的字符串拼接到传递多次的字符串上,并且和命令字符串一起传递给xargs函数，就算任务完成了。</p><p>对传递过来的一整个字符串，xargs需要对其进行分割，分割的标志就是空格’ ‘，把这一串数据再重构成一个向量。这里实现的方式是先把原始数据拷贝到一个私有数组中，再定义一个指针数组，每个指针都指向一个参数的开始，同时吧原来用于标识分隔的空格改成NULL，这样就相当于有很多独立的字符串了。之后再用exec函数执行(值得注意一点是，参数的第一个指向的字符串是命令的名称，很奇怪对吧).当然以上所用的处理都是在xargs的子程序中执行的了，父程序只需要wait坐享其成就行。</p></blockquote><hr><p>最后附上一张成功通过的截图纪念一下第一次lab<br><img src="/2024/03/06/xv6-lab-Util/grade_test.png" alt="grade_test"></p><hr><p><em><strong>写在最后</strong></em>：感谢能读到这里，希望没有浪费您宝贵的时间，如果觉得还不错，不要吝啬手中的赞呦~。</p><blockquote><p>加以修改后的源代码放在了<a href="https://github.com/sycamoremoon/xv6-labs-2023">sycamoremoon’s github</a>,需要的同学可以自取。</p><p>之后还会有其他的内容上传，希望我的小小努力能够给大家带来帮助</p><p>这是<a href="sycamoremoon.online">我的网站</a>，内容会随着时间逐渐丰富的..</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>xv6-Operating system</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unix/Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初探优雅地解耦代码</title>
    <link href="/2024/02/04/%E4%BC%98%E9%9B%85%E5%9C%B0%E8%A7%A3%E8%80%A6%E4%BB%A3%E7%A0%81/"/>
    <url>/2024/02/04/%E4%BC%98%E9%9B%85%E5%9C%B0%E8%A7%A3%E8%80%A6%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="初探优雅地解耦代码"><a href="#初探优雅地解耦代码" class="headerlink" title="初探优雅地解耦代码"></a>初探优雅地解耦代码</h1><p><em><strong>首先声明：本篇文章的初始版源代码是Clone自GitHub上 <a href="https://github.com/NevermindZZT/cpost">NevermindZZT</a> 大佬，本人只是在这个基础上根据自身理解加以改动和移植。</strong></em></p><p><em><strong>仅用作学习交流，未用作任何商业用途，如有版权问题请联系更改</strong></em></p><hr><ul><li><a href="#%E5%89%8D%E8%A8%80">前言</a></li><li><a href="#CPost">CPost</a><ul><li><a href="#CPost%E4%BD%BF%E7%94%A8">CPost使用</a></li><li><a href="#CPost%E5%AE%9E%E7%8E%B0">CPost实现</a></li><li><a href="#CPost%E7%A7%BB%E6%A4%8D">CPost移植</a></li></ul></li><li><a href="#CEvent">CEvent</a><ul><li><a href="#CEvent%E4%BD%BF%E7%94%A8">CEvent使用</a></li><li><a href="#CEvent%E5%AE%9E%E7%8E%B0">CEvent 实现</a></li><li><a href="#CEvent%E7%A7%BB%E6%A4%8D">CEvent移植</a></li></ul></li></ul><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相信经常和单片机打交道的同学肯定看见过类似下面main函数初始化的画面</p><p><img src="/2024/02/04/%E4%BC%98%E9%9B%85%E5%9C%B0%E8%A7%A3%E8%80%A6%E4%BB%A3%E7%A0%81/%E5%A4%8D%E6%9D%82%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0.jpg" alt="初始化"></p><p>同时，在处理中断函数的时候，经常设置一个标志位来标志状态的改变，控制main函数中某些函数的执行与否。</p><p>用裸机进行单片机开发的过程中，曾经我也认为这是理所应当的，直到我偶然间看见了NevermindZZT写的一篇<a href="https://blog.csdn.net/qq_34245464/article/details/111804661">博客</a>，顿时觉得十分神奇，因为这样优雅利索的代码正是我十分向往的。于是我下载了源代码，根据博客和注释像读一本好书一样慢慢品味。</p><p>接下来我会简要分析一下<strong>CPost</strong>和<strong>CEvent</strong>的使用和实现机制，以及如何将这个使用在新版编译器上的代码，<strong>移植到不完全支持C99</strong>的KEIL C51和KEIL C251 编译器上。</p><h2 id="CPost"><a href="#CPost" class="headerlink" title="CPost"></a>CPost</h2><h3 id="CPost使用"><a href="#CPost使用" class="headerlink" title="CPost使用"></a>CPost使用</h3><p>CPost使用方式比较简单，使用支持C99的编译器几乎可以不对源码做任何修改就能够使用。只需设置好本系统的时钟获取函数，在中断函数中用<code>cpost()</code>函数添加handler抛出任务，然后在主函数中用<code>cpostProcess()</code>处理相关的回调函数即可</p><h3 id="CPost实现"><a href="#CPost实现" class="headerlink" title="CPost实现"></a>CPost实现</h3><p>核心有两点，一是弄懂两个结构体的作用，二是明白如何添加handler</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">size_t</span> startTime;<br>    <span class="hljs-type">size_t</span> delay;<br>    <span class="hljs-type">void</span> (*handler)(<span class="hljs-type">void</span> *);            <span class="hljs-comment">//定义了一个返回值为void的函数指针，接受参数为一个任意类型的指针</span><br>    <span class="hljs-type">void</span> *param;                        <span class="hljs-comment">//定义了一个任意类型的指向函数参数的指针                      </span><br>&#125; CpostHandler;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">void</span> *handler;<br>    <span class="hljs-type">void</span> *param;<br>    <span class="hljs-type">size_t</span> delay;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flag : <span class="hljs-number">2</span>;         <span class="hljs-comment">//结构体位段定义两个位存状态</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> paramDiff: <span class="hljs-number">1</span>;<br>    &#125; attrs;<br>&#125; CpostParam;<br></code></pre></td></tr></table></figure><p><code>CpostParam</code>结构体是用户自己定义的，包括指向函数的指针<code>handler</code>,指向参数的指针<code>param</code>,以及抛出任务后<code>delay</code>多久会被响应。</p><p><code>CpostHandler</code>结构体才是CPost真正抛出的任务，相当于封装了一层，和用户使用分隔开便于维护和更新，<code>handler</code>被强制类型转化成了一个<strong>真正的函数指针</strong>，<code>param</code>依旧是参数指针，剩下两个是用于计算延时时间的，使用频率相对不高。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> cpost(...) \</span><br><span class="hljs-meta">        cpostAddHandler(&amp;((CpostParam)&#123;__VA_ARGS__&#125;))   <span class="hljs-comment">//宏定义传递可变参数</span></span><br><span class="hljs-comment">// #define cpost(arg...) \</span><br><span class="hljs-comment">//         cpostAddHandler(&amp;((CpostParam)&#123;arg&#125;))   //等价用arg代替</span><br></code></pre></td></tr></table></figure><p>在C99标准中引入了新的<code>...</code>和<code>__VA_ARGS__</code>宏定义支持可变参数的传递，同时也用到了<strong>复合字面量</strong>生成一个匿名变量仅用来传递参数初始化。在初始化的过程中也可以用到非常方便的<strong>指定成员初始化</strong>，由于是全局变量，所以没有指定默认是0，相当于默认赋初值了，比如<code>cpost(handler, .delay=5000);</code></p><p>以上全部是C99的新标准，技巧十分丰富。至于<code>cpostAddHandler</code>中的具体实现如何，大家有兴趣可以在 <a href="https://github.com/NevermindZZT/cpost">NevermindZZT</a>的GitHub上自行查看，相对容易理解就不赘述了。</p><h3 id="CPost移植"><a href="#CPost移植" class="headerlink" title="CPost移植"></a>CPost移植</h3><p>C99的新标准让编程变得更加优美简洁，但是如果条件要求只能用C51和C251编译器所支持的ANSI C标准，就不得不对原本简洁的代码做出一些妥协了。</p><p>主要需要更改的还是<code>cpost</code>的宏定义,虽然随着版本更新，以上两款老编译器已经支持<code>__VA_ARGS__</code>宏定义，但是想要做到上面的效果还需要支持<strong>复合字面量</strong>的。无奈之下，只能含泪再定义一个函数，充当那个复合字面量的生成，具体代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//定义了一个参数结构体,全局变量重复使用。</span><br>CpostParam cpostparam;                 <br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> cpost(handler,param,delay,flag,paramdiff) \</span><br><span class="hljs-meta">        cpostAddHandler(cpostparaminit(handler,param,delay,flag,paramdiff)) </span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">*   @brief cpostparam 结构体生成</span><br><span class="hljs-comment">*只支持用地址传递一个参数</span><br><span class="hljs-comment">*/</span><br>CpostParam * <span class="hljs-title function_">cpostparaminit</span><span class="hljs-params">(<span class="hljs-type">void</span> * handler,<span class="hljs-type">void</span> * param,<span class="hljs-type">size_t</span> delay,<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flag,<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> paramDiff)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> i;<br>    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; CPOST_MAX_HANDLER_SIZE; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (cposhHandlers[i].handler == <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            cpostparam.handler = handler;<br>            cpostparam.param = param;<br>            cpostparam.delay = delay;<br>            cpostparam.attrs.flag = flag;<br>            cpostparam.attrs.paramDiff = paramDiff;<br>            <span class="hljs-keyword">return</span> &amp;cpostparam;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说，在函数中定义的<code>cpostparam</code>通过值传递给了<code>cpostAddHandler()</code>函数，最终被销毁。这也导致使用宏定义的时候必须要给出全部参数，并且还要按照固定的顺序:cry:.显得臃肿了很多，但是为了使用也是无奈之举。</p><h2 id="CEvent"><a href="#CEvent" class="headerlink" title="CEvent"></a>CEvent</h2><h3 id="CEvent使用"><a href="#CEvent使用" class="headerlink" title="CEvent使用"></a>CEvent使用</h3><p>CEvent的作用也十分巧妙，核心思想是把事件的导出和事件的执行分离开。这样的机理对于减少代码之间的耦合十分有帮助，添加需要执行的函数只需导出事件，减少执行的函数只需不导出事件即可。</p><blockquote><p>有同学这时候可能要发问了，这样处理和我用一个大的函数比如大的<code>init_all()</code>函数把所有初始化函数全部包括起来有什么区别呢？</p></blockquote><blockquote><p>其实区别是很大的。首先用一个大的 <code>init_all()</code>函数并没有切断主函数和其他模块的联系，需要一个个头文件include所有需要初始化的函数所在的位置，模块中的任何修改都会反映到主函数中函数执行中，这就是耦合。</p><p>其次，在事件执行中，自身根本不知道到底有多少事件需要执行，这完全取决于用户导出的事件数。意思是说：无论有多少函数需要执行，只要导出事件，执行函数就像一台无情的机器全部执行。(当然可以自行添加一些状态表示是否重复执行之类的信息)</p></blockquote><hr><p><em>举个实际例子：</em></p><p>当我需要一个GPIO初始化函数和一个EXTI初始化函数的时候，分别在GPIO和EXTI的源文件中用<code>CEVENT_EXPORT(event——num,func,...)</code>导出事件，然后再在main函数中<code>ceventInit()</code>和<code>ceventPost(event_num)</code>即可完成事件的处理。</p><p><code>event_num</code>是一个标号，用于事件的分类，把需要一起调用、相互之间没有先后关系的事件放在一起。具体数值可由用户设置，更好的方式是定义一个枚举变量，这样对事件的分类更加直观。</p><hr><h3 id="CEvent实现"><a href="#CEvent实现" class="headerlink" title="CEvent实现"></a>CEvent实现</h3><p>CEvent的实现主要是通过一个宏定义:<code>__attribute__((section(x)))</code>,它的详细用法可以参考<a href="https://blog.csdn.net/u012308586/article/details/106251150">博客</a>.简单来说就是把变量、函数在编译的过程中给编译到固定的一个段内(段的名称可以由x设定)，而且数据在段中连续排列。再配合对应的宏定义获取段的初始地址和结束地址，通过运算得到数据的个数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> </span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span> **param;                         <span class="hljs-comment">/**&lt; 参数(包括函数)指向一个数组，数组中存放了指向函数地址的指针和指向参数的指针 */</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> paramNum;               <span class="hljs-comment">/**&lt; 参数数量 */</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> event;                 <span class="hljs-comment">/**&lt; 监听事件 */</span><br>&#125; CEvent;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 导出事件</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param _event 事件</span><br><span class="hljs-comment"> * @param _func 注册函数</span><br><span class="hljs-comment"> * @param ... 参数,参数传递的时候要以地址的形式传递</span><br><span class="hljs-comment"> * @note cEventParam##_event##_func和cEvent##_event##_func是定义的两个变量，一个是存放指针的数组，一个是类型为Cevent的变量</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CEVENT_EXPORT(_event, _func, ...) \</span><br><span class="hljs-meta">        const void *cEventParam##_event##_func[] = &#123;(void *)_func, ##__VA_ARGS__&#125;; \</span><br><span class="hljs-meta">        const CEvent SECTION(<span class="hljs-string">&quot;cEvent&quot;</span>) cEvent##_event##_func = \</span><br><span class="hljs-meta">        &#123; \</span><br><span class="hljs-meta">            .param = cEventParam##_event##_func, \</span><br><span class="hljs-meta">            .paramNum = sizeof(cEventParam##_event##_func) / sizeof(void *), \</span><br><span class="hljs-meta">            .event = _event, \</span><br><span class="hljs-meta">        &#125;</span><br></code></pre></td></tr></table></figure><p>可以得知，事件的导出就是定义了存放在指定的段(cEvent)中的变量，变量中有一个指向数组的指针，该数组又是一个指针数组，里面包含了函数地址，参数地址。多重指针的结构使得参数传递速度很快。剩下的<code>paramNum</code>和<code>event</code>分别是数组中的指针个数和事件标号了。</p><p>导出事件之后，应该获取段的初始地址和CEvent数据个数，否则怎么得知应该从哪里开始执行事件。</p><ul><li><p>简单的方法就是直接获取段的初始地址和数据个数，在需要执行的时候直接从头开始，遍历每一个CEvent校验它的事件号和需要完成的事件号是否相同，如果相同就执行，不同就下一个。这个方法对每一个事件都遍历，效率不是很高，但是优点是不需要额外的内存，而且操作简单。</p></li><li><p>更加高效的方式就是在初始化的时候建立一个索引表，在索引表内将每个CEvent按照事件的编号排序，需要哪一个编号，直接就能通过数组的首地址加偏移量访问到，速度对于大量数据而言较快。下面是实现的源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">size_t</span> maxEvent = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; count; i++)<br>&#123;<br>    <span class="hljs-keyword">if</span> (base[i].event &gt; maxEvent) &#123;<br>        maxEvent = base[i].event;<br>    &#125;<br>&#125;<br>maxEvent += <span class="hljs-number">1</span>;<br>  <br>ceventTable.eventBase = (<span class="hljs-type">size_t</span> **) ceventBuffer;<br><span class="hljs-type">size_t</span> *cur = ceventBuffer + maxEvent;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; maxEvent; i++)<br>&#123;<br>    ceventTable.eventBase[i] = cur;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> j = <span class="hljs-number">0</span>; j &lt; count; j++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (base[j].event == i) &#123;<br>            *cur++ = (<span class="hljs-type">size_t</span>) &amp;base[j];<br>        &#125;<br>    &#125;<br>    *cur++ = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>第一步找出最大的事件标号，得让那个索引表能够得到最远的位置才行嘛。</p><p>第二步就是对CEvent数据的重新排列，将排列好的数据存放在<code>ceventBuffer</code>中。这个<code>ceventBuffer</code>相当于分成了前半部分和后半部分。前半部分就是索引表，每个数据类型都是一个地址，指向后面的部分。后面的部分中存放着在事件导出过程中CEvent数据的实际地址。这样通过两次解引用操作，就能够快速访问CEvent数据了。</p><hr><p><em>同样举个例子：</em></p></li></ul><p>​我定义了两个标号为2的事件和一个标号为3的事件，然后经过初始化排列后，memory中就会变成这样：</p><p>​<img src="/2024/02/04/%E4%BC%98%E9%9B%85%E5%9C%B0%E8%A7%A3%E8%80%A6%E4%BB%A3%E7%A0%81/ceventTable.jpg" alt="CeventTable"></p><p>​其中，0x455是<code>ceventTable.eventBase</code>的地址，地址中存放了<code>ceventBuffer</code>的地址，然后再<code>ceventBuffer</code>中的指针指向关系已经画出。那个0x800、0x807、0x80E就是CEvent的实际地址了。<strong>注意0x807和0x80E之前存在一个0000间隙</strong>，这个间隙是通过上面的函数很巧妙插入的，目的是为了将这个作为一个事件标号的结束，不会在执行事件2的时候把事件3的函数也给执行了。</p><hr><p>剩下的<code>ceventPost(event_num)</code>函数就是执行某一个标号的所有事件了。这个过程比较明了也容易理解，主要是函数指针的使用，此处就不赘述了，可以在<a href="https://github.com/NevermindZZT/cpost">NevermindZZT</a>上下载源码查看。</p><h3 id="CEvent移植"><a href="#CEvent移植" class="headerlink" title="CEvent移植"></a>CEvent移植</h3><p>CEvent的在C51&#x2F;C251编译器上的移植就比较困难了，网络上找遍几乎所有资料都没有，当初我还一度认为不可能。</p><p>首先，最关键的宏定义:<code>__attribute__((section(x)))</code>，在以上两个编译器中不支持，所以问题的核心就是如何用已有的条件替代宏定义:<code>__attribute__((section(x)))</code>。</p><blockquote><p>最初我想到的方法是定义一个最够大的数组来代替段，这样既能保证数据之间是连续的，又能获取数据的长度和首地址。写完还没等我编译我就知道这个方法肯定行不通。因为<code>__attribute__((section(x)))</code>的关键特点就是在编译的过程中就已经让数据刻在内存里面了，而我这样定义一个数组，在程序运行的时候再来写入肯定是不行的，就算能做到也失去了最初降低代码耦合性的目的。</p></blockquote><p>于是我仔细查阅C251的使用手册，发现在使用C251.exe编译器的时候可以加入一些指令，来指导它的编译</p><p><img src="/2024/02/04/%E4%BC%98%E9%9B%85%E5%9C%B0%E8%A7%A3%E8%80%A6%E4%BB%A3%E7%A0%81/directives.jpg" alt="directives"></p><p>可以通过<code>#pragma SYMBOLS</code>类似的预编译语句在源代码中对编译器提出指令。</p><p>别无选择，只能期望这些指令列表中有能实现相关要求的指令了。对于我这种英语一般般的人来说，就算真的有相应的功能，我也不一定能在众多指令中找出我需要的指令。经过反复挣扎，我总算是发现了相应的指令(不然真的得考虑用汇编了:crying_cat_face:)</p><p><img src="/2024/02/04/%E4%BC%98%E9%9B%85%E5%9C%B0%E8%A7%A3%E8%80%A6%E4%BB%A3%E7%A0%81/userclass.jpg" alt="userclass"></p><p>大概意思就是，可以使用类似下面的语句，将变量定义在一个指定的段内</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> userclass (near = app1)</span><br><span class="hljs-type">int</span>    x1;<br><span class="hljs-type">int</span>    x2;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> userclass (near = default)</span><br></code></pre></td></tr></table></figure><p>app1是自己定义的段名称，default是编译器默认的段，查看生成的map文件可以发现，确实做到了在一个特定段内数据连续排列。</p><p><img src="/2024/02/04/%E4%BC%98%E9%9B%85%E5%9C%B0%E8%A7%A3%E8%80%A6%E4%BB%A3%E7%A0%81/stack.jpg" alt="map"></p><p>有了这个编译指令，问题就解决了一大半，剩下的问题下面逐一解决</p><blockquote><ol><li>段的首地址如何获取？C99有专门获取段首地址的宏，但是显然目前所用的编译器不可能支持。</li><li>在不同源文件中定义的段虽然可以命名,但是最后在链接的时候的的最终段名却不同。比如在main.c中定义的叫<code>?ED?APP1?MAIN</code>,在gpio.c中定义的叫<code>?ED?APP1?GPIO</code>,它们之间的顺序却又是链接器随机链接的。</li><li>在<code>CEVENT_EXPORT()</code>的时候，只能有CEvent结构体存入<code>cEvent</code>段，那个存放参数的数组不能一并存入。</li><li>段内数据的个数如何获取？</li></ol></blockquote><ul><li><p>要解决前两个问题，就不得不查阅L251.exe链接器的相关手册了。其实链接器在使用的时候也可以输入相关的指令</p><p><img src="/2024/02/04/%E4%BC%98%E9%9B%85%E5%9C%B0%E8%A7%A3%E8%80%A6%E4%BB%A3%E7%A0%81/link_directives.jpg" alt="link_directives"></p></li></ul><p>​其中正巧又有一条我需要的</p><p><img src="/2024/02/04/%E4%BC%98%E9%9B%85%E5%9C%B0%E8%A7%A3%E8%80%A6%E4%BB%A3%E7%A0%81/segments.jpg" alt="segments"></p><p>找到keil的链接器设置界面，通过这个指令，在<code>User Segments</code>中按照手册的说明配置。段的首地址就可以自己配置，作为一个常量了，<em>问题1解决</em>。按照顺序给出segments的指令，段名也会按照给定的顺序依次排列，所以能够做到<strong>连续</strong>了，<em>问题2解决</em>。</p><ul><li><p>要解决第三个问题就必须给参数数组重新指定内存位置，但这样意味着要把原来的宏定义给拆散，再分别定义，这样异常麻烦。既然对参数数组的存储位置没有要求，那么就把参数数组给扔到外置数据RAM中，加入<code>xdata</code>限定符，再配置<code>xdata</code>的有效范围后。<em>问题3就基本解决了</em>。</p></li><li><p>最后一个问题就是如何确定事件的个数呢？原来的代码的方案是通过宏定义找到段的起始位置和终止位置，然后再除以CEvent结构体的数据长度得到事件的个数。但是目前所用的编译器没有这个宏，也不能这样做了。我想到的方案是<strong>用函数来确定事件的个数</strong>，因为事件的格式是用于初始化函数中，并<strong>不要求在编译的时候确定</strong>，所以这样方案是可行的，代码如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 获取数组中最后连续存放的cevent序号</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-title function_">get_lastcevent</span><span class="hljs-params">(CEvent* event_list)</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;(i&lt;(CEVENT_BUFFER_SIZE/<span class="hljs-number">2</span>));i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(*((*(event_list+i)).param)==<span class="hljs-literal">NULL</span>)<span class="hljs-comment">//param是一个类型为void* 的数组，应该再次取地址获得第一个参数：函数指针</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;                 <span class="hljs-comment">//返回下一个空余位置序号</span><br>&#125;<br></code></pre></td></tr></table></figure><p>只是如果采用这样的方案，就必须确保最后一个的CEvent为空，所以要在最后添加一个空CEvent变量，理论上在哪添加都行，但是我选择在main.c中添加，这样不容易忘记。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> userclass (near=CEVENT)</span><br>CEVENT_EXPORT(<span class="hljs-number">0</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> userclass (near=default)</span><br></code></pre></td></tr></table></figure><hr><p>综上所述，想要在C51&#x2F;C251正常使用CEvent模块，就必须做一些额外的工作了。除了在导出事件的时候应该像上面所示多添加两条编译指令，还应该在L251链接器设置界面配置如下：</p><p><img src="/2024/02/04/%E4%BC%98%E9%9B%85%E5%9C%B0%E8%A7%A3%E8%80%A6%E4%BB%A3%E7%A0%81/link_set.jpg" alt="link_set"></p></li></ul><p><code>xdata</code>可以根据实际情况调整，<code>User Segments</code>中设置好相应的段，段名可以在生成的<code>.map</code>文件中查看，都是有规律的。然后在指定初始地址后按照顺序写在后面即可，注意别忘了最后是一个空的CEvent哦。</p><p>可以在<code>map</code>文件中看到实际的段空间分配内存情况，和预期一样是连续分布的。</p><p><img src="/2024/02/04/%E4%BC%98%E9%9B%85%E5%9C%B0%E8%A7%A3%E8%80%A6%E4%BB%A3%E7%A0%81/final.jpg" alt="final"></p><p><strong>至此CEvent就移植成功了:laughing:</strong></p><hr><p><em><strong>写在最后</strong></em>：感谢能读到这里，希望没有浪费您宝贵的时间，如果觉得还不错，不要吝啬手中的赞呦~。</p><blockquote><p>加以修改后的源代码放在了<a href="https://github.com/sycamoremoon/Classpractice">sycamoremoon’s github</a>,需要的同学可以自取。</p><p>之后还会有其他的内容上传，希望我的小小努力能够给大家带来帮助</p><p>这是<a href="sycamoremoon.online">我的网站</a>，内容会随着时间逐渐丰富的..</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>软件设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言高级编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模拟计算机</title>
    <link href="/2024/01/17/%E6%A8%A1%E6%8B%9F%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    <url>/2024/01/17/%E6%A8%A1%E6%8B%9F%E8%AE%A1%E7%AE%97%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="关于2023全国大学生电子设计大赛综合测评的解析"><a href="#关于2023全国大学生电子设计大赛综合测评的解析" class="headerlink" title="关于2023全国大学生电子设计大赛综合测评的解析"></a>关于2023全国大学生电子设计大赛综合测评的解析</h1><p><em>首先感谢给予<strong>宝贵指导的老师和学长</strong>，没有他们的循循善诱，我可能还是停留在原地徘徊</em></p><p><em>其次，关于写这次博客的动机是在仿真电路和焊接实物的过程中本人遇到了一些问题，想通过博客的形式记录下来供自己和大家参考。顺便弥补一下网络上关于这个题目资源相对较少的遗憾。</em></p><hr><h2 id="首先是对题目的解读"><a href="#首先是对题目的解读" class="headerlink" title="首先是对题目的解读"></a>首先是对题目的解读</h2><p>这里推荐BiliBili上中量大求是电子协会的视频，<a href="https://www.bilibili.com/video/BV1Cu4y1q7U1/?spm_id_from=333.337.search-card.all.click&vd_source=afefae5b8dc3c6db1130aadd8eaadc5f">链接在此</a>,由于该视频已经讲得很详细和通俗易懂，本文直接给出结论供大家进行分析。</p><p><img src="/2024/01/17/%E6%A8%A1%E6%8B%9F%E8%AE%A1%E7%AE%97%E6%9C%BA/%E9%A2%98%E7%9B%AE.png" alt="题目"></p><p>测评的时候会提供<em><strong>两片4运放的LM324和各型号的电阻电容数量不限，以及二极管1N4007数量不限。</strong></em></p><p>相信很多同学和我一样在看见这个题目的时候就感觉十分懵，出题人也考虑到了这一点，所以后面还有作为附录的对题目的提示。</p><p><img src="/2024/01/17/%E6%A8%A1%E6%8B%9F%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%8F%90%E7%A4%BA.png"></p><p>根据提示和相关的高等数学的知识，方程求解的框图可以化简为如下所示。具体推导过程可以在上述的<a href="https://www.bilibili.com/video/BV1Cu4y1q7U1/?spm_id_from=333.337.search-card.all.click&vd_source=afefae5b8dc3c6db1130aadd8eaadc5f">视频</a>中看见。</p><p><img src="/2024/01/17/%E6%A8%A1%E6%8B%9F%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%8C%96%E7%AE%80%E5%90%8E%E7%9A%84%E6%A1%86%E5%9B%BE.png" alt="化简后的框图"></p><p>分析到这里，想要完成题目要求就可以大致分为以下几个模块</p><blockquote><ul><li>制作波形发生器</li><li>制作一个加法电路</li><li>制作两个积分器</li><li>按照合适的顺序、选择合适的电路参数将以上部分连接起来。</li><li>考虑正弦波和三角波的相位，使得三角波和正弦波同频同相（<em>听说这个在实际考察中可有可无</em>）</li></ul></blockquote><h2 id="开始电路仿真"><a href="#开始电路仿真" class="headerlink" title="开始电路仿真"></a>开始电路仿真</h2><p>使用Multisim作为仿真软件如下所示</p><ol><li><p><strong>制作波形发生器</strong></p><blockquote><p>波形发生电路可以分成大致两个思路：</p><ul><li>用文氏桥正弦波发生电路选频发生一个正弦波，之后对正弦波进行迟滞电压比较器的波形变换成方波，然后通过积分电路把方波积分成三角波。*(注：关于这个方法对相位的处理又有两种方法，分别是在正弦波变化成方波时不考虑相位，然后通过全通滤波器移相；还有一种方法是在迟滞电压比较器波形变换的同时将方波的相位移动90度，之后积分再相移90度就回来了，实现的大致思路是：确定比较的临界点分别为正弦波的最大峰值和最小峰值，可以通过调节正反馈反馈电阻的大小改变反馈因子$\beta$,但是还存在一个问题是LM324不是轨到轨的运放，所以即使反馈因子$\beta$相同反馈回来的电压也不同，解决办法就是添加一个偏置电压。<em>反馈电压低是吧，那我朝你那边偏，你即使低我也可以达到我想要的阈值电压，同理如果你反馈回来的电压高，我离你远一点，这样一互补，不就可以达到我想要的阈值电压了</em>)*</li><li>还有就是用一个阻尼振荡器直接发生一个方波，之后对这个方波进行处理，比如滤波、积分的操作。这种方法貌似对相位的处理只有加全通滤波器了。因为我就是用的这种方法，所以会在下面进行详细说明。</li></ul></blockquote></li></ol><ul><li>方波发生部分如下：</li></ul><p><img src="/2024/01/17/%E6%A8%A1%E6%8B%9F%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%96%B9%E6%B3%A2%E5%8F%91%E7%94%9F.png" alt="方波"></p><p>如图所示方波发生部分就是由简单的阻尼振荡器变形而来，频率由C1和R3的大小决定，但是实际操作的时候还是得用滑动变阻器慢慢调。</p><p>主要有两个关键的地方要注意，原因还是这个LM324不是轨到轨的运放导致。一是震荡出来的方波（图中红色的波形）不对称，含有直流分量，二是在图中的正反馈回路中区分了正电压和负电压流经的反馈通路，因为这个<strong>运放的正电压只能到3.5V左右而负电压能够达到-5V左右</strong>，如果不加以区分就会导致震荡出来的方波占空比严重失衡，仿真上不太能看出来，但是实物就非常明显，这会导致后面的波形<strong>全部失真</strong>，所以用二极管加上滑动变阻器调节占空比。最后滤去直流分量的波形如仿真图中绿色波形所示。</p><img src="不对称的方波.jpg" alt="不对称的方波" style="zoom:33%;" /><ul><li><p>三角波和正弦波发生如下</p><img src="三角波和正弦波.png" alt="三角波和正弦波" style="zoom:50%;" /></li></ul><p>众所周知，方波经过积分之后就是三角波，而利用小学二年级学过的傅里叶变化对三角波分解可以得到三角波是由一系列的正弦波叠加而成的。基波的频率为题目要求的600rad也就是大概95.4Hz。由于只有奇数次谐波，所以我们在滤波保留基波时只能把下限截至频率选取在100~300Hz之间，考虑到留有一定裕量和元器件的误差，在计算的时候就先用的200Hz作为近似，再用现有的元器件参数去作近似，应该不会超出这个范围。</p><p>在积分的时候要在电容上方并联上一个大电阻，目的是为了在非理想运放存在输入失调电压和输入失调电流的时候提供一个直流通路，以至于不会使运放输出饱和，这是一个很现实的应用。</p><p>滤波电路采用了二阶的切比雪夫低通滤波器，能过获得在转折频率之外更加陡峭的滚降。如图可见该滤波器的直流增益为单位1，这是一种常用单位增益Sallen-Key的形式。</p><img src="滤波器.png" style="zoom:50%;" /><p> 经过拉氏变换后s&#x3D;j$\omega$,传递函数为<br>$$<br>A(s)&#x3D;\frac{1}{1+\omega_CC_1(R_1+R_2)s+\omega_C^2R_1R_2C_1C_2s^2}\<br>$$<br>$$<br>a_1&#x3D;\omega_CC_1(R_1+R_2)\<br>$$<br>$$<br>b_1&#x3D;\omega_C^2R_1R_2C_1C_2<br>$$<br>计算可以得到<br>$$<br>R_1&#x3D;\frac{a_1C_2-\sqrt{a_1^2C_1^2-4b_1C_1C_2}}{4\pi f_CC_1C_2} \<br>$$<br>$$<br>R_2&#x3D;\frac{a_1C_2+\sqrt{a_1^2C_1^2-4b_1C_1C_2}}{4\pi f_CC_1C_2} \<br>$$<br>$$<br>C_2\geqslant C_1\frac{4b_1}{a_1^2}<br>$$<br>根据上述公式，选取截止频率和C1、C2，注意保证C1和C2的关系要保证满足最后一个$\geqslant$，然后再根据查表得来的a1和b1可以计算出R1和R2，最后只需要将元件按照上图所示连接即可，感兴趣的同学也可以自己推导传递函数和公式。</p><ul><li><p>全通滤波器</p><img src="全通滤波器.png" alt="全通滤波器" style="zoom:50%;" /></li></ul><p>最后全通滤波器的部分比较简单，连好电路后转转滑动变阻器合适即可</p><ol start="2"><li><strong>信号运算处理部分</strong></li></ol><ul><li><p>加法电路</p><p>根据原来的分析结果可以看出：加法器的作用是为了将输入信号与最后的结果相减，由提示信息可知外部输入信号$u_i$应该乘以一个系数$b_0&#x3D;3\times10^4$,再和最后的输出结果$u_o$乘以一个系数$a_0&#x3D;4\times10^4$相加，但是这么大的系数肯定不能直接乘，否则必然饱和。注意到上图中加法器输出后有一个 $\frac{1}{k_1k_2}$了吗？这个意思是可以将结果先衰减之后再进行运算，那么既然要衰减，为什么不直接不乘以这个系数呢:joy:？所以我的方法是将$4\times10^4$作为$k_1k_2$,放在之后的积分电路中作为因数慢慢乘进去。同时为了统一性，输入信号在进入加法器的时候应该先衰减$\frac{3}{4}$,这样之后乘以$4\times 10^4$就相当于乘了一个$3\times10^4$。</p><img src="加法器.png" alt="加法器" style="zoom:50%;" /><p>加法器下面这一堆就是题目中所述的初始条件$u_0&#x3D;1V$</p></li><li><p>积分电路</p><p>对于一个简单的一阶有源积分器来说，它的积分系数就是$\frac{1}{RC}$,由于要积两次，所以我每个积分器给了200的系数，这一环节没有什么难度，只是要注意积分的同时要提供直流通路即并上一个大电阻。</p><img src="积分器.png" alt="积分电路" style="zoom:50%;" /></li></ul><p>同样,开关S2作为题中要求的初始条件$\frac{du_o(0)}{dt}&#x3D;0V&#x2F;s$ </p><ol start="3"><li><p>仿真结果演示</p><p><strong>不能保证我的结论一定正确</strong>，但是经过我仿真和实物焊接的过程中我发现这个结果的输出<strong>不是一个稳态</strong>，输出结果变化如下所示：</p><img src="结果变化.png" alt="结果变化" style="zoom:75%;" /><p>最终波形变成了一个正弦波：</p> <img src="最终结果.png" alt=" 最终结果" style="zoom:50%;" /></li></ol><p>可以发现，最终这个波形的输出是一个变化的过程，变化快慢随着积分电路上并联电阻的大小变化，电阻越大变化越慢，我并联的20M欧电阻都能明显看见，如果只有几百千欧姆那变化就是一瞬间的事情。那么有同学就想问了：如果断路不就相当于电阻无穷大，这样不就是稳态了？这个对于仿真来说是成立的，可以试着把电阻给断路，结果还真的就是稳态，但是实物焊接中,由于有各种各样的现实因素，结果却不是这样，请往下看。</p><h2 id="开始实物焊接"><a href="#开始实物焊接" class="headerlink" title="开始实物焊接"></a>开始实物焊接</h2><p>焊接电路板是个技术活，如何能够节省空间、减少跳线、以及最小化噪声的干扰等等。显然我做得都不好，将就着看看：</p> <img src="正面.jpg" alt="正面" style="zoom:50%;" /><p>运放是双电源供电所以用了两组5V的电源，蓝色的线是引出给示波器用的线，用了两个机械按键用来提供初始条件，还有一堆滑动变阻器。</p><img src="反面.jpg" alt="反面" style="zoom:50%;" /><p>反面更是狼狈不堪，用了很多跳线，导致在焊接的时候经常出现线断掉的情况，搞得人一惊一乍的。然后就是用了一些贴片元件，比如贴片电阻、贴片电容和贴片二极管（为了方便，实际测评的时候是没有的），看具体情况焊接上去耦电容，去掉噪声干扰，一般使用0.1uF的电容接在电源到地之间。</p><ul><li>示波器观察波形</li></ul><p>方波、正弦波、三角波波形发生如下</p><img src="图片1.jpg" alt="方波" style="zoom:50%;" /><img src="图片2.jpg" alt="方波" style="zoom:50%;" /><img src="图片3.jpg" alt="方波" style="zoom:50%;" /><p>当输入为正弦波时，输出结果如下：</p><img src="图片4.png" alt="方波" style="zoom:50%;" /><p>由图可见当给出初始条件后，波形开始衰减，但是实物焊接出来波形衰减很快，大概在1秒钟后就衰减成了下图的正弦波</p><img src="图片5.png" alt="方波" style="zoom:50%;" /><p>我开始觉得十分奇怪，以为是电路搭错了，因为一开始我不清楚这个输出波形不是稳态（在仿真的时候积分器没有并联电阻，所以输出波形看上去没有变化），最后问了老师才知道原因所在。</p><p><strong>但是无论我在积分电路的电容上并联多么大的电阻抑或是直接断路，这个输出波形衰减的速度依旧很快</strong>，至今还是没有找到原因，也不清楚电路实际连接出来到底是不是本来就衰减很快。</p><p>其余的情况分别是无输入和输入为三角波的情况。结果类似，忘记拍照记录了，但是依旧是衰减很快。</p><p><strong>由于网上没有太多参考案例，关于这个结果也拿不准，欢迎讨论</strong></p><hr><p><em><strong>写在最后</strong></em>：感谢能读到这里，希望没有浪费您宝贵的时间，如果觉得还不错，不要吝啬手中的赞呦~。</p><blockquote><p>综合测评题目和电路仿真放在了<a href="https://github.com/sycamoremoon/Classpractice">sycamoremoon’s github</a>,需要的同学可以自取。</p><p>之后还会有其他的内容上传，希望我的小小努力能够给大家带来帮助</p><p>这是<a href="sycamoremoon.online">我的网站</a>，内容会随着时间逐渐丰富的..</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>硬件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电路设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCD1602-driver</title>
    <link href="/2023/12/04/LCD1602/"/>
    <url>/2023/12/04/LCD1602/</url>
    
    <content type="html"><![CDATA[<h1 id="手把手教你写LCD1602驱动代码"><a href="#手把手教你写LCD1602驱动代码" class="headerlink" title="手把手教你写LCD1602驱动代码"></a>手把手教你写LCD1602驱动代码</h1><p><em><strong>写在前面</strong></em>：本文是本人某种意义上写的第一篇blog，如有错误请留言指正。具体内容以官方手册内容为准<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[HD44780's datasheet download](https://www.alldatasheet.com/datasheet-pdf/pdf/63663/HITACHI/HD44780U.html)">[1]</span></a></sup>。 </p><p>首先我们要知道LCD1602屏幕驱动的背后也是有一块类似显卡的芯片<strong>HD44780U</strong>在作为驱动，当然这块上世纪的芯片当然不能和最新的4090相比，它的显存只有可怜的80bytes，但是这对于很多应用场景来说已经够用了，这也是这块芯片能够经久不衰的原因。此处附上<a href="https://www.alldatasheet.com/datasheet-pdf/pdf/63663/HITACHI/HD44780U.html">DataSheet下载网址</a>，现在就让我们正式开始这块芯片的学习吧。</p><p><em><strong>HD44780U</strong></em>以下简称44780</p><hr><h2 id="44780的内部资源"><a href="#44780的内部资源" class="headerlink" title="44780的内部资源"></a>44780的内部资源</h2><p><img src="/2023/12/04/LCD1602/HD44780U_block_diagram.png" alt="HD44780U内部结构"></p><ol><li><p>44780中最重要的就是它的寄存器和存储器了，寄存器分别是指令寄存器IR和数据寄存器DR，存储器又分为DDRAM，CGROM和CGRAM了，下面一一为大家解释他们的含义。</p><ul><li><p>IR寄存器叫指令寄存器，只能通过MCU发出指令才能改变IR，它相当于一个指挥者，指挥着这块芯片的所有行为，信息可以包含屏幕的显示与否，光标的显示与否，还有RAM的地址信息等</p></li><li><p>DR寄存器叫数据寄存器，它负责数据在MCU和44780之间的传递，MCU需要读取或者写入信息到44780的时候才用到。DR自动地完成了数据在DDRAM和CGRAM中的传输，意思是我们如果想要往DDRAM或者CGRAM中写入或者读取数据，只需要访问或者修改DR即可。我们一般能够使用44780自带的字库就已经够了，所以只需要往DDRAM中写入数据，除非需要自己往44780中写入数据或者读取状态信息。</p></li><li><p>DDRAM全称叫Display Data RAM，顾名思义它的作用是实际显示字符。所有在DDRAM中的8-bit character codes 都会以对应character 显示出来。它是是一个80 x 8bit的RAM，所以最多能够显示80个字符，但是实际上不能显示如此之多，需要外部的硬件驱动扩展，这点我们之后再讨论。</p></li><li><p>对应的CGROM全称叫Character Generator ROM。CGROM中每一个8位地址都确定了对应的5 x 8 bit 或者 5 x 10 bit 数据，此外ROM为只读存储器，它在出厂时就已经确定，一共有208个5 x 8 bit 的数据和32个5 x 10 bit的数据，用户不能更改一般我们买到的都是欧版和日版。</p></li><li><p>用户可以更改的时CGRAM，CGRAM实际上是有16个5 x 8 bit 的物理存储单元，和CGROM合计256个单元。但是我们只能使用其中的8个物理存储单元因为对于CGRAM的地址来说低字节的第三位是无效位，详细分析请看<em>“在CGRAM中自定义数据”</em>。</p><p>此处附上欧版CGRAM和CGROM的字库</p><p><img src="/2023/12/04/LCD1602/characters.png" alt="character"></p></li></ul></li><li><p>44780中还有两个重要的内部结构分别是BF和AC，尤其AC是芯片运行至关重要的结构。</p><ul><li>BF叫Busy Flag 是44780的忙信号，它在不忙的时候是0，在忙的时候是1。那什么时候忙什么时候不忙呢：读者有没有记得在之前说过DR寄存器负责数据的传输，这个过程是芯片内部自动执行，这个过程是MCU不可控制的，所以需要一个标志来表示结束信号。此外，根据芯片手册，当芯片处于忙状态时是不会接受下一条指令的，甚至如果这个时候再发送指令到IR，芯片不仅不会接受而且会花上成倍的时间去调整，可谓是得不偿失，所以大家在写指令之前一定要先确认44780处于空闲状态。</li><li>AC叫Address Counter，它记录着DDRAM的地址和CGRAM的地址信息，AC初始是0，当读取DDRAM和CGRAM的数据后，AC根据后面介绍的设定自动加一或者减一。AC的改变可以用指令进行，当执行写地址指令后，AC的地址会变成在IR地址中包含的地址信息。这一点在刚开始引起了我的不解，现在仍旧想到有两种方式解释：一是AC中有两个独立的寄存器分别存储DDRAM和CDRAM的地址信息，二是AC通过一种译码方式确定了地址是属于DDRAM还是CGRAM，毕竟DDRAM是7位地址，CCGRAM是六位地址。总之无论是哪种方式，外部看来结果都一样，在操作之前都要通过写地址指令来确定位置。</li></ul></li></ol><hr><h2 id="44780的常规指令操作"><a href="#44780的常规指令操作" class="headerlink" title="44780的常规指令操作"></a>44780的常规指令操作</h2><p>Let’s take a quick look of these instructions,读者有可能和我刚开始一样云里雾里，但是没关系我会解释的。</p><p><img src="/2023/12/04/LCD1602/instruction.png" alt="instructions"></p><p>这些指令可以被分成4类，分别是写命令，写数据，读命令，读数据</p><ol><li>我们先来看看写命令和写数据，他们都是属于往44780中写的范畴，一个是往IR中写一个是往DR中写，要完整无误地进行操作，首先还是得看看44780的写操作时序</li></ol><p>​<img src="/2023/12/04/LCD1602/write.png" alt="Write"></p><p>​由图中可以看出，在改变RS、RW状态后，需要一个短暂的t<sub>AS</sub>来建立地址，手册中给的是40ns，但是12MHz单片机最短延迟时间是1us，所以就按照1us来处理。为了方便，<strong>因为所有的操作延迟时间都低于1us，所以就按照1us来延迟</strong>，这样我们得到了第一个延迟时间点，接下来给出使能信号enable，图中显示enable分别有一个rise time和 fall time，以及高电平保持时间不小于PW<sub>EH</sub>,为了保险起见此处再次延时1us，然后将数据送入总线BUS，此时enable还是保持有效状态，数据也有一个最短建立时间t<sub>DSW</sub>,所以再次延时1us，注意此时的延时1us并不是代表1us后数据就已经能够发挥作用，而是代表这个时候才能被44780所读取，所以在1us后再改变的话，44780读到的数据是改变之后的那一个。真正能把数据锁存住 的信号是enable的下降沿，当enable的下降沿到来时这个指令周期内BUS上的数据如何变化都和44780无关了。刚学的时候，很容易混淆<strong>操作延迟时间</strong>和<strong>指令延时时间</strong>。操作延迟时间很短，大多在ns级别，而指令延迟时间却在us级别，需要在所有的引脚电平变化完成后再额外指令操作延时，这一点在大多数教程中是没有明确指出的。</p><blockquote><p><strong>写指令</strong>代码示例如下</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">LCD1602_COMMAND</span><span class="hljs-params">(uchar cmd)</span><br>&#123;<br> <span class="hljs-keyword">while</span>(Check_Busy());<br> LCD_RS=<span class="hljs-number">0</span>;<br> LCD_RW=<span class="hljs-number">0</span>;<br> _nop_();<span class="hljs-comment">//Address set-up time</span><br> LCD_EN=<span class="hljs-number">1</span>;<br> _nop_();<br> BUS=cmd;<br> BUS=cmd;<br> _nop_();<span class="hljs-comment">//Data set-up time</span><br> LCD_EN=<span class="hljs-number">0</span>;<br> BUS = <span class="hljs-number">0</span>; <span class="hljs-comment">//当enable下降沿到来时，数据已经被所存住，所以这个时候改变也不会影响</span><br> Delay_us(<span class="hljs-number">500</span>);<span class="hljs-comment">//instruction implement time</span><br>&#125;<br></code></pre></td></tr></table></figure><p>读指令类似，只需要将RS变成1即可</p><ol start="2"><li>接下来就是读命令和读指令操作了，依旧，我们先来看看读操作的时序图</li></ol><p><img src="/2023/12/04/LCD1602/read.png" alt="Read"></p><p>由于读操作确实不太常用，而且编程思想和写操作类似，所以在次就简单描述。在配置完RS和RW状态后，仍然需要一段延时来建立地址，之后就是使能信号的置一，与写操作不同的是：此处使能信号之后的延时并不是可选的了，而是必须的。因为需要等待t<sub>DDR</sub>的Data delay time之后才能读取到有效的数据，所以此处<strong>必须</strong>延时1us。由于延时了1us，所以PW<sub>EH</sub>也顺利保持，之后只需要直接置enable为0即可。</p><blockquote><p><strong>读数据</strong>的示例如下</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">uchar <span class="hljs-title function_">Read_Data</span><span class="hljs-params">()</span><br>&#123;<br> uchar data_result;<br> <span class="hljs-keyword">while</span>(Check_Busy());<br> LCD_RS=<span class="hljs-number">1</span>;<br> LCD_RW=<span class="hljs-number">1</span>;<br> BUS=<span class="hljs-number">0xff</span>;<span class="hljs-comment">//读取数据之前要先置一</span><br> _nop_();<span class="hljs-comment">//Address set-up time</span><br> LCD_EN=<span class="hljs-number">1</span>;<br> _nop_();<span class="hljs-comment">//Data delay time，</span><br> data_result = BUS;<br> LCD_EN=<span class="hljs-number">0</span>;<br> <span class="hljs-keyword">return</span> data_result;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>读指令</strong>的示例如下</p><p><em><strong>值得注意的是读指令不需要检查忙信号</strong></em>，因为读指令比较特殊，在BF为1的时候也能执行，否则怎么知道BF到底为多少？哈哈哈。另一方面来说Check busy函数本身就调用了读指令函数，这会导致递归调用而且没有终止条件，这个错误是致命的。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"> uchar <span class="hljs-title function_">Read_Busyflag_and_AD</span><span class="hljs-params">()</span><br>&#123;<br> uchar BF_AD_result;<span class="hljs-comment">//读指令不需要checkbusy</span><br> LCD_RS=<span class="hljs-number">0</span>;<br> LCD_RW=<span class="hljs-number">1</span>;<br> BUS=<span class="hljs-number">0xff</span>;<br> _nop_();<span class="hljs-comment">//Address set-up time</span><br> LCD_EN=<span class="hljs-number">1</span>;<br> _nop_();<span class="hljs-comment">//Data delay time</span><br> BF_AD_result = BUS;<br> LCD_EN=<span class="hljs-number">0</span>;<br> <span class="hljs-keyword">return</span> BF_AD_result;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>读指令返回的结果有两部分，一部分是BF的状态，一部分是AC的当前值，也就是执行完上一条指令之后的值。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">bit <span class="hljs-title function_">Check_Busy</span><span class="hljs-params">()</span><br>&#123;<br> bit result;<br> result = (bit)(Read_Busyflag_and_AD()&amp;<span class="hljs-number">0x80</span>);<br> <span class="hljs-keyword">return</span> result;<span class="hljs-comment">//BF=1,the next instruction will not be accepted.</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><p>有了最基础的4个指令之后，就可以开始写更详细的上层功能实现了，由于这一部分网络上资源较多，所以为了不占用太多篇幅，我就挑选一个来详细说明。今天是12月4号，那就挑选第四个吧，我们看第四个：Cursor or display shift</p><p>指令的前两位代表RS和RW，由于是写指令所以都为0，接下来3位的也全部是0，直到DB4才出现从高位到低位的首个1，细心的同学可能已经发现，44780正是通过这种判断首个高位出现的位置的方式来判断到底这个指令属于哪一个类别。DB3是选择移动的是cursor还是display，如果为1，则每执行一次这个命令，背景整个移动一次，如果为0则背景不动，光标移动。注意一点：<strong>光标移动没有改变DDRAM中的数据</strong>，实际上光标移动的本质就是AC发生了变化，没有写数据的指令，DDRAM当然不会变了。</p></li></ol><hr><h2 id="在CGRAM中自定义数据"><a href="#在CGRAM中自定义数据" class="headerlink" title="在CGRAM中自定义数据"></a>在CGRAM中自定义数据</h2><p><em>这部分内容属于了解即可，如果不是为了特殊需求，CGROM中的字库完全足够使用</em></p><ol><li>44780在上电之后需要初始化，而初始化所需要执行的指令除了设置光标，清屏等个性化操作之外，有一条十分重要的指令，在instructions图中有说到，那就是Function set指令，该指令必须放在所有指令之前执行，并且执行一次后不能修改。我们先来看看这条指令的详细说明</li></ol><p><img src="/2023/12/04/LCD1602/function_set.png" alt="function set"></p><p>该指令DL选择数据位长度，可以为4位或者8位，一般都是8位，除非IO口不够或者MCU是4位的。</p><p>N位选择屏幕显示的模式：可以为一行显示和两行显示，正常来说都是两行。</p><p>F位选择显示在屏幕上的字体格式，有5 x 8 bit和5 x 10 bit，选择好后这个44780芯片的工作就按照选择的模式进行了</p><ol start="2"><li>我们之前说到，CGRAM只有8个编码的位置能够写自定义数据，那么如何找到这8个位置呢？仍然以5 x 8 bit为例，5 x 10 bit类似。</li></ol><p><img src="/2023/12/04/LCD1602/custom_data.png" alt="custom data"></p><p>​我们想要自定义数据，本质上就是要在CGRAM中写入数据对应的信息，而CGRAM根据characters图片可知是在地址编码的前16位(00000000-00001111)，但是根据上图可知第3位为无效位<strong>‘*’</strong>，所以实际上只有8个逻辑地址能够让用户自己写入数据，在写入之前，需要先设定想写入的位置。比如1号(00000001)位置，那么就需要将AC的地址设置为CGRAM，然后往对应的CGRAM地址写入8位的数据，但其中仅低5位有效。每一个逻辑地址对应的8个CGRAM地址都需要写入一个8位的数据，所以总共写8次，对应到这个情况就是往(001000-001111)每个位置都写一次。数据为1对应的像素亮，为0对应的像素灭。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// store the chars into the CGRAM  </span><br>Set_CGRAM_Address(<span class="hljs-number">0x40</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">8</span>; i++) Write_Data(cc1[i]);<br></code></pre></td></tr></table></figure><p>由于第三位无效，所以在引用0号位置的时候，可以往DDRAM中写入0x00或者0x80，都会显示同一个字符。</p><p>5 x 10 bit 的自定义数据写入和8 bit类似，读者可以根据下图自行写入</p><p><img src="/2023/12/04/LCD1602/custom_10bit.png" alt="10bit custom"></p><p>虽然这个模式不常用，但是读者如果在写入时要注意characters code 的无效位为0，3位，characters pattern的后5个字节也无关。</p><hr><h2 id="使用时的注意事项"><a href="#使用时的注意事项" class="headerlink" title="使用时的注意事项"></a>使用时的注意事项</h2><ul><li>要在合适的工作电压下使用，这样才能保证44780上电后的初始化正常执行。如果电压不稳定，导致自动初始化没有正常完成，此时44780工作会发生异常。解决方法是手动多次初始化( function set)</li></ul><hr><p><em><strong>写在最后</strong></em>：感谢能读到这里，希望没有浪费您宝贵的时间，如果觉得还不错，不要吝啬手中的赞呦~。</p><blockquote><p>LCD1602的驱动代码放在了<a href="https://github.com/sycamoremoon">sycamoremoon’s github</a>,需要的同学可以自取。</p><p>之后还会有其他的内容上传，希望我的小小努力能够给大家带来帮助</p><p> 这是<a href="sycamoremoon.online">我的网站</a>，内容会随着时间逐渐丰富的..</p></blockquote><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.alldatasheet.com/datasheet-pdf/pdf/63663/HITACHI/HD44780U.html">HD44780’s datasheet download</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>硬件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>外设驱动开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello_world</title>
    <link href="/2023/12/03/Hello-world/"/>
    <url>/2023/12/03/Hello-world/</url>
    
    <content type="html"><![CDATA[<img src="/2023/12/03/Hello-world/Hello_World.jpg" class="" title="this is my first blog"><p>Welcome to my blog ! This is my very first post. I want to share you something I like.</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
