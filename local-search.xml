<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>模拟计算机</title>
    <link href="/2024/01/17/%E6%A8%A1%E6%8B%9F%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    <url>/2024/01/17/%E6%A8%A1%E6%8B%9F%E8%AE%A1%E7%AE%97%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="关于2023全国大学生电子设计大赛综合测评的解析"><a href="#关于2023全国大学生电子设计大赛综合测评的解析" class="headerlink" title="关于2023全国大学生电子设计大赛综合测评的解析"></a>关于2023全国大学生电子设计大赛综合测评的解析</h1><p><em>首先感谢给予<strong>宝贵指导的老师和学长</strong>，没有他们的循循善诱，我可能还是停留在原地徘徊</em></p><p><em>其次，关于写这次博客的动机是在仿真电路和焊接实物的过程中本人遇到了一些问题，想通过博客的形式记录下来供自己和大家参考。顺便弥补一下网络上关于这个题目资源相对较少的遗憾。</em></p><hr><h2 id="首先是对题目的解读"><a href="#首先是对题目的解读" class="headerlink" title="首先是对题目的解读"></a>首先是对题目的解读</h2><p>这里推荐BiliBili上中量大求是电子协会的视频，<a href="https://www.bilibili.com/video/BV1Cu4y1q7U1/?spm_id_from=333.337.search-card.all.click&vd_source=afefae5b8dc3c6db1130aadd8eaadc5f">链接在此</a>,由于该视频已经讲得很详细和通俗易懂，本文直接给出结论供大家进行分析。</p><p><img src="/2024/01/17/%E6%A8%A1%E6%8B%9F%E8%AE%A1%E7%AE%97%E6%9C%BA/%E9%A2%98%E7%9B%AE.png" alt="题目"></p><p>测评的时候会提供<em><strong>两片4运放的LM324和各型号的电阻电容数量不限，以及二极管1N4007数量不限。</strong></em></p><p>相信很多同学和我一样在看见这个题目的时候就感觉十分懵，出题人也考虑到了这一点，所以后面还有作为附录的对题目的提示。</p><p><img src="/2024/01/17/%E6%A8%A1%E6%8B%9F%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%8F%90%E7%A4%BA.png"></p><p>根据提示和相关的高等数学的知识，方程求解的框图可以化简为如下所示。具体推导过程可以在上述的<a href="https://www.bilibili.com/video/BV1Cu4y1q7U1/?spm_id_from=333.337.search-card.all.click&vd_source=afefae5b8dc3c6db1130aadd8eaadc5f">视频</a>中看见。</p><p><img src="/2024/01/17/%E6%A8%A1%E6%8B%9F%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%8C%96%E7%AE%80%E5%90%8E%E7%9A%84%E6%A1%86%E5%9B%BE.png" alt="化简后的框图"></p><p>分析到这里，想要完成题目要求就可以大致分为以下几个模块</p><blockquote><ul><li>制作波形发生器</li><li>制作一个加法电路</li><li>制作两个积分器</li><li>按照合适的顺序、选择合适的电路参数将以上部分连接起来。</li><li>考虑正弦波和三角波的相位，使得三角波和正弦波同频同相（<em>听说这个在实际考察中可有可无</em>）</li></ul></blockquote><h2 id="开始电路仿真"><a href="#开始电路仿真" class="headerlink" title="开始电路仿真"></a>开始电路仿真</h2><p>使用Multisim作为仿真软件如下所示</p><ol><li><p><strong>制作波形发生器</strong></p><blockquote><p>波形发生电路可以分成大致两个思路：</p><ul><li>用文氏桥正弦波发生电路选频发生一个正弦波，之后对正弦波进行迟滞电压比较器的波形变换成方波，然后通过积分电路把方波积分成三角波。**(注：关于这个方法对相位的处理又有两种方法，分别是在正弦波变化成方波时不考虑相位，然后通过全通滤波器移相；还有一种方法是在迟滞电压比较器波形变换的同时将方波的相位移动90度，之后积分再相移90度就回来了，实现的大致思路是：确定比较的临界点分别为正弦波的最大峰值和最小峰值，可以通过调节正反馈反馈电阻的大小改变反馈因子$\beta$,但是还存在一个问题是LM324不是轨到轨的运放，所以即使反馈因子$\beta$相同反馈回来的电压也不同，解决办法就是添加一个偏置电压。<em>反馈电压低是吧，那我朝你那边偏，你即使低我也可以达到我想要的阈值电压，同理如果你反馈回来的电压高，我离你远一点，这样一互补，不就可以达到我想要的阈值电压了</em>)**</li><li>还有就是用一个阻尼振荡器直接发生一个正弦波，之后对这个方波进行处理，比如滤波、积分的操作。这种方法貌似对相位的处理只有加全通滤波器了。因为我就是用的这种方法，所以会在下面进行详细说明。</li></ul></blockquote></li></ol><ul><li>方波发生部分如下：</li></ul><p><img src="/2024/01/17/%E6%A8%A1%E6%8B%9F%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%96%B9%E6%B3%A2%E5%8F%91%E7%94%9F.png" alt="方波"></p><p>如图所示方波发生部分就是由简单的阻尼振荡器变形而来，频率由C1和R3的大小决定，但是实际操作的时候还是得用滑动变阻器慢慢调。</p><p>主要有两个关键的地方要注意，原因还是这个LM324不是轨到轨的运放导致。一是震荡出来的方波（图中红色的波形）不对称，含有直流分量，二是在图中的正反馈回路中区分了正电压和负电压流经的反馈通路，因为这个<strong>运放的正电压只能到3.5V左右而负电压能够达到-5V左右</strong>，如果不加以区分就会导致震荡出来的方波占空比严重失衡，仿真上不太能看出来，但是实物就非常明显，这会导致后面的波形<strong>全部失真</strong>，所以用二极管加上滑动变阻器调节占空比。最后滤去直流分量的波形如仿真图中绿色波形所示。</p><img src="不对称的方波.jpg" alt="不对称的方波" style="zoom:33%;" /><ul><li><p>三角波和正弦波发生如下</p><img src="三角波和正弦波.png" alt="三角波和正弦波" style="zoom:50%;" /></li></ul><p>众所周知，方波经过积分之后就是三角波，而利用小学二年级学过的傅里叶变化对三角波分解可以得到三角波是由一系列的正弦波叠加而成的。基波的频率为题目要求的600rad也就是大概95.4Hz。由于只有奇数次谐波，所以我们在滤波保留基波时只能把下限截至频率选取在100~300Hz之间，考虑到留有一定裕量和元器件的误差，在计算的时候就先用的200Hz作为近似，再用现有的元器件参数去作近似，应该不会超出这个范围。</p><p>在积分的时候要在电容上方并联上一个大电阻，目的是为了在非理想运放存在输入失调电压和输入失调电流的时候提供一个直流通路，以至于不会使运放输出饱和，这是一个很现实的应用。</p><p>滤波电路采用了二阶的切比雪夫低通滤波器，能过获得在转折频率之外更加陡峭的滚降。如图可见该滤波器的直流增益为单位1，这是一种常用单位增益Sallen-Key的形式。</p><img src="滤波器.png" style="zoom:50%;" /><p> 经过拉氏变换后s&#x3D;j$\omega$,传递函数为<br>$$<br>A(s)&#x3D;\frac{1}{1+\omega_CC_1(R_1+R_2)s+\omega_C^2R_1R_2C_1C_2s^2}\<br>$$<br>$$<br>a_1&#x3D;\omega_CC_1(R_1+R_2)\<br>$$<br>$$<br>b_1&#x3D;\omega_C^2R_1R_2C_1C_2<br>$$<br>计算可以得到<br>$$<br>R_1&#x3D;\frac{a_1C_2-\sqrt{a_1^2C_1^2-4b_1C_1C_2}}{4\pi f_CC_1C_2} \<br>$$<br>$$<br>R_2&#x3D;\frac{a_1C_2+\sqrt{a_1^2C_1^2-4b_1C_1C_2}}{4\pi f_CC_1C_2} \<br>$$<br>$$<br>C_2\geqslant C_1\frac{4b_1}{a_1^2}<br>$$<br>根据上述公式，选取截止频率和C1、C2，注意保证C1和C2的关系要保证满足最后一个$\geqslant$，然后再根据查表得来的a1和b1可以计算出R1和R2，最后只需要将元件按照上图所示连接即可，感兴趣的同学也可以自己推导传递函数和公式。</p><ul><li><p>全通滤波器</p><img src="全通滤波器.png" alt="全通滤波器" style="zoom:50%;" /></li></ul><p>最后全通滤波器的部分比较简单，连好电路后转转滑动变阻器合适即可</p><ol start="2"><li><strong>信号运算处理部分</strong></li></ol><ul><li><p>加法电路</p><p>根据原来的分析结果可以看出：加法器的作用是为了将输入信号与最后的结果相减，由提示信息可知外部输入信号$u_i$应该乘以一个系数$b_0&#x3D;3\times10^4$,再和最后的输出结果$u_o$乘以一个系数$a_0&#x3D;4\times10^4$相加，但是这么大的系数肯定不能直接乘，否则必然饱和。注意到上图中加法器输出后有一个 $\frac{1}{k_1k_2}$了吗？这个意思是可以将结果先衰减之后再进行运算，那么既然要衰减，为什么不直接不乘以这个系数呢:joy:？所以我的方法是将$4\times10^4$作为$k_1k_2$,放在之后的积分电路中作为因数慢慢乘进去。同时为了统一性，输入信号在进入加法器的时候应该先衰减$\frac{3}{4}$,这样之后乘以$4\times 10^4$就相当于乘了一个$3\times10^4$。</p><img src="加法器.png" alt="加法器" style="zoom:50%;" /><p>加法器下面这一堆就是题目中所述的初始条件$u_0&#x3D;1V$</p></li><li><p>积分电路</p><p>对于一个简单的一阶有源积分器来说，它的积分系数就是$\frac{1}{RC}$,由于要积两次，所以我每个积分器给了200的系数，这一环节没有什么难度，只是要注意积分的同时要提供直流通路即并上一个大电阻。</p><img src="积分器.png" alt="积分电路" style="zoom:50%;" /></li></ul><p>同样,开关S2作为题中要求的初始条件$\frac{du_o(0)}{dt}&#x3D;0V&#x2F;s$ </p><ol start="3"><li><p>仿真结果演示</p><p><strong>不能保证我的结论一定正确</strong>，但是经过我仿真和实物焊接的过程中我发现这个结果的输出<strong>不是一个稳态</strong>，输出结果变化如下所示：</p><img src="结果变化.png" alt="结果变化" style="zoom:75%;" /><p>最终波形变成了一个正弦波：</p> <img src="最终结果.png" alt=" 最终结果" style="zoom:50%;" /></li></ol><p>可以发现，最终这个波形的输出是一个变化的过程，变化快慢随着积分电路上并联电阻的大小变化，电阻越大变化越慢，我并联的20M欧电阻都能明显看见，如果只有几百千欧姆那变化就是一瞬间的事情。那么有同学就想问了：如果断路不就相当于电阻无穷大，这样不就是稳态了？这个对于仿真来说是成立的，可以试着把电阻给断路，结果还真的就是稳态，但是实物焊接中,由于有各种各样的现实因素，结果却不是这样，请往下看。</p><h2 id="开始实物焊接"><a href="#开始实物焊接" class="headerlink" title="开始实物焊接"></a>开始实物焊接</h2><p>焊接电路板是个技术活，如何能够节省空间、减少跳线、以及最小化噪声的干扰等等。显然我做得都不好，将就着看看：</p> <img src="正面.jpg" alt="正面" style="zoom:50%;" /><p>运放是双电源供电所以用了两组5V的电源，蓝色的线是引出给示波器用的线，用了两个机械按键用来提供初始条件，还有一堆滑动变阻器。</p><img src="反面.jpg" alt="反面" style="zoom:50%;" /><p>反面更是狼狈不堪，用了很多跳线，导致在焊接的时候经常出现线断掉的情况，搞得人一惊一乍的。然后就是用了一些贴片元件，比如贴片电阻、贴片电容和贴片二极管（为了方便，实际测评的时候是没有的），看具体情况焊接上去耦电容，去掉噪声干扰，一般使用0.1uF的电容接在电源到地之间。</p><ul><li>示波器观察波形</li></ul><p>方波、正弦波、三角波波形发生如下</p><img src="图片1.jpg" alt="方波" style="zoom:50%;" /><img src="图片2.jpg" alt="方波" style="zoom:50%;" /><img src="图片3.jpg" alt="方波" style="zoom:50%;" /><p>当输入为正弦波时，输出结果如下：</p><img src="图片4.png" alt="方波" style="zoom:50%;" /><p>由图可见当给出初始条件后，波形开始衰减，但是实物焊接出来波形衰减很快，大概在1秒钟后就衰减成了下图的正弦波</p><img src="图片5.png" alt="方波" style="zoom:50%;" /><p>我开始觉得十分奇怪，以为是电路搭错了，因为一开始我不清楚这个输出波形不是稳态（在仿真的时候积分器没有并联电阻，所以输出波形看上去没有变化），最后问了老师才知道原因所在。</p><p><strong>但是无论我在积分电路的电容上并联多么大的电阻抑或是直接断路，这个输出波形衰减的速度依旧很快</strong>，至今还是没有找到原因，也不清楚电路实际连接出来到底是不是本来就衰减很快。</p><p>其余的情况分别是无输入和输入为三角波的情况。结果类似，忘记拍照记录了，但是依旧是衰减很快。</p><p><strong>由于网上没有太多参考案例，关于这个结果也拿不准，欢迎讨论</strong></p><hr><p><em><strong>写在最后</strong></em>：感谢能读到这里，希望没有浪费您宝贵的时间，如果觉得还不错，不要吝啬手中的赞呦~。</p><blockquote><p>综合测评题目和电路仿真放在了<a href="https://github.com/sycamoremoon/Classpractice">sycamoremoon’s github</a>,需要的同学可以自取。</p><p>之后还会有其他的内容上传，希望我的小小努力能够给大家带来帮助</p><p>这是<a href="sycamoremoon.online">我的网站</a>，内容会随着时间逐渐丰富的..</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>硬件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电路设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCD1602-driver</title>
    <link href="/2023/12/04/LCD1602/"/>
    <url>/2023/12/04/LCD1602/</url>
    
    <content type="html"><![CDATA[<h1 id="手把手教你写LCD1602驱动代码"><a href="#手把手教你写LCD1602驱动代码" class="headerlink" title="手把手教你写LCD1602驱动代码"></a>手把手教你写LCD1602驱动代码</h1><p><em><strong>写在前面</strong></em>：本文是本人某种意义上写的第一篇blog，如有错误请留言指正。具体内容以官方手册内容为准<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[HD44780's datasheet download](https://www.alldatasheet.com/datasheet-pdf/pdf/63663/HITACHI/HD44780U.html)">[1]</span></a></sup>。 </p><p>首先我们要知道LCD1602屏幕驱动的背后也是有一块类似显卡的芯片<strong>HD44780U</strong>在作为驱动，当然这块上世纪的芯片当然不能和最新的4090相比，它的显存只有可怜的80bytes，但是这对于很多应用场景来说已经够用了，这也是这块芯片能够经久不衰的原因。此处附上<a href="https://www.alldatasheet.com/datasheet-pdf/pdf/63663/HITACHI/HD44780U.html">DataSheet下载网址</a>，现在就让我们正式开始这块芯片的学习吧。</p><p><em><strong>HD44780U</strong></em>以下简称44780</p><hr><h2 id="44780的内部资源"><a href="#44780的内部资源" class="headerlink" title="44780的内部资源"></a>44780的内部资源</h2><p><img src="/2023/12/04/LCD1602/HD44780U_block_diagram.png" alt="HD44780U内部结构"></p><ol><li><p>44780中最重要的就是它的寄存器和存储器了，寄存器分别是指令寄存器IR和数据寄存器DR，存储器又分为DDRAM，CGROM和CGRAM了，下面一一为大家解释他们的含义。</p><ul><li><p>IR寄存器叫指令寄存器，只能通过MCU发出指令才能改变IR，它相当于一个指挥者，指挥着这块芯片的所有行为，信息可以包含屏幕的显示与否，光标的显示与否，还有RAM的地址信息等</p></li><li><p>DR寄存器叫数据寄存器，它负责数据在MCU和44780之间的传递，MCU需要读取或者写入信息到44780的时候才用到。DR自动地完成了数据在DDRAM和CGRAM中的传输，意思是我们如果想要往DDRAM或者CGRAM中写入或者读取数据，只需要访问或者修改DR即可。我们一般能够使用44780自带的字库就已经够了，所以只需要往DDRAM中写入数据，除非需要自己往44780中写入数据或者读取状态信息。</p></li><li><p>DDRAM全称叫Display Data RAM，顾名思义它的作用是实际显示字符。所有在DDRAM中的8-bit character codes 都会以对应character 显示出来。它是是一个80 x 8bit的RAM，所以最多能够显示80个字符，但是实际上不能显示如此之多，需要外部的硬件驱动扩展，这点我们之后再讨论。</p></li><li><p>对应的CGROM全称叫Character Generator ROM。CGROM中每一个8位地址都确定了对应的5 x 8 bit 或者 5 x 10 bit 数据，此外ROM为只读存储器，它在出厂时就已经确定，一共有208个5 x 8 bit 的数据和32个5 x 10 bit的数据，用户不能更改一般我们买到的都是欧版和日版。</p></li><li><p>用户可以更改的时CGRAM，CGRAM实际上是有16个5 x 8 bit 的物理存储单元，和CGROM合计256个单元。但是我们只能使用其中的8个物理存储单元因为对于CGRAM的地址来说低字节的第三位是无效位，详细分析请看<em>“在CGRAM中自定义数据”</em>。</p><p>此处附上欧版CGRAM和CGROM的字库</p><p><img src="/2023/12/04/LCD1602/characters.png" alt="character"></p></li></ul></li><li><p>44780中还有两个重要的内部结构分别是BF和AC，尤其AC是芯片运行至关重要的结构。</p><ul><li>BF叫Busy Flag 是44780的忙信号，它在不忙的时候是0，在忙的时候是1。那什么时候忙什么时候不忙呢：读者有没有记得在之前说过DR寄存器负责数据的传输，这个过程是芯片内部自动执行，这个过程是MCU不可控制的，所以需要一个标志来表示结束信号。此外，根据芯片手册，当芯片处于忙状态时是不会接受下一条指令的，甚至如果这个时候再发送指令到IR，芯片不仅不会接受而且会花上成倍的时间去调整，可谓是得不偿失，所以大家在写指令之前一定要先确认44780处于空闲状态。</li><li>AC叫Address Counter，它记录着DDRAM的地址和CGRAM的地址信息，AC初始是0，当读取DDRAM和CGRAM的数据后，AC根据后面介绍的设定自动加一或者减一。AC的改变可以用指令进行，当执行写地址指令后，AC的地址会变成在IR地址中包含的地址信息。这一点在刚开始引起了我的不解，现在仍旧想到有两种方式解释：一是AC中有两个独立的寄存器分别存储DDRAM和CDRAM的地址信息，二是AC通过一种译码方式确定了地址是属于DDRAM还是CGRAM，毕竟DDRAM是7位地址，CCGRAM是六位地址。总之无论是哪种方式，外部看来结果都一样，在操作之前都要通过写地址指令来确定位置。</li></ul></li></ol><hr><h2 id="44780的常规指令操作"><a href="#44780的常规指令操作" class="headerlink" title="44780的常规指令操作"></a>44780的常规指令操作</h2><p>Let’s take a quick look of these instructions,读者有可能和我刚开始一样云里雾里，但是没关系我会解释的。</p><p><img src="/2023/12/04/LCD1602/instruction.png" alt="instructions"></p><p>这些指令可以被分成4类，分别是写命令，写数据，读命令，读数据</p><ol><li>我们先来看看写命令和写数据，他们都是属于往44780中写的范畴，一个是往IR中写一个是往DR中写，要完整无误地进行操作，首先还是得看看44780的写操作时序</li></ol><p>​<img src="/2023/12/04/LCD1602/write.png" alt="Write"></p><p>​由图中可以看出，在改变RS、RW状态后，需要一个短暂的t<sub>AS</sub>来建立地址，手册中给的是40ns，但是12MHz单片机最短延迟时间是1us，所以就按照1us来处理。为了方便，<strong>因为所有的操作延迟时间都低于1us，所以就按照1us来延迟</strong>，这样我们得到了第一个延迟时间点，接下来给出使能信号enable，图中显示enable分别有一个rise time和 fall time，以及高电平保持时间不小于PW<sub>EH</sub>,为了保险起见此处再次延时1us，然后将数据送入总线BUS，此时enable还是保持有效状态，数据也有一个最短建立时间t<sub>DSW</sub>,所以再次延时1us，注意此时的延时1us并不是代表1us后数据就已经能够发挥作用，而是代表这个时候才能被44780所读取，所以在1us后再改变的话，44780读到的数据是改变之后的那一个。真正能把数据锁存住 的信号是enable的下降沿，当enable的下降沿到来时这个指令周期内BUS上的数据如何变化都和44780无关了。刚学的时候，很容易混淆<strong>操作延迟时间</strong>和<strong>指令延时时间</strong>。操作延迟时间很短，大多在ns级别，而指令延迟时间却在us级别，需要在所有的引脚电平变化完成后再额外指令操作延时，这一点在大多数教程中是没有明确指出的。</p><blockquote><p><strong>写指令</strong>代码示例如下</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">LCD1602_COMMAND</span><span class="hljs-params">(uchar cmd)</span><br>&#123;<br> <span class="hljs-keyword">while</span>(Check_Busy());<br> LCD_RS=<span class="hljs-number">0</span>;<br> LCD_RW=<span class="hljs-number">0</span>;<br> _nop_();<span class="hljs-comment">//Address set-up time</span><br> LCD_EN=<span class="hljs-number">1</span>;<br> _nop_();<br> BUS=cmd;<br> BUS=cmd;<br> _nop_();<span class="hljs-comment">//Data set-up time</span><br> LCD_EN=<span class="hljs-number">0</span>;<br> BUS = <span class="hljs-number">0</span>; <span class="hljs-comment">//当enable下降沿到来时，数据已经被所存住，所以这个时候改变也不会影响</span><br> Delay_us(<span class="hljs-number">500</span>);<span class="hljs-comment">//instruction implement time</span><br>&#125;<br></code></pre></td></tr></table></figure><p>读指令类似，只需要将RS变成1即可</p><ol start="2"><li>接下来就是读命令和读指令操作了，依旧，我们先来看看读操作的时序图</li></ol><p><img src="/2023/12/04/LCD1602/read.png" alt="Read"></p><p>由于读操作确实不太常用，而且编程思想和写操作类似，所以在次就简单描述。在配置完RS和RW状态后，仍然需要一段延时来建立地址，之后就是使能信号的置一，与写操作不同的是：此处使能信号之后的延时并不是可选的了，而是必须的。因为需要等待t<sub>DDR</sub>的Data delay time之后才能读取到有效的数据，所以此处<strong>必须</strong>延时1us。由于延时了1us，所以PW<sub>EH</sub>也顺利保持，之后只需要直接置enable为0即可。</p><blockquote><p><strong>读数据</strong>的示例如下</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">uchar <span class="hljs-title function_">Read_Data</span><span class="hljs-params">()</span><br>&#123;<br> uchar data_result;<br> <span class="hljs-keyword">while</span>(Check_Busy());<br> LCD_RS=<span class="hljs-number">1</span>;<br> LCD_RW=<span class="hljs-number">1</span>;<br> BUS=<span class="hljs-number">0xff</span>;<span class="hljs-comment">//读取数据之前要先置一</span><br> _nop_();<span class="hljs-comment">//Address set-up time</span><br> LCD_EN=<span class="hljs-number">1</span>;<br> _nop_();<span class="hljs-comment">//Data delay time，</span><br> data_result = BUS;<br> LCD_EN=<span class="hljs-number">0</span>;<br> <span class="hljs-keyword">return</span> data_result;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>读指令</strong>的示例如下</p><p><em><strong>值得注意的是读指令不需要检查忙信号</strong></em>，因为读指令比较特殊，在BF为1的时候也能执行，否则怎么知道BF到底为多少？哈哈哈。另一方面来说Check busy函数本身就调用了读指令函数，这会导致递归调用而且没有终止条件，这个错误是致命的。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"> uchar <span class="hljs-title function_">Read_Busyflag_and_AD</span><span class="hljs-params">()</span><br>&#123;<br> uchar BF_AD_result;<span class="hljs-comment">//读指令不需要checkbusy</span><br> LCD_RS=<span class="hljs-number">0</span>;<br> LCD_RW=<span class="hljs-number">1</span>;<br> BUS=<span class="hljs-number">0xff</span>;<br> _nop_();<span class="hljs-comment">//Address set-up time</span><br> LCD_EN=<span class="hljs-number">1</span>;<br> _nop_();<span class="hljs-comment">//Data delay time</span><br> BF_AD_result = BUS;<br> LCD_EN=<span class="hljs-number">0</span>;<br> <span class="hljs-keyword">return</span> BF_AD_result;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>读指令返回的结果有两部分，一部分是BF的状态，一部分是AC的当前值，也就是执行完上一条指令之后的值。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">bit <span class="hljs-title function_">Check_Busy</span><span class="hljs-params">()</span><br>&#123;<br> bit result;<br> result = (bit)(Read_Busyflag_and_AD()&amp;<span class="hljs-number">0x80</span>);<br> <span class="hljs-keyword">return</span> result;<span class="hljs-comment">//BF=1,the next instruction will not be accepted.</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><p>有了最基础的4个指令之后，就可以开始写更详细的上层功能实现了，由于这一部分网络上资源较多，所以为了不占用太多篇幅，我就挑选一个来详细说明。今天是12月4号，那就挑选第四个吧，我们看第四个：Cursor or display shift</p><p>指令的前两位代表RS和RW，由于是写指令所以都为0，接下来3位的也全部是0，直到DB4才出现从高位到低位的首个1，细心的同学可能已经发现，44780正是通过这种判断首个高位出现的位置的方式来判断到底这个指令属于哪一个类别。DB3是选择移动的是cursor还是display，如果为1，则每执行一次这个命令，背景整个移动一次，如果为0则背景不动，光标移动。注意一点：<strong>光标移动没有改变DDRAM中的数据</strong>，实际上光标移动的本质就是AC发生了变化，没有写数据的指令，DDRAM当然不会变了。</p></li></ol><hr><h2 id="在CGRAM中自定义数据"><a href="#在CGRAM中自定义数据" class="headerlink" title="在CGRAM中自定义数据"></a>在CGRAM中自定义数据</h2><p><em>这部分内容属于了解即可，如果不是为了特殊需求，CGROM中的字库完全足够使用</em></p><ol><li>44780在上电之后需要初始化，而初始化所需要执行的指令除了设置光标，清屏等个性化操作之外，有一条十分重要的指令，在instructions图中有说到，那就是Function set指令，该指令必须放在所有指令之前执行，并且执行一次后不能修改。我们先来看看这条指令的详细说明</li></ol><p><img src="/2023/12/04/LCD1602/function_set.png" alt="function set"></p><p>该指令DL选择数据位长度，可以为4位或者8位，一般都是8位，除非IO口不够或者MCU是4位的。</p><p>N位选择屏幕显示的模式：可以为一行显示和两行显示，正常来说都是两行。</p><p>F位选择显示在屏幕上的字体格式，有5 x 8 bit和5 x 10 bit，选择好后这个44780芯片的工作就按照选择的模式进行了</p><ol start="2"><li>我们之前说到，CGRAM只有8个编码的位置能够写自定义数据，那么如何找到这8个位置呢？仍然以5 x 8 bit为例，5 x 10 bit类似。</li></ol><p><img src="/2023/12/04/LCD1602/custom_data.png" alt="custom data"></p><p>​我们想要自定义数据，本质上就是要在CGRAM中写入数据对应的信息，而CGRAM根据characters图片可知是在地址编码的前16位(00000000-00001111)，但是根据上图可知第3位为无效位<strong>‘*’</strong>，所以实际上只有8个逻辑地址能够让用户自己写入数据，在写入之前，需要先设定想写入的位置。比如1号(00000001)位置，那么就需要将AC的地址设置为CGRAM，然后往对应的CGRAM地址写入8位的数据，但其中仅低5位有效。每一个逻辑地址对应的8个CGRAM地址都需要写入一个8位的数据，所以总共写8次，对应到这个情况就是往(001000-001111)每个位置都写一次。数据为1对应的像素亮，为0对应的像素灭。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// store the chars into the CGRAM  </span><br>Set_CGRAM_Address(<span class="hljs-number">0x40</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">8</span>; i++) Write_Data(cc1[i]);<br></code></pre></td></tr></table></figure><p>由于第三位无效，所以在引用0号位置的时候，可以往DDRAM中写入0x00或者0x80，都会显示同一个字符。</p><p>5 x 10 bit 的自定义数据写入和8 bit类似，读者可以根据下图自行写入</p><p><img src="/2023/12/04/LCD1602/custom_10bit.png" alt="10bit custom"></p><p>虽然这个模式不常用，但是读者如果在写入时要注意characters code 的无效位为0，3位，characters pattern的后5个字节也无关。</p><hr><h2 id="使用时的注意事项"><a href="#使用时的注意事项" class="headerlink" title="使用时的注意事项"></a>使用时的注意事项</h2><ul><li>要在合适的工作电压下使用，这样才能保证44780上电后的初始化正常执行。如果电压不稳定，导致自动初始化没有正常完成，此时44780工作会发生异常。解决方法是手动多次初始化( function set)</li></ul><hr><p><em><strong>写在最后</strong></em>：感谢能读到这里，希望没有浪费您宝贵的时间，如果觉得还不错，不要吝啬手中的赞呦~。</p><blockquote><p>LCD1602的驱动代码放在了<a href="https://github.com/sycamoremoon">sycamoremoon’s github</a>,需要的同学可以自取。</p><p>之后还会有其他的内容上传，希望我的小小努力能够给大家带来帮助</p><p> 这是<a href="sycamoremoon.online">我的网站</a>，内容会随着时间逐渐丰富的..</p></blockquote><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.alldatasheet.com/datasheet-pdf/pdf/63663/HITACHI/HD44780U.html">HD44780’s datasheet download</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>硬件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>外设驱动开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello_world</title>
    <link href="/2023/12/03/Hello-world/"/>
    <url>/2023/12/03/Hello-world/</url>
    
    <content type="html"><![CDATA[<img src="/2023/12/03/Hello-world/Hello_World.jpg" class="" title="this is my first blog"><p>Welcome to my blog ! This is my very first post. I want to share you something I like.</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
