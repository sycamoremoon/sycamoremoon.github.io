<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>remap caps to esc/ctrl</title>
    <link href="/2024/03/14/esc-ctrl/"/>
    <url>/2024/03/14/esc-ctrl/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux下将Caps重映射为Esc和Ctrl的一种简便方法"><a href="#Linux下将Caps重映射为Esc和Ctrl的一种简便方法" class="headerlink" title="Linux下将Caps重映射为Esc和Ctrl的一种简便方法"></a>Linux下将Caps重映射为Esc和Ctrl的一种简便方法</h1><p><em><strong>写在前面</strong></em>: 本文是对于Linux操作系统下，对于标准键盘的键盘重映射的记录，同时能够给想对键盘重映射的同学提供一个参考。</p><hr><ul><li><a href="#%E9%97%AE%E9%A2%98%E5%BC%95%E5%85%A5">问题引入</a></li><li><a href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95">常见的解决方法</a></li><li><a href="#%E5%8E%9F%E5%88%9B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95">原创解决方法</a></li></ul><hr><h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><blockquote><p>由于本文更多是为了记录的目的，如果不想听个人的罗嗦，可以直接跳转到<a href="#%E9%85%8D%E7%BD%AExmodmap">快速解决</a>。</p></blockquote><p>在使用Vim的过程中，经常会使用到Esc键来进行Normal模式和Insert模式的切换。但是由于Esc键位距离主键盘的位置太远，所以需要自己进行设置。方式也有很多：有使用快捷键进行代替的，也有用Ctrl+]代替的。但是本人不喜欢这样优柔寡断的解决方案。希望能够在不仅仅使用Vim时做到esc键位的方便，在其他软件的使用中也能做到同样的效果。</p><p>所以，在网络上搜索之后发现了对键盘键位进行重映射的方法。于是才有了这篇文章。</p><h2 id="常见的解决方案"><a href="#常见的解决方案" class="headerlink" title="常见的解决方案"></a>常见的解决方案</h2><p>一开始我在网络上找到了很多种键位重映射的方案</p><ol><li>使用xmodmap，<a href="https://www.cnblogs.com/uestcliming666/p/13196572.html">参考教程网站</a></li><li>使用XCaps软件辅助，<a href="https://www.jianshu.com/p/6fdc0e0fb266">参考教程网站</a></li><li>使用caps2esc软件达到重映射的效果，<a href="https://orxing.top/post/d3c3145e.html#%E5%85%B6%E4%BB%96">参考网站教程</a></li></ol><h3 id="xcaps"><a href="#xcaps" class="headerlink" title="xcaps"></a>xcaps</h3><p>一开始我是使用的第二种方案，对于新手来说比较友好，也不需要配置复杂的环境。按照教程操作之后确实可以达到我想要的效果：Caps短按是Esc，按组合键是Ctrl。但是原来的Ctrl键变成了CapsLosck键，这一时间有些不习惯，会导致经常性按错。但是这不是主要原因我放弃了它，转而寻找一种新的方法。真正的不可接受的是，在我的电脑环境下(Ubuntu 22.04LTS), <strong>经常性的失灵</strong>,这使得我在某个时间正愉快地编辑的时候，突然发现键位变了。想要恢复还得重启电脑(可能有简单的方法我没有找到).</p><h3 id="caps2esc"><a href="#caps2esc" class="headerlink" title="caps2esc"></a>caps2esc</h3><p>在这个时间段里面，我同时也在尝试给我的Windows系统也修改一下键位的映射。不然在系统切换的时候得用两套不同的键盘很难受。于是我在网络上找到了，caps2esc这个软件。也就是上面提到的第三种方案。按照里面的教程我很快就在WIndows中配置好了。而且在Windows中的这个软件稳定性很高，并且能够保留原来的Ctrl功能，把CapsLock键位给映射到原来的Esc键上面去。很舒服。这样就不用担心会误触了，而且兼容之前的使用习惯。</p><p>查看caps2esc的<a href="https://gitlab.com/interception/linux/plugins/caps2esc">gitlab</a>官网的时候，我发现这个caps2esc还支持在linux系统下的使用，这让我很是激动。于是打算按照他的这个教程来配置一下我的Linux环境</p><blockquote><p>我主要参考的是gitlab上的教程和上面提到的第三个教程，但是比较懵，现在看来教程的主要目的就是将一个系统服务添加到系统自启动项目中去。所以在教程中会叫你创建一个名为<code>udenmon.yaml</code>的文件和<code>udevmon.service</code>的文件。<code>.yaml</code>是一种脚本语言。<code>.service</code>是一项系统任务。关于** systemctl命令的相关介绍** 可以看这篇关于<a href="https://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html">systemctld的博客</a>.</p><p>后面的本地服务配置比较容易完成, 但是前面部分的程序环境搭建就没那么顺利了。要执行下面三个命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo add-apt-repository ppa:deafmute/interception<br>sudo apt install interception-tools<br>sudo apt install interception-caps2es<br></code></pre></td></tr></table></figure><p>由于caps2esc是依赖于interception的，需要先创建相关的环境，所以在执行第二条命令的时候就出了问题。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Depends</span>: libyaml-cpp0.<span class="hljs-number">6</span> (&gt;= <span class="hljs-number">0</span>.<span class="hljs-number">6</span>.<span class="hljs-number">2</span>) but it is not installable<br></code></pre></td></tr></table></figure><p>这一看就是相关的依赖又没有添加，所以正当我打算添加libyaml-cpp0.6时，发现直接用Ubuntu自带的apt-get安装只能安装0.7的版本，这就十分尴尬了。当然我尝试过能不能用0.7兼容0.6,显然是不能的，这东西它只认0.6的版本。我还得自己去找这个版本的<code>.deb</code>包。<br>前面说过，本文主要用来记录。所以给出<a href="https://pkgs.org/">下载网站</a>.然后执行dpkg命令，后面跟上需要安装的<code>.deb</code>包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo dpkg -i *******.deb <br></code></pre></td></tr></table></figure><p>之后重新执行以上三条命令就能成功安装了。</p></blockquote><p>为什么我觉得恶心心呢，因为在我的环境下(有可能是软件的BUG也有可能是我本身环境的配置问题)，不知道为什么,当我按下Ctrl与其他按键的组合键的时候，会自动执行原来CapsLock本身的功能，并且会输出一个大写的A之类的字符。</p><p>在我尝试排除过很多可能的问题之后，包括重装，重启，甚至直接从源码编译。我放弃了…..</p><h3 id="xmodmap"><a href="#xmodmap" class="headerlink" title="xmodmap"></a>xmodmap</h3><p>这个方法本身是最简单的，它只用到了xmodmap软件，在很多X11基础的图形化界面中甚至这个软件是自带的。如果没有就下载一个，自行搜索下载方法. 那为什么一开始不用这个方法呢，因为我看网上的教程中说这个方法只能把两个按键交换位置，并不能实现CapsLock在短按和长按分别为不同功能的作用。</p><p>但是经过我在无奈之下的研究，了解xmodmap重映射的原理之后，我发现只用xmodmap也能把CapsLock映射到两个按键的功能，具体实现看下一节的介绍。</p><h2 id="原创解决方案"><a href="#原创解决方案" class="headerlink" title="原创解决方案"></a>原创解决方案</h2><p>首先需要理解键盘的工作原理，这一部分网上有很多博客都在介绍，这里推荐这个<a href="https://www.cnblogs.com/yinheyi/p/10146900.html">博客</a>.</p><p>简单理解就是：键盘上每一个按键按下只是给操作系统发送了一个信号(中断)。比如按下’a’,只是给操作系统发送了一个“38号按键”已经按下的信息，具体对此应该做怎样的处理则交给操作系统来处理。在这个情况下，按下“38号按键”对应的是’a’的编码。</p><ul><li>每一个按键的物理序号和位置都是固定的。(‘a’的位置对应38号按键)</li><li>同时每一个想要真实表达的信息编码也是确定的(如’a’就只能对应0x62,’b’就只能对应0x63).</li></ul><p>所以，能够改变的只是上面两者的对应关系。明白这一点后，再来看看组合键是如何实现的。</p><p><img src="/2024/03/14/esc-ctrl/key_map.png" alt="key_map"></p><p>图中显示的shift,control,lock等是按键按下的功能，举个例子：假如说我按下了左边Shift_L对应位置的按键，正常来说是对应一个“使用者想按下shift而不是a”的信号，所以这时候对应的编码是0x32。</p><p>但是，按下Shift_L之后又有什么用呢？注意到一点，我们单独按Shift是没有任何反应的，说明shift功能本身对应的编码0x32就不会产生任何反应。我们都知道shift组合键的一个最简单的功能就是将其他按键对应的其他字符显示出来，或者切换大小写。</p><p>关键来了,<strong>Shift编号0x32本身是不会产生任何效果的，与0x62编号产生一个a不同。但是我们在这个基础上赋予了0x32按键按下不放开的状态一个新的含义</strong>.由于这个含义是后来赋予的，和键盘硬件以及对应的编码都没有关系。所以其实我们也是可以把这个含义赋予到其他按键编码上面。那为什么不这样做呢？原因就是其他案件都有自己本身产生的效果或者反映，而Shift(0x32)等等这一类的按键编码则没有任何自身的反应,这岂不是绝配?!</p><p>明白了这个shift组合键的原理，再来看conttrol和lock键也就自然能明白了。我在理解这一点之后做的事情很简单，首先将键盘上的Esc与CapsLock键对应的键码交换，所以Esc实现的是转换大小写的功能，CapsLock实现的是退出的功能。然后再将control键的这个状态赋予了Esc的键码(0x42).</p><p>前面说道，shift，control这个状态切换的能力是我们使用者有能力赋予给对应的键码的。所以这里赋予给ESC(0x42)也是没有任何问题的。然后就是考虑功能会不会重叠的问题，实际测试过：按下配置好的CapsLock后会首先给出一个Esc功能的键码给操作系统，再切换状态。</p><blockquote><p>在日常使用中，如果想要按下Esc是只需要按一次的。反正我是没见过有哪种情况需要同时按下Esc和其他的按键。然后进入Control状态再退出，control模式只要你不同时按其他的键相当与没按，啥也不做，所以这个情况是没有任何影响的。</p><p>如果只想要按下Ctrl键，那么意味着自动先输入了一个Escape。这个虽然理论上是会有影响，但是在日常使用中可谓是微乎其微。除非你在看视频的全屏状态下想按下Ctrl组合键，这样会使得你退出全屏。还一点就是，对于使用Vim的人来说，这还是一件好事，因为大多数Ctrl的组合键都是在Normal模式下进行的。这相当于可以直接在Insert模式直接按下Ctrl组合键，然后直接跳转到Normal模式执行想要的命令。</p></blockquote><p>总之这样改完是稍微有一点影响的，不过影响微乎其微。用过才知道真的好用。况且，要是真的有那种需要不先按下Esc直接按Ctrl组合键的需求，原来的左右两个Ctrl这不也没动它吗。</p><h3 id="配置xmodmap"><a href="#配置xmodmap" class="headerlink" title="配置xmodmap"></a>配置xmodmap</h3><p>在家目录下创建一个<code>.xmodmap</code>的配置文件。这里附上我的配置供参考</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs abnf">clear lock<br>clear control <br>add Control <span class="hljs-operator">=</span> Control_L<br>add Control <span class="hljs-operator">=</span> Control_R<br>add Control <span class="hljs-operator">=</span> Escape<br>keycode <span class="hljs-number">9</span> <span class="hljs-operator">=</span> Caps_Lock<br>keycode <span class="hljs-number">66</span> <span class="hljs-operator">=</span> Escape<br>keycode <span class="hljs-number">37</span> <span class="hljs-operator">=</span> Control_L<br></code></pre></td></tr></table></figure><p>因为我的这个配置之前弄得有点混乱，所以我选择一开始全部清除再重新配置，如果是默认的正常配置，那么前4行可以省略。</p><p>可能有同学会在网上看见这样的配置：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">clear <span class="hljs-keyword">Lock</span><br>keysym Caps_Lock = <span class="hljs-keyword">Escape</span><br>keysym <span class="hljs-keyword">Escape</span> = Caps_Lock<br><span class="hljs-keyword">add</span> <span class="hljs-keyword">Lock</span> = Caps_Lock<br></code></pre></td></tr></table></figure><p>一个主要的区别是，被修改的实际键盘上的编号表示方式的不同<code>keycode</code>是用一个不会变的物理编号来表示。<code>keysym</code>是用一个变量来表示,这个等号左边变量名又恰好和等号右边的实际功能名一样。就特别容易混淆，这里推荐还是用<code>keycode</code>表示，清晰又直观。</p><p>配置完成之后就只需要更新配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">xmodmap ~/.xmodmap<br></code></pre></td></tr></table></figure><p>当然一个很自然的想法就是希望能在开机时候自己启动，这样就可以毫无察觉地更改键位了，但是我按照网上的教程尝试过很多方法，包括但不限于:修改.bashrc_profile, 修改.profile,修改crontab周期执行程序,添加脚本到&#x2F;etc&#x2F;init.d&#x2F;,添加system系统服务程序,添加autostart等等。后面三种是我在那照猫画虎，但是前面几种方法我是真没搞懂是哪出的问题。登录后再<code>source ～/.profile</code>都没有问题。我只能是理解成登录后又重新恢复了一下默认配置了。有知道原因的同学麻烦指导指导。</p><p>所以我只能用手动的方式来进行了：创建一个包含开机需要运行一次的脚本<code>start.sh</code>.然后在<code>/usr/local/bin</code>中创建一个软链接<code>startup</code>指向这个脚本。开机后手动执行一次<code>startup</code>，这也是一个暂时的方式了</p><hr><p><em><strong>写在最后</strong></em>：感谢能读到这里，希望没有浪费您宝贵的时间，如果觉得还不错，不要吝啬手中的赞呦~。</p><blockquote><p>其他有关的资料代码放在了<a href="https://github.com/sycamoremoon">sycamoremoon’s github</a>,需要的同学可以自取。</p><p>之后还会有其他的内容上传，希望我的小小努力能够给大家带来帮助</p><p> 这是<a href="sycamoremoon.online">我的网站</a>，内容会随着时间逐渐丰富的..</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>question_records</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unix/Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xv6-lab-Util</title>
    <link href="/2024/03/06/xv6-lab-Util/"/>
    <url>/2024/03/06/xv6-lab-Util/</url>
    
    <content type="html"><![CDATA[<h1 id="xv6-labs-Util-实验记录分析"><a href="#xv6-labs-Util-实验记录分析" class="headerlink" title="xv6-labs-Util 实验记录分析"></a>xv6-labs-Util 实验记录分析</h1><p><em><strong>写在前面</strong></em>:在使用类Unix操作系统中，我对这类操作系统的原理产生了比较浓厚的兴趣，同时这类Unix操作系统也是嵌入式实时操作系统的基础，所以选择跟着<a href="https://pdos.csail.mit.edu/6.828/2020/schedule.html">MIT6.S081</a>这门课程开始学习。<br>    这个类别的文章是我独立通过思考完成labs的记录，便于个人日后复盘以及其他同学参考</p><hr><ul><li><a href="#%E5%90%AF%E5%8A%A8xv6">启动xv6</a></li><li><a href="#sleep">sleep</a></li><li><a href="#ping-pong">ping-pong</a></li><li><a href="#primes">primes</a></li><li><a href="#find">find</a></li><li><a href="#xargs">xargs</a></li></ul><hr><p>相信能够选择学习这门课程的同学应该都对unix环境配置有着一定掌握，根据网络上的教程应该可以配置出这个运行在RISC-V架构下的xv6操作系统,此处附上一篇<a href="https://zhangjk98.xyz/archives/page/5/">博客</a>，能够作为不错的参考。</p><h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p>第一个程序比较简单，直接看代码就可以理解，注意在读取命令行参数时是一个字符串，需要用atoi()库函数转化成整数传递给sleep()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">int</span> <br><span class="hljs-title function_">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> * argv[])</span><br>&#123;<br><span class="hljs-keyword">if</span>(argc &gt; <span class="hljs-number">2</span>)<br>&#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;error of using sleep function&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(argc == <span class="hljs-number">2</span>)<br>&#123;<br>sleep(atoi(argv[<span class="hljs-number">1</span>]));<br>&#125;<br><span class="hljs-keyword">else</span><br>sleep(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ping-pong"><a href="#ping-pong" class="headerlink" title="ping-pong"></a>ping-pong</h2><p>ping-pong这个函数也相对简单，是对进程之间用管道通行的简单实验，涉及到通信的顺序问题，了解wait(),read()的阻塞机制就可以正常完成。源码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc , <span class="hljs-type">const</span> <span class="hljs-type">char</span> * argv[])</span><br>&#123;<br><span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<br><span class="hljs-type">char</span> buf[<span class="hljs-number">1</span>];<br><span class="hljs-type">int</span> pid;<br>pipe(p);<br><span class="hljs-keyword">if</span>((pid = fork())&gt;<span class="hljs-number">0</span>)<br>&#123;<br>wait(<span class="hljs-number">0</span>);<br>read(p[<span class="hljs-number">0</span>],buf,<span class="hljs-keyword">sizeof</span>(buf));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received pong\n&quot;</span>,getpid());<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid ==<span class="hljs-number">0</span>)<br>&#123;<br>write(p[<span class="hljs-number">1</span>],buf,<span class="hljs-keyword">sizeof</span>(buf));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received ping\n&quot;</span>,getpid());<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;fork failed&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h2><p>关于这个实验，我花了不少功夫，一方面是对管道通信的不熟悉，一方面是本身自己的逻辑也不够完善。对得起<strong>hard</strong>这个难度称号了。<br><a href="https://pdos.csail.mit.edu/6.828/2020/labs/util.html">官方给出的提示</a>翻译成<a href="https://xv6.dgs.zone/labs/requirements/lab1.html">中文</a><br>首先给出代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc , <span class="hljs-type">const</span> <span class="hljs-type">char</span> * argv[])</span><br>&#123;<br><span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<br><span class="hljs-type">char</span> buf[<span class="hljs-number">1</span>];<br><span class="hljs-type">int</span> pid;<br>pipe(p);<br><span class="hljs-keyword">if</span>((pid = fork())&gt;<span class="hljs-number">0</span>)<br>&#123;<br>wait(<span class="hljs-number">0</span>);<br>read(p[<span class="hljs-number">0</span>],buf,<span class="hljs-keyword">sizeof</span>(buf));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received pong\n&quot;</span>,getpid());<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid ==<span class="hljs-number">0</span>)<br>&#123;<br>write(p[<span class="hljs-number">1</span>],buf,<span class="hljs-keyword">sizeof</span>(buf));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received ping\n&quot;</span>,getpid());<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;fork failed&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>对于提示中的<strong>For each prime number, you will arrange to create one process that reads from its left neighbor over a pipe and writes to its right neighbor over another pipe</strong> 这句话也没有很明确表示每个prime的process应该是由谁来创建，所以在思考应该如何实现的时候就有了两种方案：</p><ol><li>由子进程来创建新的子进程，最开始的父进程只创建一个进程，后面的执行就交给子进程不断递归实现。所以父进程需要等待所有的子子孙孙进程终止，同时每个子进程也要等待自己创建的子子孙孙进程终止。</li><li>还有一种方案就是将数据的传递交给最后开始的父进程，子进程只负责数据的筛选和打印，完成任务之后就立即终止。这样不断循环直到发生一个终止条件，这样子进程不需要等待任何条件来退出了。</li></ol><p>很显然这两个方案的区别也是经典的递归算法和循环算法的区别，由于我在嵌入式开发这样的环境中基本不使用递归算法，就没有用递归的习惯(其实也不会了..),所以上面的程序用的就是循环来实现的，比较繁琐，远没有递归优美. 同时也出了很多问题，在网上找到的参考全部都是递归实现的，但是秉着递归能实现那么循环也能实现的心态, 一点一点查手册找问题最终真的实现了</p><p>一点小感慨，罗嗦这么久，现在来分析一下这个循环的实现和注意的要点：</p><blockquote><p>在代码的开始给数组初始化赋值就不用多说了，我觉得这个实验最需要注意的点之一就是read()和write()系统调用在管道通信中的使用:</p><ol><li>read()在一般的环境下读取管道都是阻塞的，也就是当有任意的进程打开write文件描述符,并且这个文件描述符和read指向同一个管道。此时read就有可能发生阻塞，一般发生在管道里面没有文件，read在读同时write也没有在往里面写数据的时候。</li><li>read()也有一个最大能读取的字节长度作为参数，不管有没有write文件描述符指向管道，只要管道里面有数据read就能够成功读取，读取的长度小于等于最大字节长度，并返回实际读取到的字节数。但是相反的，要是管道里没有数据，read就不能正常读取，要么阻塞(上文提到),要么发生错误(当没有任何write文件指向管道的时候)，返回-1。</li></ol><p>还有一个要特别注意的点就是关闭不需要用到的文件描述符，在官方指导中是这样说的：<strong>Be careful to close file descriptors that a process doesn’t need, because otherwise your program will run xv6 out of resources before the first process reaches 35</strong>,至于原因是关于文件描述符有一个最大值的limit，不能超过这个limit。</p></blockquote><p>注意到我的代码实现数据传递是用了两个管道来进行数据传递，因为父进程和子进程需要进行双向的通信。虽然管道是可以进行双向通信的，但是为了标识数据的末尾，在一方发送完数据之后就必须关闭管道。这就需要用两个管道分别进行数据从父到子和从子到父的传输。并且如果对一个管道是读操那么作必须关闭对管道write的文件描述符，否则就会导致自己阻塞自己情况。同理，如果对一个管道进行写操作意味着就不能对这个管道read了，需要关闭read文件描述符，目的是为了节省资源也防止阻塞。这一点体现在代码的22,23行和36,37行。</p><p>此外，即使对一个管道只进行的写操作，比如父进程写管道1向子进程通信，在父进程写完之后也要关闭对管道1的write文件描述符，因为此时这个描述符已经属于一个不需要的文件描述符(file descriptor that a process doesn’t need)。同理，对其他不需要的文件描述符也应该关闭。这体现在代码的27,32行和53,58行。之前调试的时候忘记关闭，就导致了一个情况：当数字数目比较小的时候能正常运行，数目变多就发生了各种各样的问题…</p><p>父程序的28行wait()系统调用不是必须的，父进程在从子进程读取的过程会阻塞父进程，一直到58行子进程关闭文件描述符。</p><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>find程序主要参考了xv6系统自己写的ls命令代码，可谓是短小精悍。不多说了，直接上源码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/fs.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/fcntl.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * filename, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * path)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span><br><span class="hljs-type">int</span> fd;<br><span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>] = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//why if I dont initalize this buf, it will go wrong</span><br>   <span class="hljs-type">char</span> * p;<br><br><span class="hljs-comment">//printf(&quot;for the begin the path is %s\nthe buf is %s\n&quot;,path,buf);</span><br><span class="hljs-keyword">if</span> ((fd = open(path,O_RDONLY)) &lt; <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: cannot open current path\n&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>memmove(buf,path,<span class="hljs-built_in">strlen</span>(path));<br>p = buf + <span class="hljs-built_in">strlen</span>(buf);<br><span class="hljs-comment">//printf(&quot;before loop the buf is %s\n&quot;,buf);</span><br><span class="hljs-keyword">while</span>(read(fd,&amp;de,<span class="hljs-keyword">sizeof</span>(de)) == <span class="hljs-keyword">sizeof</span>(de))<br>&#123;<br><span class="hljs-keyword">if</span>(de.inum == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">continue</span>;<br>*p = <span class="hljs-string">&#x27;/&#x27;</span>;<span class="hljs-comment">// p point to where the &#x27;/&#x27; is</span><br>memmove(p+<span class="hljs-number">1</span>,de.name,DIRSIZ);<span class="hljs-comment">//when it copys, the position where p point to is not change</span><br>p[DIRSIZ] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (stat(buf,&amp;st) &lt; <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;find: cannot stat %s \n&quot;</span>,buf);<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">switch</span> (st.type)&#123;<br><span class="hljs-keyword">case</span> T_DEVICE:<br><span class="hljs-keyword">case</span> T_FILE:<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(de.name,filename) == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-type">char</span> ret= <span class="hljs-string">&#x27;\n&#x27;</span>;<br>write(<span class="hljs-number">1</span>,buf,<span class="hljs-built_in">strlen</span>(buf));<br>write(<span class="hljs-number">1</span>,&amp;ret,<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> T_DIR:<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(de.name,<span class="hljs-string">&quot;.&quot;</span>) == <span class="hljs-number">0</span> || <span class="hljs-built_in">strcmp</span>(de.name,<span class="hljs-string">&quot;..&quot;</span>) == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br><span class="hljs-comment">//printf(&quot;before recsive the buf is %s ,filename is %s\n&quot;,buf ,filename);</span><br>find(filename,buf);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">break</span>;<br><br>&#125;<br>&#125;<br>close(fd);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc , <span class="hljs-type">const</span> <span class="hljs-type">char</span> * argv[])</span><br>&#123;<br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span> )<br>&#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;Please input at least one target\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">2</span>;i &lt; argc; i++)<br>&#123;<br>find(argv[i],argv[<span class="hljs-number">1</span>]);<br>&#125;<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>main函数就不多说了，就是一个参数的读取和对find函数的调用。关键是find函数，这其中还包含了不少坑。</p><p>确定基本的思路就是对命令行的参数循环读取，对于每个被查找的文件对象都执行一次find函数。然后find函数再从当前的目录开始对每个目录里面的文件都递归执行相同的步骤。总结就是: <strong>循环对当前目录下的文件遍历，如果发现是普通文件就执行比较文件名的操作;如果是目录文件就再次调用自身</strong>。可以对照ls.c文件查看更容易理解。</p><p>但是其中有这两个细节:</p><ol><li>如果文件名匹配，就需要输出这个文件的完整路径名。一开始我用的是printf标准输出函数，带输出缓冲.C标准规定，对于标准输出函数的缓冲如果是终端等设备，那么默认是 <strong>行缓冲，也就是一行结束冲洗一次缓冲区</strong> ，结束标志也就是我们熟悉的’\n’.直接使用没有任何问题，也能过后面的检测。但是如果将find命令重定向之后再输出，这个时候缓冲策略就变成了 <strong>全缓冲，即要么缓冲区满，要么这个程序执行完毕exit之后才会冲洗缓冲区</strong> 。这也是我在完成后面的xargs命令时发现的一个问题。我找了找这个user&#x2F;user.h文件夹中没有相关的flush函数和改变缓冲策略的函数。所以只能使用不带缓冲的 <strong>系统调用write</strong>了。</li><li>经过实验验证，在递归调用find函数自身的时候，发起调用的函数中的临时变量中的内容会原封不动的复制到被调函数中去。代码的12行定义了一个临时数组，一开始没有进行初始化，导致之前发起调用的函数往buf中填充的数据也给了被调函数。一开始不清楚，后面疯狂插入了好多printf查看变量状态。发现了这个问题<br><img src="/2024/03/06/xv6-lab-Util/find_buf_issue.png" alt="find_buf_issue"><br>别问为什么不用GDB调试，问就是环境没配好，出一些奇怪的BUG。</li></ol><h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><p>开始看见这个xargs的时候非常疑惑，因为我从来没有使用过这个这么强有力的工具，然后又去网上找了xargs的介绍才继续做的。<br>先贴源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/param.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXCMD 9</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXNUM 8</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">xargs</span><span class="hljs-params">( <span class="hljs-type">char</span> * cmd , <span class="hljs-type">char</span> * args)</span><br>&#123;<br><span class="hljs-type">char</span> * vargs[MAXNUM] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">char</span> private_buf[MAXARG] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">char</span> * pchar;<br><span class="hljs-comment">//printf(&quot;before child the args is %s\n&quot;,args);</span><br><span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span> )<span class="hljs-comment">//child process</span><br>&#123;<br><span class="hljs-type">int</span> v = <span class="hljs-number">2</span>;<br>memmove(private_buf,args,MAXARG);<br>vargs[<span class="hljs-number">0</span>] = cmd;<br>vargs[<span class="hljs-number">1</span>] = pchar= private_buf;<br><span class="hljs-keyword">while</span>((pchar = <span class="hljs-built_in">strchr</span>(pchar,<span class="hljs-string">&#x27; &#x27;</span>))!= <span class="hljs-number">0</span> )<br>&#123;<br>*pchar = <span class="hljs-number">0</span>;<br>vargs[v++] = ++pchar;<br>&#125;<br>vargs[v] = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//for(int i=0; i&lt;=v;i++)</span><br><span class="hljs-comment">//printf(&quot;VEC&#x27;s num is %d\nthe vec[%d] is %s\n&quot;,v,i,vargs[i]);</span><br><span class="hljs-comment">//printf(&quot;the cmd is %s\n&quot;,cmd);</span><br>exec(cmd,vargs);<br>&#125;<br><br>wait(<span class="hljs-number">0</span>);<br><br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc , <span class="hljs-type">const</span> <span class="hljs-type">char</span> * argv[])</span><br>&#123;<br><span class="hljs-type">int</span> i;<br><span class="hljs-type">char</span> cmd[MAXCMD] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">char</span> * begin;<br><span class="hljs-type">char</span> argsbuf[MAXARG] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">char</span> streambuf[MAXARG] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">char</span> * p_argv , *p_stream;<br><br><span class="hljs-comment">//printf(&quot;argc is %d\n&quot;,argc);</span><br><span class="hljs-keyword">for</span>(i =<span class="hljs-number">0</span> ;i&lt;argc ;i++)<br>&#123;<br><span class="hljs-comment">//printf(&quot;argv[%d] is %s\n&quot;,i,argv[i]);</span><br>&#125;<br><span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>)<br>&#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;xargs: missing argument\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-built_in">strcpy</span>(cmd,argv[<span class="hljs-number">1</span>]);<br>p_stream = streambuf;<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">2</span>;i&lt;argc;i++)<br>&#123;<br><span class="hljs-built_in">strcpy</span>(p_stream,argv[i]);<br>p_stream = p_stream + <span class="hljs-built_in">strlen</span>(argv[i]);<br>*(p_stream++)= <span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br><br>p_argv = argsbuf;<br><span class="hljs-type">int</span> fnum;<br><span class="hljs-keyword">while</span> ((fnum = read(<span class="hljs-number">0</span>,p_argv,MAXARG)) &gt; <span class="hljs-number">0</span>)<span class="hljs-comment">// read the data from standard input </span><br>&#123;<br>p_argv = p_argv+fnum;<br>&#125;<br><span class="hljs-comment">//printf(&quot;read from pipe is %sthe argsbuf is %s&quot;,p_argv,argsbuf);</span><br>begin = argsbuf;<br><span class="hljs-keyword">do</span>&#123;<br>p_argv = <span class="hljs-built_in">strchr</span>(begin,<span class="hljs-string">&#x27;\n&#x27;</span>);<br><span class="hljs-keyword">if</span>(p_argv != <span class="hljs-number">0</span>)*p_argv = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">strcpy</span>(p_stream,begin);<br>xargs(cmd,streambuf);<br>begin = p_argv+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">while</span>((p_argv = <span class="hljs-built_in">strchr</span>(begin,<span class="hljs-string">&#x27;\n&#x27;</span>)) != <span class="hljs-number">0</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我觉得写这个命令的难点主要在于</p><ol><li><p>对命令行输入和管道数据的读取</p><blockquote><p>数据的读取是在main函数里面完成的,命令行参数读取就不用多说了，一个循环搞定。对管道数据的获取是有一个小坑的,64行的读取文件描述0的内容就是标准输入，但是已经被重定向到之前的一个函数的输出了。不过对于函数xargs自身来说对是否被重定向是一概不知的。所以它 <strong>仍然用处理终端输入的策略来进行数据读取</strong>(行缓冲一次读取一行)，遇到换行符停止，并把换行符留在缓冲区中。所以这里需要循环读取直到读取到EOF。之前只读取一次就出现了漏掉参数的情况。(突然想到大一学c语言的时候，每次scanf之后都需要一个getchar来吃掉最后的换行符，应该是一个道理)</p></blockquote></li><li><p>对获取到的数据进行分隔和组合</p></li></ol><blockquote><p>对数据处理在main和xargs函数中都有了，main中主要负责把整个的数据分成命令字符串、需要传递多次的字符串和只需要传递一次的字符串。传递一次的字符串用’\n’分割，代码的69至77就是处理这个事情，方法显得繁琐，主要是之前没有注意到gets这个库函数。将只传递一次的字符串拼接到传递多次的字符串上,并且和命令字符串一起传递给xargs函数，就算任务完成了。</p><p>对传递过来的一整个字符串，xargs需要对其进行分割，分割的标志就是空格’ ‘，把这一串数据再重构成一个向量。这里实现的方式是先把原始数据拷贝到一个私有数组中，再定义一个指针数组，每个指针都指向一个参数的开始，同时吧原来用于标识分隔的空格改成NULL，这样就相当于有很多独立的字符串了。之后再用exec函数执行(值得注意一点是，参数的第一个指向的字符串是命令的名称，很奇怪对吧).当然以上所用的处理都是在xargs的子程序中执行的了，父程序只需要wait坐享其成就行。</p></blockquote><hr><p>最后附上一张成功通过的截图纪念一下第一次lab<br><img src="/2024/03/06/xv6-lab-Util/grade_test.png" alt="grade_test"></p><hr><p><em><strong>写在最后</strong></em>：感谢能读到这里，希望没有浪费您宝贵的时间，如果觉得还不错，不要吝啬手中的赞呦~。</p><blockquote><p>加以修改后的源代码放在了<a href="https://github.com/sycamoremoon/xv6-labs-2023">sycamoremoon’s github</a>,需要的同学可以自取。</p><p>之后还会有其他的内容上传，希望我的小小努力能够给大家带来帮助</p><p>这是<a href="sycamoremoon.online">我的网站</a>，内容会随着时间逐渐丰富的..</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>xv6-Operating system</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unix/Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初探优雅地解耦代码</title>
    <link href="/2024/02/04/%E4%BC%98%E9%9B%85%E5%9C%B0%E8%A7%A3%E8%80%A6%E4%BB%A3%E7%A0%81/"/>
    <url>/2024/02/04/%E4%BC%98%E9%9B%85%E5%9C%B0%E8%A7%A3%E8%80%A6%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="初探优雅地解耦代码"><a href="#初探优雅地解耦代码" class="headerlink" title="初探优雅地解耦代码"></a>初探优雅地解耦代码</h1><p><em><strong>首先声明：本篇文章的初始版源代码是Clone自GitHub上 <a href="https://github.com/NevermindZZT/cpost">NevermindZZT</a> 大佬，本人只是在这个基础上根据自身理解加以改动和移植。</strong></em></p><p><em><strong>仅用作学习交流，未用作任何商业用途，如有版权问题请联系更改</strong></em></p><hr><ul><li><a href="#%E5%89%8D%E8%A8%80">前言</a></li><li><a href="#CPost">CPost</a><ul><li><a href="#CPost%E4%BD%BF%E7%94%A8">CPost使用</a></li><li><a href="#CPost%E5%AE%9E%E7%8E%B0">CPost实现</a></li><li><a href="#CPost%E7%A7%BB%E6%A4%8D">CPost移植</a></li></ul></li><li><a href="CEvent">CEvent</a><ul><li><a href="#%E4%BD%BF%E7%94%A8">CEvent使用</a></li><li><a href="#CEvent%E5%AE%9E%E7%8E%B0">CEvent 实现</a></li><li><a href="#CEvent%E7%A7%BB%E6%A4%8D">CEvent移植</a></li></ul></li></ul><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>相信经常和单片机打交道的同学肯定看见过类似下面main函数初始化的画面</p><p><img src="/2024/02/04/%E4%BC%98%E9%9B%85%E5%9C%B0%E8%A7%A3%E8%80%A6%E4%BB%A3%E7%A0%81/%E5%A4%8D%E6%9D%82%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0.jpg" alt="初始化"></p><p>同时，在处理中断函数的时候，经常设置一个标志位来标志状态的改变，控制main函数中某些函数的执行与否。</p><p>用裸机进行单片机开发的过程中，曾经我也认为这是理所应当的，直到我偶然间看见了NevermindZZT写的一篇<a href="https://blog.csdn.net/qq_34245464/article/details/111804661">博客</a>，顿时觉得十分神奇，因为这样优雅利索的代码正是我十分向往的。于是我下载了源代码，根据博客和注释像读一本好书一样慢慢品味。</p><p>接下来我会简要分析一下<strong>CPost</strong>和<strong>CEvent</strong>的使用和实现机制，以及如何将这个使用在新版编译器上的代码，<strong>移植到不完全支持C99</strong>的KEIL C51和KEIL C251 编译器上。</p><h3 id="CPost"><a href="#CPost" class="headerlink" title="CPost"></a>CPost</h3><h4 id="CPost使用"><a href="#CPost使用" class="headerlink" title="CPost使用"></a>CPost使用</h4><p>CPost使用方式比较简单，使用支持C99的编译器几乎可以不对源码做任何修改就能够使用。只需设置好本系统的时钟获取函数，在中断函数中用<code>cpost()</code>函数添加handler抛出任务，然后在主函数中用<code>cpostProcess()</code>处理相关的回调函数即可</p><h4 id="CPost实现"><a href="#CPost实现" class="headerlink" title="CPost实现"></a>CPost实现</h4><p>核心有两点，一是弄懂两个结构体的作用，二是明白如何添加handler</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">size_t</span> startTime;<br>    <span class="hljs-type">size_t</span> delay;<br>    <span class="hljs-type">void</span> (*handler)(<span class="hljs-type">void</span> *);            <span class="hljs-comment">//定义了一个返回值为void的函数指针，接受参数为一个任意类型的指针</span><br>    <span class="hljs-type">void</span> *param;                        <span class="hljs-comment">//定义了一个任意类型的指向函数参数的指针                      </span><br>&#125; CpostHandler;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">void</span> *handler;<br>    <span class="hljs-type">void</span> *param;<br>    <span class="hljs-type">size_t</span> delay;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flag : <span class="hljs-number">2</span>;         <span class="hljs-comment">//结构体位段定义两个位存状态</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> paramDiff: <span class="hljs-number">1</span>;<br>    &#125; attrs;<br>&#125; CpostParam;<br></code></pre></td></tr></table></figure><p><code>CpostParam</code>结构体是用户自己定义的，包括指向函数的指针<code>handler</code>,指向参数的指针<code>param</code>,以及抛出任务后<code>delay</code>多久会被响应。</p><p><code>CpostHandler</code>结构体才是CPost真正抛出的任务，相当于封装了一层，和用户使用分隔开便于维护和更新，<code>handler</code>被强制类型转化成了一个<strong>真正的函数指针</strong>，<code>param</code>依旧是参数指针，剩下两个是用于计算延时时间的，使用频率相对不高。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> cpost(...) \</span><br><span class="hljs-meta">        cpostAddHandler(&amp;((CpostParam)&#123;__VA_ARGS__&#125;))   <span class="hljs-comment">//宏定义传递可变参数</span></span><br><span class="hljs-comment">// #define cpost(arg...) \</span><br><span class="hljs-comment">//         cpostAddHandler(&amp;((CpostParam)&#123;arg&#125;))   //等价用arg代替</span><br></code></pre></td></tr></table></figure><p>在C99标准中引入了新的<code>...</code>和<code>__VA_ARGS__</code>宏定义支持可变参数的传递，同时也用到了<strong>复合字面量</strong>生成一个匿名变量仅用来传递参数初始化。在初始化的过程中也可以用到非常方便的<strong>指定成员初始化</strong>，由于是全局变量，所以没有指定默认是0，相当于默认赋初值了，比如<code>cpost(handler, .delay=5000);</code></p><p>以上全部是C99的新标准，技巧十分丰富。至于<code>cpostAddHandler</code>中的具体实现如何，大家有兴趣可以在 <a href="https://github.com/NevermindZZT/cpost">NevermindZZT</a>的GitHub上自行查看，相对容易理解就不赘述了。</p><h4 id="CPost移植"><a href="#CPost移植" class="headerlink" title="CPost移植"></a>CPost移植</h4><p>C99的新标准让编程变得更加优美简洁，但是如果条件要求只能用C51和C251编译器所支持的ANSI C标准，就不得不对原本简洁的代码做出一些妥协了。</p><p>主要需要更改的还是<code>cpost</code>的宏定义,虽然随着版本更新，以上两款老编译器已经支持<code>__VA_ARGS__</code>宏定义，但是想要做到上面的效果还需要支持<strong>复合字面量</strong>的。无奈之下，只能含泪再定义一个函数，充当那个复合字面量的生成，具体代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> cpost(handler,param,delay,flag,paramdiff) \</span><br><span class="hljs-meta">        cpostAddHandler(cpostparaminit(handler,param,delay,flag,paramdiff)) </span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">*   @brief cpostparam 结构体生成</span><br><span class="hljs-comment">*只支持用地址传递一个参数</span><br><span class="hljs-comment">*/</span><br>CpostParam * <span class="hljs-title function_">cpostparaminit</span><span class="hljs-params">(<span class="hljs-type">void</span> * handler,<span class="hljs-type">void</span> * param,<span class="hljs-type">size_t</span> delay,<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flag,<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> paramDiff)</span><br>&#123;<br>CpostParam cpostparam;                 <span class="hljs-comment">//定义了一个参数结构体</span><br>    <span class="hljs-type">size_t</span> i;<br>    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; CPOST_MAX_HANDLER_SIZE; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (cposhHandlers[i].handler == <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            cpostparam.handler = handler;<br>            cpostparam.param = param;<br>            cpostparam.delay = delay;<br>            cpostparam.attrs.flag = flag;<br>            cpostparam.attrs.paramDiff = paramDiff;<br>            <span class="hljs-keyword">return</span> &amp;cpostparam;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说，在函数中定义的<code>cpostparam</code>通过值传递给了<code>cpostAddHandler()</code>函数，最终被销毁。这也导致使用宏定义的时候必须要给出全部参数，并且还要按照固定的顺序:cry:.显得臃肿了很多，但是为了使用也是无奈之举。</p><h3 id="CEvent"><a href="#CEvent" class="headerlink" title="CEvent"></a>CEvent</h3><h4 id="CEvent使用"><a href="#CEvent使用" class="headerlink" title="CEvent使用"></a>CEvent使用</h4><p>CEvent的作用也十分巧妙，核心思想是把事件的导出和事件的执行分离开。这样的机理对于减少代码之间的耦合十分有帮助，添加需要执行的函数只需导出事件，减少执行的函数只需不导出事件即可。</p><blockquote><p>有同学这时候可能要发问了，这样处理和我用一个大的函数比如大的<code>init_all()</code>函数把所有初始化函数全部包括起来有什么区别呢？</p></blockquote><blockquote><p>其实区别是很大的。首先用一个大的 <code>init_all()</code>函数并没有切断主函数和其他模块的联系，需要一个个头文件include所有需要初始化的函数所在的位置，模块中的任何修改都会反映到主函数中函数执行中，这就是耦合。</p><p>其次，在事件执行中，自身根本不知道到底有多少事件需要执行，这完全取决于用户导出的事件数。意思是说：无论有多少函数需要执行，只要导出事件，执行函数就像一台无情的机器全部执行。(当然可以自行添加一些状态表示是否重复执行之类的信息)</p></blockquote><hr><p><em>举个实际例子：</em></p><p>当我需要一个GPIO初始化函数和一个EXTI初始化函数的时候，分别在GPIO和EXTI的源文件中用<code>CEVENT_EXPORT(event——num,func,...)</code>导出事件，然后再在main函数中<code>ceventInit()</code>和<code>ceventPost(event_num)</code>即可完成事件的处理。</p><p><code>event_num</code>是一个标号，用于事件的分类，把需要一起调用、相互之间没有先后关系的事件放在一起。具体数值可由用户设置，更好的方式是定义一个枚举变量，这样对事件的分类更加直观。</p><hr><h4 id="CEvent实现"><a href="#CEvent实现" class="headerlink" title="CEvent实现"></a>CEvent实现</h4><p>CEvent的实现主要是通过一个宏定义:<code>__attribute__((section(x)))</code>,它的详细用法可以参考<a href="https://blog.csdn.net/u012308586/article/details/106251150">博客</a>.简单来说就是把变量、函数在编译的过程中给编译到固定的一个段内(段的名称可以由x设定)，而且数据在段中连续排列。再配合对应的宏定义获取段的初始地址和结束地址，通过运算得到数据的个数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> </span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span> **param;                         <span class="hljs-comment">/**&lt; 参数(包括函数)指向一个数组，数组中存放了指向函数地址的指针和指向参数的指针 */</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> paramNum;               <span class="hljs-comment">/**&lt; 参数数量 */</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> event;                 <span class="hljs-comment">/**&lt; 监听事件 */</span><br>&#125; CEvent;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 导出事件</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param _event 事件</span><br><span class="hljs-comment"> * @param _func 注册函数</span><br><span class="hljs-comment"> * @param ... 参数,参数传递的时候要以地址的形式传递</span><br><span class="hljs-comment"> * @note cEventParam##_event##_func和cEvent##_event##_func是定义的两个变量，一个是存放指针的数组，一个是类型为Cevent的变量</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CEVENT_EXPORT(_event, _func, ...) \</span><br><span class="hljs-meta">        const void *cEventParam##_event##_func[] = &#123;(void *)_func, ##__VA_ARGS__&#125;; \</span><br><span class="hljs-meta">        const CEvent SECTION(<span class="hljs-string">&quot;cEvent&quot;</span>) cEvent##_event##_func = \</span><br><span class="hljs-meta">        &#123; \</span><br><span class="hljs-meta">            .param = cEventParam##_event##_func, \</span><br><span class="hljs-meta">            .paramNum = sizeof(cEventParam##_event##_func) / sizeof(void *), \</span><br><span class="hljs-meta">            .event = _event, \</span><br><span class="hljs-meta">        &#125;</span><br></code></pre></td></tr></table></figure><p>可以得知，事件的导出就是定义了存放在指定的段(cEvent)中的变量，变量中有一个指向数组的指针，该数组又是一个指针数组，里面包含了函数地址，参数地址。多重指针的结构使得参数传递速度很快。剩下的<code>paramNum</code>和<code>event</code>分别是数组中的指针个数和事件标号了。</p><p>导出事件之后，应该获取段的初始地址和CEvent数据个数，否则怎么得知应该从哪里开始执行事件。</p><ul><li><p>简单的方法就是直接获取段的初始地址和数据个数，在需要执行的时候直接从头开始，遍历每一个CEvent校验它的事件号和需要完成的事件号是否相同，如果相同就执行，不同就下一个。这个方法对每一个事件都遍历，效率不是很高，但是优点是不需要额外的内存，而且操作简单。</p></li><li><p>更加高效的方式就是在初始化的时候建立一个索引表，在索引表内将每个CEvent按照事件的编号排序，需要哪一个编号，直接就能通过数组的首地址加偏移量访问到，速度对于大量数据而言较快。下面是实现的源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">size_t</span> maxEvent = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; count; i++)<br>&#123;<br>    <span class="hljs-keyword">if</span> (base[i].event &gt; maxEvent) &#123;<br>        maxEvent = base[i].event;<br>    &#125;<br>&#125;<br>maxEvent += <span class="hljs-number">1</span>;<br>  <br>ceventTable.eventBase = (<span class="hljs-type">size_t</span> **) ceventBuffer;<br><span class="hljs-type">size_t</span> *cur = ceventBuffer + maxEvent;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; maxEvent; i++)<br>&#123;<br>    ceventTable.eventBase[i] = cur;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> j = <span class="hljs-number">0</span>; j &lt; count; j++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (base[j].event == i) &#123;<br>            *cur++ = (<span class="hljs-type">size_t</span>) &amp;base[j];<br>        &#125;<br>    &#125;<br>    *cur++ = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>第一步找出最大的事件标号，得让那个索引表能够得到最远的位置才行嘛。</p><p>第二步就是对CEvent数据的重新排列，将排列好的数据存放在<code>ceventBuffer</code>中。这个<code>ceventBuffer</code>相当于分成了前半部分和后半部分。前半部分就是索引表，每个数据类型都是一个地址，指向后面的部分。后面的部分中存放着在事件导出过程中CEvent数据的实际地址。这样通过两次解引用操作，就能够快速访问CEvent数据了。</p><hr><p><em>同样举个例子：</em></p></li></ul><p>​我定义了两个标号为2的事件和一个标号为3的事件，然后经过初始化排列后，memory中就会变成这样：</p><p>​<img src="/2024/02/04/%E4%BC%98%E9%9B%85%E5%9C%B0%E8%A7%A3%E8%80%A6%E4%BB%A3%E7%A0%81/ceventTable.jpg" alt="CeventTable"></p><p>​其中，0x455是<code>ceventTable.eventBase</code>的地址，地址中存放了<code>ceventBuffer</code>的地址，然后再<code>ceventBuffer</code>中的指针指向关系已经画出。那个0x800、0x807、0x80E就是CEvent的实际地址了。<strong>注意0x807和0x80E之前存在一个0000间隙</strong>，这个间隙是通过上面的函数很巧妙插入的，目的是为了将这个作为一个事件标号的结束，不会在执行事件2的时候把事件3的函数也给执行了。</p><hr><p>剩下的<code>ceventPost(event_num)</code>函数就是执行某一个标号的所有事件了。这个过程比较明了也容易理解，主要是函数指针的使用，此处就不赘述了，可以在<a href="https://github.com/NevermindZZT/cpost">NevermindZZT</a>上下载源码查看。</p><h4 id="CEvent移植"><a href="#CEvent移植" class="headerlink" title="CEvent移植"></a>CEvent移植</h4><p>CEvent的在C51&#x2F;C251编译器上的移植就比较困难了，网络上找遍几乎所有资料都没有，当初我还一度认为不可能。</p><p>首先，最关键的宏定义:<code>__attribute__((section(x)))</code>，在以上两个编译器中不支持，所以问题的核心就是如何用已有的条件替代宏定义:<code>__attribute__((section(x)))</code>。</p><blockquote><p>最初我想到的方法是定义一个最够大的数组来代替段，这样既能保证数据之间是连续的，又能获取数据的长度和首地址。写完还没等我编译我就知道这个方法肯定行不通。因为<code>__attribute__((section(x)))</code>的关键特点就是在编译的过程中就已经让数据刻在内存里面了，而我这样定义一个数组，在程序运行的时候再来写入肯定是不行的，就算能做到也失去了最初降低代码耦合性的目的。</p></blockquote><p>于是我仔细查阅C251的使用手册，发现在使用C251.exe编译器的时候可以加入一些指令，来指导它的编译</p><p><img src="/2024/02/04/%E4%BC%98%E9%9B%85%E5%9C%B0%E8%A7%A3%E8%80%A6%E4%BB%A3%E7%A0%81/directives.jpg" alt="directives"></p><p>可以通过<code>#pragma SYMBOLS</code>类似的预编译语句在源代码中对编译器提出指令。</p><p>别无选择，只能期望这些指令列表中有能实现相关要求的指令了。对于我这种英语一般般的人来说，就算真的有相应的功能，我也不一定能在众多指令中找出我需要的指令。经过反复挣扎，我总算是发现了相应的指令(不然真的得考虑用汇编了:crying_cat_face:)</p><p><img src="/2024/02/04/%E4%BC%98%E9%9B%85%E5%9C%B0%E8%A7%A3%E8%80%A6%E4%BB%A3%E7%A0%81/userclass.jpg" alt="userclass"></p><p>大概意思就是，可以使用类似下面的语句，将变量定义在一个指定的段内</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> userclass (near = app1)</span><br><span class="hljs-type">int</span>    x1;<br><span class="hljs-type">int</span>    x2;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> userclass (near = default)</span><br></code></pre></td></tr></table></figure><p>app1是自己定义的段名称，default是编译器默认的段，查看生成的map文件可以发现，确实做到了在一个特定段内数据连续排列。</p><p><img src="/2024/02/04/%E4%BC%98%E9%9B%85%E5%9C%B0%E8%A7%A3%E8%80%A6%E4%BB%A3%E7%A0%81/stack.jpg" alt="map"></p><p>有了这个编译指令，问题就解决了一大半，剩下的问题下面逐一解决</p><blockquote><ol><li>段的首地址如何获取？C99有专门获取段首地址的宏，但是显然目前所用的编译器不可能支持。</li><li>在不同源文件中定义的段虽然可以命名,但是最后在链接的时候的的最终段名却不同。比如在main.c中定义的叫<code>?ED?APP1?MAIN</code>,在gpio.c中定义的叫<code>?ED?APP1?GPIO</code>,它们之间的顺序却又是链接器随机链接的。</li><li>在<code>CEVENT_EXPORT()</code>的时候，只能有CEvent结构体存入<code>cEvent</code>段，那个存放参数的数组不能一并存入。</li><li>段内数据的个数如何获取？</li></ol></blockquote><ul><li><p>要解决前两个问题，就不得不查阅L251.exe链接器的相关手册了。其实链接器在使用的时候也可以输入相关的指令</p><p><img src="/2024/02/04/%E4%BC%98%E9%9B%85%E5%9C%B0%E8%A7%A3%E8%80%A6%E4%BB%A3%E7%A0%81/link_directives.jpg" alt="link_directives"></p></li></ul><p>​其中正巧又有一条我需要的</p><p><img src="/2024/02/04/%E4%BC%98%E9%9B%85%E5%9C%B0%E8%A7%A3%E8%80%A6%E4%BB%A3%E7%A0%81/segments.jpg" alt="segments"></p><p>找到keil的链接器设置界面，通过这个指令，在<code>User Segments</code>中按照手册的说明配置。段的首地址就可以自己配置，作为一个常量了，<em>问题1解决</em>。按照顺序给出segments的指令，段名也会按照给定的顺序依次排列，所以能够做到<strong>连续</strong>了，<em>问题2解决</em>。</p><ul><li><p>要解决第三个问题就必须给参数数组重新指定内存位置，但这样意味着要把原来的宏定义给拆散，再分别定义，这样异常麻烦。既然对参数数组的存储位置没有要求，那么就把参数数组给扔到外置数据RAM中，加入<code>xdata</code>限定符，再配置<code>xdata</code>的有效范围后。<em>问题3就基本解决了</em>。</p></li><li><p>最后一个问题就是如何确定事件的个数呢？原来的代码的方案是通过宏定义找到段的起始位置和终止位置，然后再除以CEvent结构体的数据长度得到事件的个数。但是目前所用的编译器没有这个宏，也不能这样做了。我想到的方案是<strong>用函数来确定事件的个数</strong>，因为事件的格式是用于初始化函数中，并<strong>不要求在编译的时候确定</strong>，所以这样方案是可行的，代码如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 获取数组中最后连续存放的cevent序号</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-title function_">get_lastcevent</span><span class="hljs-params">(CEvent* event_list)</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;(i&lt;(CEVENT_BUFFER_SIZE/<span class="hljs-number">2</span>));i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(*((*(event_list+i)).param)==<span class="hljs-literal">NULL</span>)<span class="hljs-comment">//param是一个类型为void* 的数组，应该再次取地址获得第一个参数：函数指针</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;                 <span class="hljs-comment">//返回下一个空余位置序号</span><br>&#125;<br></code></pre></td></tr></table></figure><p>只是如果采用这样的方案，就必须确保最后一个的CEvent为空，所以要在最后添加一个空CEvent变量，理论上在哪添加都行，但是我选择在main.c中添加，这样不容易忘记。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> userclass (near=CEVENT)</span><br>CEVENT_EXPORT(<span class="hljs-number">0</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> userclass (near=default)</span><br></code></pre></td></tr></table></figure><hr><p>综上所述，想要在C51&#x2F;C251正常使用CEvent模块，就必须做一些额外的工作了。除了在导出事件的时候应该像上面所示多添加两条编译指令，还应该在L251链接器设置界面配置如下：</p><p><img src="/2024/02/04/%E4%BC%98%E9%9B%85%E5%9C%B0%E8%A7%A3%E8%80%A6%E4%BB%A3%E7%A0%81/link_set.jpg" alt="link_set"></p></li></ul><p><code>xdata</code>可以根据实际情况调整，<code>User Segments</code>中设置好相应的段，段名可以在生成的<code>.map</code>文件中查看，都是有规律的。然后在指定初始地址后按照顺序写在后面即可，注意别忘了最后是一个空的CEvent哦。</p><p>可以在<code>map</code>文件中看到实际的段空间分配内存情况，和预期一样是连续分布的。</p><p><img src="/2024/02/04/%E4%BC%98%E9%9B%85%E5%9C%B0%E8%A7%A3%E8%80%A6%E4%BB%A3%E7%A0%81/final.jpg" alt="final"></p><p><strong>至此CEvent就移植成功了:laughing:</strong></p><hr><p><em><strong>写在最后</strong></em>：感谢能读到这里，希望没有浪费您宝贵的时间，如果觉得还不错，不要吝啬手中的赞呦~。</p><blockquote><p>加以修改后的源代码放在了<a href="https://github.com/sycamoremoon/Classpractice">sycamoremoon’s github</a>,需要的同学可以自取。</p><p>之后还会有其他的内容上传，希望我的小小努力能够给大家带来帮助</p><p>这是<a href="sycamoremoon.online">我的网站</a>，内容会随着时间逐渐丰富的..</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>软件设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言高级编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模拟计算机</title>
    <link href="/2024/01/17/%E6%A8%A1%E6%8B%9F%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    <url>/2024/01/17/%E6%A8%A1%E6%8B%9F%E8%AE%A1%E7%AE%97%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="关于2023全国大学生电子设计大赛综合测评的解析"><a href="#关于2023全国大学生电子设计大赛综合测评的解析" class="headerlink" title="关于2023全国大学生电子设计大赛综合测评的解析"></a>关于2023全国大学生电子设计大赛综合测评的解析</h1><p><em>首先感谢给予<strong>宝贵指导的老师和学长</strong>，没有他们的循循善诱，我可能还是停留在原地徘徊</em></p><p><em>其次，关于写这次博客的动机是在仿真电路和焊接实物的过程中本人遇到了一些问题，想通过博客的形式记录下来供自己和大家参考。顺便弥补一下网络上关于这个题目资源相对较少的遗憾。</em></p><hr><h2 id="首先是对题目的解读"><a href="#首先是对题目的解读" class="headerlink" title="首先是对题目的解读"></a>首先是对题目的解读</h2><p>这里推荐BiliBili上中量大求是电子协会的视频，<a href="https://www.bilibili.com/video/BV1Cu4y1q7U1/?spm_id_from=333.337.search-card.all.click&vd_source=afefae5b8dc3c6db1130aadd8eaadc5f">链接在此</a>,由于该视频已经讲得很详细和通俗易懂，本文直接给出结论供大家进行分析。</p><p><img src="/2024/01/17/%E6%A8%A1%E6%8B%9F%E8%AE%A1%E7%AE%97%E6%9C%BA/%E9%A2%98%E7%9B%AE.png" alt="题目"></p><p>测评的时候会提供<em><strong>两片4运放的LM324和各型号的电阻电容数量不限，以及二极管1N4007数量不限。</strong></em></p><p>相信很多同学和我一样在看见这个题目的时候就感觉十分懵，出题人也考虑到了这一点，所以后面还有作为附录的对题目的提示。</p><p><img src="/2024/01/17/%E6%A8%A1%E6%8B%9F%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%8F%90%E7%A4%BA.png"></p><p>根据提示和相关的高等数学的知识，方程求解的框图可以化简为如下所示。具体推导过程可以在上述的<a href="https://www.bilibili.com/video/BV1Cu4y1q7U1/?spm_id_from=333.337.search-card.all.click&vd_source=afefae5b8dc3c6db1130aadd8eaadc5f">视频</a>中看见。</p><p><img src="/2024/01/17/%E6%A8%A1%E6%8B%9F%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%8C%96%E7%AE%80%E5%90%8E%E7%9A%84%E6%A1%86%E5%9B%BE.png" alt="化简后的框图"></p><p>分析到这里，想要完成题目要求就可以大致分为以下几个模块</p><blockquote><ul><li>制作波形发生器</li><li>制作一个加法电路</li><li>制作两个积分器</li><li>按照合适的顺序、选择合适的电路参数将以上部分连接起来。</li><li>考虑正弦波和三角波的相位，使得三角波和正弦波同频同相（<em>听说这个在实际考察中可有可无</em>）</li></ul></blockquote><h2 id="开始电路仿真"><a href="#开始电路仿真" class="headerlink" title="开始电路仿真"></a>开始电路仿真</h2><p>使用Multisim作为仿真软件如下所示</p><ol><li><p><strong>制作波形发生器</strong></p><blockquote><p>波形发生电路可以分成大致两个思路：</p><ul><li>用文氏桥正弦波发生电路选频发生一个正弦波，之后对正弦波进行迟滞电压比较器的波形变换成方波，然后通过积分电路把方波积分成三角波。*(注：关于这个方法对相位的处理又有两种方法，分别是在正弦波变化成方波时不考虑相位，然后通过全通滤波器移相；还有一种方法是在迟滞电压比较器波形变换的同时将方波的相位移动90度，之后积分再相移90度就回来了，实现的大致思路是：确定比较的临界点分别为正弦波的最大峰值和最小峰值，可以通过调节正反馈反馈电阻的大小改变反馈因子$\beta$,但是还存在一个问题是LM324不是轨到轨的运放，所以即使反馈因子$\beta$相同反馈回来的电压也不同，解决办法就是添加一个偏置电压。<em>反馈电压低是吧，那我朝你那边偏，你即使低我也可以达到我想要的阈值电压，同理如果你反馈回来的电压高，我离你远一点，这样一互补，不就可以达到我想要的阈值电压了</em>)*</li><li>还有就是用一个阻尼振荡器直接发生一个方波，之后对这个方波进行处理，比如滤波、积分的操作。这种方法貌似对相位的处理只有加全通滤波器了。因为我就是用的这种方法，所以会在下面进行详细说明。</li></ul></blockquote></li></ol><ul><li>方波发生部分如下：</li></ul><p><img src="/2024/01/17/%E6%A8%A1%E6%8B%9F%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%96%B9%E6%B3%A2%E5%8F%91%E7%94%9F.png" alt="方波"></p><p>如图所示方波发生部分就是由简单的阻尼振荡器变形而来，频率由C1和R3的大小决定，但是实际操作的时候还是得用滑动变阻器慢慢调。</p><p>主要有两个关键的地方要注意，原因还是这个LM324不是轨到轨的运放导致。一是震荡出来的方波（图中红色的波形）不对称，含有直流分量，二是在图中的正反馈回路中区分了正电压和负电压流经的反馈通路，因为这个<strong>运放的正电压只能到3.5V左右而负电压能够达到-5V左右</strong>，如果不加以区分就会导致震荡出来的方波占空比严重失衡，仿真上不太能看出来，但是实物就非常明显，这会导致后面的波形<strong>全部失真</strong>，所以用二极管加上滑动变阻器调节占空比。最后滤去直流分量的波形如仿真图中绿色波形所示。</p><img src="不对称的方波.jpg" alt="不对称的方波" style="zoom:33%;" /><ul><li><p>三角波和正弦波发生如下</p><img src="三角波和正弦波.png" alt="三角波和正弦波" style="zoom:50%;" /></li></ul><p>众所周知，方波经过积分之后就是三角波，而利用小学二年级学过的傅里叶变化对三角波分解可以得到三角波是由一系列的正弦波叠加而成的。基波的频率为题目要求的600rad也就是大概95.4Hz。由于只有奇数次谐波，所以我们在滤波保留基波时只能把下限截至频率选取在100~300Hz之间，考虑到留有一定裕量和元器件的误差，在计算的时候就先用的200Hz作为近似，再用现有的元器件参数去作近似，应该不会超出这个范围。</p><p>在积分的时候要在电容上方并联上一个大电阻，目的是为了在非理想运放存在输入失调电压和输入失调电流的时候提供一个直流通路，以至于不会使运放输出饱和，这是一个很现实的应用。</p><p>滤波电路采用了二阶的切比雪夫低通滤波器，能过获得在转折频率之外更加陡峭的滚降。如图可见该滤波器的直流增益为单位1，这是一种常用单位增益Sallen-Key的形式。</p><img src="滤波器.png" style="zoom:50%;" /><p> 经过拉氏变换后s&#x3D;j$\omega$,传递函数为<br>$$<br>A(s)&#x3D;\frac{1}{1+\omega_CC_1(R_1+R_2)s+\omega_C^2R_1R_2C_1C_2s^2}\<br>$$<br>$$<br>a_1&#x3D;\omega_CC_1(R_1+R_2)\<br>$$<br>$$<br>b_1&#x3D;\omega_C^2R_1R_2C_1C_2<br>$$<br>计算可以得到<br>$$<br>R_1&#x3D;\frac{a_1C_2-\sqrt{a_1^2C_1^2-4b_1C_1C_2}}{4\pi f_CC_1C_2} \<br>$$<br>$$<br>R_2&#x3D;\frac{a_1C_2+\sqrt{a_1^2C_1^2-4b_1C_1C_2}}{4\pi f_CC_1C_2} \<br>$$<br>$$<br>C_2\geqslant C_1\frac{4b_1}{a_1^2}<br>$$<br>根据上述公式，选取截止频率和C1、C2，注意保证C1和C2的关系要保证满足最后一个$\geqslant$，然后再根据查表得来的a1和b1可以计算出R1和R2，最后只需要将元件按照上图所示连接即可，感兴趣的同学也可以自己推导传递函数和公式。</p><ul><li><p>全通滤波器</p><img src="全通滤波器.png" alt="全通滤波器" style="zoom:50%;" /></li></ul><p>最后全通滤波器的部分比较简单，连好电路后转转滑动变阻器合适即可</p><ol start="2"><li><strong>信号运算处理部分</strong></li></ol><ul><li><p>加法电路</p><p>根据原来的分析结果可以看出：加法器的作用是为了将输入信号与最后的结果相减，由提示信息可知外部输入信号$u_i$应该乘以一个系数$b_0&#x3D;3\times10^4$,再和最后的输出结果$u_o$乘以一个系数$a_0&#x3D;4\times10^4$相加，但是这么大的系数肯定不能直接乘，否则必然饱和。注意到上图中加法器输出后有一个 $\frac{1}{k_1k_2}$了吗？这个意思是可以将结果先衰减之后再进行运算，那么既然要衰减，为什么不直接不乘以这个系数呢:joy:？所以我的方法是将$4\times10^4$作为$k_1k_2$,放在之后的积分电路中作为因数慢慢乘进去。同时为了统一性，输入信号在进入加法器的时候应该先衰减$\frac{3}{4}$,这样之后乘以$4\times 10^4$就相当于乘了一个$3\times10^4$。</p><img src="加法器.png" alt="加法器" style="zoom:50%;" /><p>加法器下面这一堆就是题目中所述的初始条件$u_0&#x3D;1V$</p></li><li><p>积分电路</p><p>对于一个简单的一阶有源积分器来说，它的积分系数就是$\frac{1}{RC}$,由于要积两次，所以我每个积分器给了200的系数，这一环节没有什么难度，只是要注意积分的同时要提供直流通路即并上一个大电阻。</p><img src="积分器.png" alt="积分电路" style="zoom:50%;" /></li></ul><p>同样,开关S2作为题中要求的初始条件$\frac{du_o(0)}{dt}&#x3D;0V&#x2F;s$ </p><ol start="3"><li><p>仿真结果演示</p><p><strong>不能保证我的结论一定正确</strong>，但是经过我仿真和实物焊接的过程中我发现这个结果的输出<strong>不是一个稳态</strong>，输出结果变化如下所示：</p><img src="结果变化.png" alt="结果变化" style="zoom:75%;" /><p>最终波形变成了一个正弦波：</p> <img src="最终结果.png" alt=" 最终结果" style="zoom:50%;" /></li></ol><p>可以发现，最终这个波形的输出是一个变化的过程，变化快慢随着积分电路上并联电阻的大小变化，电阻越大变化越慢，我并联的20M欧电阻都能明显看见，如果只有几百千欧姆那变化就是一瞬间的事情。那么有同学就想问了：如果断路不就相当于电阻无穷大，这样不就是稳态了？这个对于仿真来说是成立的，可以试着把电阻给断路，结果还真的就是稳态，但是实物焊接中,由于有各种各样的现实因素，结果却不是这样，请往下看。</p><h2 id="开始实物焊接"><a href="#开始实物焊接" class="headerlink" title="开始实物焊接"></a>开始实物焊接</h2><p>焊接电路板是个技术活，如何能够节省空间、减少跳线、以及最小化噪声的干扰等等。显然我做得都不好，将就着看看：</p> <img src="正面.jpg" alt="正面" style="zoom:50%;" /><p>运放是双电源供电所以用了两组5V的电源，蓝色的线是引出给示波器用的线，用了两个机械按键用来提供初始条件，还有一堆滑动变阻器。</p><img src="反面.jpg" alt="反面" style="zoom:50%;" /><p>反面更是狼狈不堪，用了很多跳线，导致在焊接的时候经常出现线断掉的情况，搞得人一惊一乍的。然后就是用了一些贴片元件，比如贴片电阻、贴片电容和贴片二极管（为了方便，实际测评的时候是没有的），看具体情况焊接上去耦电容，去掉噪声干扰，一般使用0.1uF的电容接在电源到地之间。</p><ul><li>示波器观察波形</li></ul><p>方波、正弦波、三角波波形发生如下</p><img src="图片1.jpg" alt="方波" style="zoom:50%;" /><img src="图片2.jpg" alt="方波" style="zoom:50%;" /><img src="图片3.jpg" alt="方波" style="zoom:50%;" /><p>当输入为正弦波时，输出结果如下：</p><img src="图片4.png" alt="方波" style="zoom:50%;" /><p>由图可见当给出初始条件后，波形开始衰减，但是实物焊接出来波形衰减很快，大概在1秒钟后就衰减成了下图的正弦波</p><img src="图片5.png" alt="方波" style="zoom:50%;" /><p>我开始觉得十分奇怪，以为是电路搭错了，因为一开始我不清楚这个输出波形不是稳态（在仿真的时候积分器没有并联电阻，所以输出波形看上去没有变化），最后问了老师才知道原因所在。</p><p><strong>但是无论我在积分电路的电容上并联多么大的电阻抑或是直接断路，这个输出波形衰减的速度依旧很快</strong>，至今还是没有找到原因，也不清楚电路实际连接出来到底是不是本来就衰减很快。</p><p>其余的情况分别是无输入和输入为三角波的情况。结果类似，忘记拍照记录了，但是依旧是衰减很快。</p><p><strong>由于网上没有太多参考案例，关于这个结果也拿不准，欢迎讨论</strong></p><hr><p><em><strong>写在最后</strong></em>：感谢能读到这里，希望没有浪费您宝贵的时间，如果觉得还不错，不要吝啬手中的赞呦~。</p><blockquote><p>综合测评题目和电路仿真放在了<a href="https://github.com/sycamoremoon/Classpractice">sycamoremoon’s github</a>,需要的同学可以自取。</p><p>之后还会有其他的内容上传，希望我的小小努力能够给大家带来帮助</p><p>这是<a href="sycamoremoon.online">我的网站</a>，内容会随着时间逐渐丰富的..</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>硬件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电路设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCD1602-driver</title>
    <link href="/2023/12/04/LCD1602/"/>
    <url>/2023/12/04/LCD1602/</url>
    
    <content type="html"><![CDATA[<h1 id="手把手教你写LCD1602驱动代码"><a href="#手把手教你写LCD1602驱动代码" class="headerlink" title="手把手教你写LCD1602驱动代码"></a>手把手教你写LCD1602驱动代码</h1><p><em><strong>写在前面</strong></em>：本文是本人某种意义上写的第一篇blog，如有错误请留言指正。具体内容以官方手册内容为准<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[HD44780's datasheet download](https://www.alldatasheet.com/datasheet-pdf/pdf/63663/HITACHI/HD44780U.html)">[1]</span></a></sup>。 </p><p>首先我们要知道LCD1602屏幕驱动的背后也是有一块类似显卡的芯片<strong>HD44780U</strong>在作为驱动，当然这块上世纪的芯片当然不能和最新的4090相比，它的显存只有可怜的80bytes，但是这对于很多应用场景来说已经够用了，这也是这块芯片能够经久不衰的原因。此处附上<a href="https://www.alldatasheet.com/datasheet-pdf/pdf/63663/HITACHI/HD44780U.html">DataSheet下载网址</a>，现在就让我们正式开始这块芯片的学习吧。</p><p><em><strong>HD44780U</strong></em>以下简称44780</p><hr><h2 id="44780的内部资源"><a href="#44780的内部资源" class="headerlink" title="44780的内部资源"></a>44780的内部资源</h2><p><img src="/2023/12/04/LCD1602/HD44780U_block_diagram.png" alt="HD44780U内部结构"></p><ol><li><p>44780中最重要的就是它的寄存器和存储器了，寄存器分别是指令寄存器IR和数据寄存器DR，存储器又分为DDRAM，CGROM和CGRAM了，下面一一为大家解释他们的含义。</p><ul><li><p>IR寄存器叫指令寄存器，只能通过MCU发出指令才能改变IR，它相当于一个指挥者，指挥着这块芯片的所有行为，信息可以包含屏幕的显示与否，光标的显示与否，还有RAM的地址信息等</p></li><li><p>DR寄存器叫数据寄存器，它负责数据在MCU和44780之间的传递，MCU需要读取或者写入信息到44780的时候才用到。DR自动地完成了数据在DDRAM和CGRAM中的传输，意思是我们如果想要往DDRAM或者CGRAM中写入或者读取数据，只需要访问或者修改DR即可。我们一般能够使用44780自带的字库就已经够了，所以只需要往DDRAM中写入数据，除非需要自己往44780中写入数据或者读取状态信息。</p></li><li><p>DDRAM全称叫Display Data RAM，顾名思义它的作用是实际显示字符。所有在DDRAM中的8-bit character codes 都会以对应character 显示出来。它是是一个80 x 8bit的RAM，所以最多能够显示80个字符，但是实际上不能显示如此之多，需要外部的硬件驱动扩展，这点我们之后再讨论。</p></li><li><p>对应的CGROM全称叫Character Generator ROM。CGROM中每一个8位地址都确定了对应的5 x 8 bit 或者 5 x 10 bit 数据，此外ROM为只读存储器，它在出厂时就已经确定，一共有208个5 x 8 bit 的数据和32个5 x 10 bit的数据，用户不能更改一般我们买到的都是欧版和日版。</p></li><li><p>用户可以更改的时CGRAM，CGRAM实际上是有16个5 x 8 bit 的物理存储单元，和CGROM合计256个单元。但是我们只能使用其中的8个物理存储单元因为对于CGRAM的地址来说低字节的第三位是无效位，详细分析请看<em>“在CGRAM中自定义数据”</em>。</p><p>此处附上欧版CGRAM和CGROM的字库</p><p><img src="/2023/12/04/LCD1602/characters.png" alt="character"></p></li></ul></li><li><p>44780中还有两个重要的内部结构分别是BF和AC，尤其AC是芯片运行至关重要的结构。</p><ul><li>BF叫Busy Flag 是44780的忙信号，它在不忙的时候是0，在忙的时候是1。那什么时候忙什么时候不忙呢：读者有没有记得在之前说过DR寄存器负责数据的传输，这个过程是芯片内部自动执行，这个过程是MCU不可控制的，所以需要一个标志来表示结束信号。此外，根据芯片手册，当芯片处于忙状态时是不会接受下一条指令的，甚至如果这个时候再发送指令到IR，芯片不仅不会接受而且会花上成倍的时间去调整，可谓是得不偿失，所以大家在写指令之前一定要先确认44780处于空闲状态。</li><li>AC叫Address Counter，它记录着DDRAM的地址和CGRAM的地址信息，AC初始是0，当读取DDRAM和CGRAM的数据后，AC根据后面介绍的设定自动加一或者减一。AC的改变可以用指令进行，当执行写地址指令后，AC的地址会变成在IR地址中包含的地址信息。这一点在刚开始引起了我的不解，现在仍旧想到有两种方式解释：一是AC中有两个独立的寄存器分别存储DDRAM和CDRAM的地址信息，二是AC通过一种译码方式确定了地址是属于DDRAM还是CGRAM，毕竟DDRAM是7位地址，CCGRAM是六位地址。总之无论是哪种方式，外部看来结果都一样，在操作之前都要通过写地址指令来确定位置。</li></ul></li></ol><hr><h2 id="44780的常规指令操作"><a href="#44780的常规指令操作" class="headerlink" title="44780的常规指令操作"></a>44780的常规指令操作</h2><p>Let’s take a quick look of these instructions,读者有可能和我刚开始一样云里雾里，但是没关系我会解释的。</p><p><img src="/2023/12/04/LCD1602/instruction.png" alt="instructions"></p><p>这些指令可以被分成4类，分别是写命令，写数据，读命令，读数据</p><ol><li>我们先来看看写命令和写数据，他们都是属于往44780中写的范畴，一个是往IR中写一个是往DR中写，要完整无误地进行操作，首先还是得看看44780的写操作时序</li></ol><p>​<img src="/2023/12/04/LCD1602/write.png" alt="Write"></p><p>​由图中可以看出，在改变RS、RW状态后，需要一个短暂的t<sub>AS</sub>来建立地址，手册中给的是40ns，但是12MHz单片机最短延迟时间是1us，所以就按照1us来处理。为了方便，<strong>因为所有的操作延迟时间都低于1us，所以就按照1us来延迟</strong>，这样我们得到了第一个延迟时间点，接下来给出使能信号enable，图中显示enable分别有一个rise time和 fall time，以及高电平保持时间不小于PW<sub>EH</sub>,为了保险起见此处再次延时1us，然后将数据送入总线BUS，此时enable还是保持有效状态，数据也有一个最短建立时间t<sub>DSW</sub>,所以再次延时1us，注意此时的延时1us并不是代表1us后数据就已经能够发挥作用，而是代表这个时候才能被44780所读取，所以在1us后再改变的话，44780读到的数据是改变之后的那一个。真正能把数据锁存住 的信号是enable的下降沿，当enable的下降沿到来时这个指令周期内BUS上的数据如何变化都和44780无关了。刚学的时候，很容易混淆<strong>操作延迟时间</strong>和<strong>指令延时时间</strong>。操作延迟时间很短，大多在ns级别，而指令延迟时间却在us级别，需要在所有的引脚电平变化完成后再额外指令操作延时，这一点在大多数教程中是没有明确指出的。</p><blockquote><p><strong>写指令</strong>代码示例如下</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">LCD1602_COMMAND</span><span class="hljs-params">(uchar cmd)</span><br>&#123;<br> <span class="hljs-keyword">while</span>(Check_Busy());<br> LCD_RS=<span class="hljs-number">0</span>;<br> LCD_RW=<span class="hljs-number">0</span>;<br> _nop_();<span class="hljs-comment">//Address set-up time</span><br> LCD_EN=<span class="hljs-number">1</span>;<br> _nop_();<br> BUS=cmd;<br> BUS=cmd;<br> _nop_();<span class="hljs-comment">//Data set-up time</span><br> LCD_EN=<span class="hljs-number">0</span>;<br> BUS = <span class="hljs-number">0</span>; <span class="hljs-comment">//当enable下降沿到来时，数据已经被所存住，所以这个时候改变也不会影响</span><br> Delay_us(<span class="hljs-number">500</span>);<span class="hljs-comment">//instruction implement time</span><br>&#125;<br></code></pre></td></tr></table></figure><p>读指令类似，只需要将RS变成1即可</p><ol start="2"><li>接下来就是读命令和读指令操作了，依旧，我们先来看看读操作的时序图</li></ol><p><img src="/2023/12/04/LCD1602/read.png" alt="Read"></p><p>由于读操作确实不太常用，而且编程思想和写操作类似，所以在次就简单描述。在配置完RS和RW状态后，仍然需要一段延时来建立地址，之后就是使能信号的置一，与写操作不同的是：此处使能信号之后的延时并不是可选的了，而是必须的。因为需要等待t<sub>DDR</sub>的Data delay time之后才能读取到有效的数据，所以此处<strong>必须</strong>延时1us。由于延时了1us，所以PW<sub>EH</sub>也顺利保持，之后只需要直接置enable为0即可。</p><blockquote><p><strong>读数据</strong>的示例如下</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">uchar <span class="hljs-title function_">Read_Data</span><span class="hljs-params">()</span><br>&#123;<br> uchar data_result;<br> <span class="hljs-keyword">while</span>(Check_Busy());<br> LCD_RS=<span class="hljs-number">1</span>;<br> LCD_RW=<span class="hljs-number">1</span>;<br> BUS=<span class="hljs-number">0xff</span>;<span class="hljs-comment">//读取数据之前要先置一</span><br> _nop_();<span class="hljs-comment">//Address set-up time</span><br> LCD_EN=<span class="hljs-number">1</span>;<br> _nop_();<span class="hljs-comment">//Data delay time，</span><br> data_result = BUS;<br> LCD_EN=<span class="hljs-number">0</span>;<br> <span class="hljs-keyword">return</span> data_result;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>读指令</strong>的示例如下</p><p><em><strong>值得注意的是读指令不需要检查忙信号</strong></em>，因为读指令比较特殊，在BF为1的时候也能执行，否则怎么知道BF到底为多少？哈哈哈。另一方面来说Check busy函数本身就调用了读指令函数，这会导致递归调用而且没有终止条件，这个错误是致命的。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"> uchar <span class="hljs-title function_">Read_Busyflag_and_AD</span><span class="hljs-params">()</span><br>&#123;<br> uchar BF_AD_result;<span class="hljs-comment">//读指令不需要checkbusy</span><br> LCD_RS=<span class="hljs-number">0</span>;<br> LCD_RW=<span class="hljs-number">1</span>;<br> BUS=<span class="hljs-number">0xff</span>;<br> _nop_();<span class="hljs-comment">//Address set-up time</span><br> LCD_EN=<span class="hljs-number">1</span>;<br> _nop_();<span class="hljs-comment">//Data delay time</span><br> BF_AD_result = BUS;<br> LCD_EN=<span class="hljs-number">0</span>;<br> <span class="hljs-keyword">return</span> BF_AD_result;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>读指令返回的结果有两部分，一部分是BF的状态，一部分是AC的当前值，也就是执行完上一条指令之后的值。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">bit <span class="hljs-title function_">Check_Busy</span><span class="hljs-params">()</span><br>&#123;<br> bit result;<br> result = (bit)(Read_Busyflag_and_AD()&amp;<span class="hljs-number">0x80</span>);<br> <span class="hljs-keyword">return</span> result;<span class="hljs-comment">//BF=1,the next instruction will not be accepted.</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><p>有了最基础的4个指令之后，就可以开始写更详细的上层功能实现了，由于这一部分网络上资源较多，所以为了不占用太多篇幅，我就挑选一个来详细说明。今天是12月4号，那就挑选第四个吧，我们看第四个：Cursor or display shift</p><p>指令的前两位代表RS和RW，由于是写指令所以都为0，接下来3位的也全部是0，直到DB4才出现从高位到低位的首个1，细心的同学可能已经发现，44780正是通过这种判断首个高位出现的位置的方式来判断到底这个指令属于哪一个类别。DB3是选择移动的是cursor还是display，如果为1，则每执行一次这个命令，背景整个移动一次，如果为0则背景不动，光标移动。注意一点：<strong>光标移动没有改变DDRAM中的数据</strong>，实际上光标移动的本质就是AC发生了变化，没有写数据的指令，DDRAM当然不会变了。</p></li></ol><hr><h2 id="在CGRAM中自定义数据"><a href="#在CGRAM中自定义数据" class="headerlink" title="在CGRAM中自定义数据"></a>在CGRAM中自定义数据</h2><p><em>这部分内容属于了解即可，如果不是为了特殊需求，CGROM中的字库完全足够使用</em></p><ol><li>44780在上电之后需要初始化，而初始化所需要执行的指令除了设置光标，清屏等个性化操作之外，有一条十分重要的指令，在instructions图中有说到，那就是Function set指令，该指令必须放在所有指令之前执行，并且执行一次后不能修改。我们先来看看这条指令的详细说明</li></ol><p><img src="/2023/12/04/LCD1602/function_set.png" alt="function set"></p><p>该指令DL选择数据位长度，可以为4位或者8位，一般都是8位，除非IO口不够或者MCU是4位的。</p><p>N位选择屏幕显示的模式：可以为一行显示和两行显示，正常来说都是两行。</p><p>F位选择显示在屏幕上的字体格式，有5 x 8 bit和5 x 10 bit，选择好后这个44780芯片的工作就按照选择的模式进行了</p><ol start="2"><li>我们之前说到，CGRAM只有8个编码的位置能够写自定义数据，那么如何找到这8个位置呢？仍然以5 x 8 bit为例，5 x 10 bit类似。</li></ol><p><img src="/2023/12/04/LCD1602/custom_data.png" alt="custom data"></p><p>​我们想要自定义数据，本质上就是要在CGRAM中写入数据对应的信息，而CGRAM根据characters图片可知是在地址编码的前16位(00000000-00001111)，但是根据上图可知第3位为无效位<strong>‘*’</strong>，所以实际上只有8个逻辑地址能够让用户自己写入数据，在写入之前，需要先设定想写入的位置。比如1号(00000001)位置，那么就需要将AC的地址设置为CGRAM，然后往对应的CGRAM地址写入8位的数据，但其中仅低5位有效。每一个逻辑地址对应的8个CGRAM地址都需要写入一个8位的数据，所以总共写8次，对应到这个情况就是往(001000-001111)每个位置都写一次。数据为1对应的像素亮，为0对应的像素灭。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// store the chars into the CGRAM  </span><br>Set_CGRAM_Address(<span class="hljs-number">0x40</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">8</span>; i++) Write_Data(cc1[i]);<br></code></pre></td></tr></table></figure><p>由于第三位无效，所以在引用0号位置的时候，可以往DDRAM中写入0x00或者0x80，都会显示同一个字符。</p><p>5 x 10 bit 的自定义数据写入和8 bit类似，读者可以根据下图自行写入</p><p><img src="/2023/12/04/LCD1602/custom_10bit.png" alt="10bit custom"></p><p>虽然这个模式不常用，但是读者如果在写入时要注意characters code 的无效位为0，3位，characters pattern的后5个字节也无关。</p><hr><h2 id="使用时的注意事项"><a href="#使用时的注意事项" class="headerlink" title="使用时的注意事项"></a>使用时的注意事项</h2><ul><li>要在合适的工作电压下使用，这样才能保证44780上电后的初始化正常执行。如果电压不稳定，导致自动初始化没有正常完成，此时44780工作会发生异常。解决方法是手动多次初始化( function set)</li></ul><hr><p><em><strong>写在最后</strong></em>：感谢能读到这里，希望没有浪费您宝贵的时间，如果觉得还不错，不要吝啬手中的赞呦~。</p><blockquote><p>LCD1602的驱动代码放在了<a href="https://github.com/sycamoremoon">sycamoremoon’s github</a>,需要的同学可以自取。</p><p>之后还会有其他的内容上传，希望我的小小努力能够给大家带来帮助</p><p> 这是<a href="sycamoremoon.online">我的网站</a>，内容会随着时间逐渐丰富的..</p></blockquote><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.alldatasheet.com/datasheet-pdf/pdf/63663/HITACHI/HD44780U.html">HD44780’s datasheet download</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>硬件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>外设驱动开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello_world</title>
    <link href="/2023/12/03/Hello-world/"/>
    <url>/2023/12/03/Hello-world/</url>
    
    <content type="html"><![CDATA[<img src="/2023/12/03/Hello-world/Hello_World.jpg" class="" title="this is my first blog"><p>Welcome to my blog ! This is my very first post. I want to share you something I like.</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
